"use strict";
process.title = 'hpserver';

// debug options
const DEBUG1 = true;       // basic debug info - file loading, hub loading
const DEBUG2 = false;
const DEBUG3 = false;
const DEBUG4 = false;
const DEBUG5 = false;
const DEBUG6 = false;
const DEBUG7 = false;
const DEBUG8 = false;
const DEBUG9 = false;
const DEBUG10 = false;
const DEBUG11 = false;
const IGNOREPW = false;

// websocket and http servers
var webSocketServer = require('websocket').server;
var webSocketClient = require('websocket').client;
var path = require('path');
var http = require('http');
var fs = require('fs');
var express = require('express');
var bodyParser = require('body-parser');
var parser = require('fast-xml-parser');
var xml2js = require('xml2js').parseString;
var crypto = require('crypto');
const UTIL = require('util');

// load supporting modules
var utils = require("./utils");

// global variables are all part of GLB object plus clients and allthings
var GLB = {};

// list of currently connected clients (users)
var clients = [];
// array of all tiles in all hubs
var allthings = {};

// server variables
var server;
var wsServer;
var app;
var applistening = false;
var serverlistening = false;

var CRYPTSALT ='HP$by%KW';
var BYPASSPW = false;

function file_exists(fname) {
    return fs.existsSync(fname);
}

function getUserName() {
    var uname;
    if ( typeof GLB.options!=="undefined" && GLB.options["config"] && array_key_exists("uname", GLB.options["config"]) ) {
        uname = GLB.options["config"]["uname"];
        if ( !uname ) { uname = "default"; }
    } else {
        uname = "default";
        if ( typeof GLB.options!=="undefined" && GLB.options["config"] ) {
            GLB.options["config"]["uname"] = uname;
        }
    }
    return uname;
}

// get the active user and skin
function getSkin() {
    var uname = getUserName();
    var skin;
    var pwords;
    if ( typeof GLB.options!=="undefined" && GLB.options["config"] && GLB.options["config"]["pword"] ) {
        pwords = GLB.options["config"]["pword"];
    }

    if ( !pwords || utils.count(pwords)===0 ) {
        skin = "skin-housepanel";
    } else if ( uname && array_key_exists(uname, pwords) ) {
        var pword = pwords[uname];
        if ( is_array(pword) ) {
            skin = pword[1];
        } else if ( GLB.options["config"]["skin"] ) {
            skin = GLB.options["config"]["skin"];
        } else {
            skin = "skin-housepanel";
        }
    } else {
        skin = "skin-housepanel";
    }
    return skin;
}

// read in customtiles ignoring the comments
// updated this to properly treat /*   */ comment blocks
function readCustomCss(skin) {
    var fname = skin + "/customtiles.css";
    var contents = fs.readFileSync(fname, 'utf8');
    return contents;
}

// call to write Custom Css Back to customtiles.css
function writeCustomCss(partnum, skin, str) {
    var results;
    // proceed only if there is a main css file in this skin folder
    if ( skin && file_exists(skin + "/housepanel.css") ) {
        var d = new Date();
        var today = d.toLocaleString();
        var fixstr = "";
        var opts = "a";

        // if this is the first part then rewrite the file
        // while preserving the header
        if ( partnum===1 ) {
            var ipos = str.indexOf("*---*/");
            opts = "w";

            // preserve the header info and update it with date
            if ( !str || ipos=== -1 ) {
                fixstr += "/* HousePanel Generated Tile Customization File */\n";
                if ( str ) {
                    fixstr += "/* Updated: " + today + " *---*/\n";
                } else {
                    fixstr += "/* Created: " + today + " *---*/\n";
                }
                fixstr += "/* ********************************************* */\n";
                fixstr += "/* ****** DO NOT EDIT THIS FILE DIRECTLY  ****** */\n";
                fixstr += "/* ****** EDITS MADE MAY BE REPLACED      ****** */\n";
                fixstr += "/* ****** WHENEVER TILE EDITOR IS USED    ****** */\n";
                fixstr += "/* ********************************************* */\n";
            } else {
                fixstr += "/* HousePanel Generated Tile Customization File */\n";
                fixstr += "/* Updated: " + today + " *---*/\n";
                ipos = ipos + 7;
                str = str.substring(ipos);
            }
        }

        // fix addition of backslashes before quotes on some servers
        if ( str && str.length ) {
            var str3 = str.replace("\\\"","\"");
            fixstr += str3;
        }

        // write to specific skin folder if the location is valid
        try {
            fs.writeFileSync(skin + "/customtiles.css", fixstr, {encoding: "utf8", flag: opts});
            console.log( (ddbg()), "custom CSS file saved in skin folder: ", skin, " of size: ", fixstr.length," part #", partnum);
            results = "success " + partnum;
        } catch (e) {
            var err = "error - attempting to save custom CSS file in skin folder: " + skin + " part #" + partnum;
            console.log( (ddbg()), err);
            results = err;
        }
    } else {
        results = "error - invalid skin: " + skin;
    }
    return results;
}

function readOptions() {

    var rewrite = false;
    var fname = "hmoptions.cfg";
    GLB.newuser = false;
    GLB.options = {};

    try {
        if ( !fs.existsSync(fname) ) {
            GLB.newuser = true;
            throw "hmoptions.cfg file not found.  New user assumed.  Welcome to HousePanel.";
        } else {
            GLB.options = JSON.parse(fs.readFileSync(fname, 'utf8'));
            if ( !GLB.options ) {
                GLB.options = {};
                throw "hmoptions.cfg file found but was not able to be processed.  Resetting.";
            }
        }

        if ( !array_key_exists("config", GLB.options) ) {
            throw "configuration settings were not found in " + fname + " configuration file.";
        }
    } catch(e) {
        console.log( (ddbg()), e); 
        setDefaults();
        rewrite = true;
    }

    // get the last user that logged in
    // and if not there use the default user
    var uname;
    if ( array_key_exists("uname", GLB.options["config"]) ) {
        uname = GLB.options["config"]["uname"];
        if ( !uname ) {
            uname = "default";
        }
    } else {
        uname = "default";
        GLB.options["config"]["uname"] = uname;
        rewrite = true;
    }

    // check for empty rooms, things, and index
    if ( !array_key_exists("rooms", GLB.options) ||
         !array_key_exists("things", GLB.options) ||
         !array_key_exists("index", GLB.options) ) {
        setDefaults();
        rewrite = true;
    }

    // handle time settings
    if ( array_key_exists("time", GLB.options) ) {
        var timeval = GLB.options["time"];
        var info = timeval.split(" @ ");
        var version = info[0];
        timeval = info[1];
    } else {
        var d = new Date();
        timeval = d.getTime();
        timeval = timeval.toString();
        version = utils.HPVERSION;
        GLB.options["time"] = version + " @ " + timeval;
        rewrite = true;
    }

    if ( !array_key_exists("useroptions", GLB.options) ) {
        GLB.options["useroptions"]= utils.getTypes();
        rewrite = true;
    }

    if ( !array_key_exists("pword", GLB.options.config) ) {
        GLB.options.config["pword"] = {};
        GLB.options.config["pword"][uname] =  ["","skin-housepanel"];
        rewrite = true;
    }

    if ( DEBUG1 ) {
        console.log( (ddbg()) + ' Config file for HP Version: ', version, " username: ", uname);
    }

    // read the hubs
    if ( array_key_exists("hubs", GLB.options["config"]) ) {
        if ( !is_array(GLB.options.config["hubs"]) ) { GLB.options.config["hubs"] = [] };
    } else {
        GLB.options.config["hubs"] = [];
        rewrite = true;
    }

    if (  GLB.options.config["hubs"].length > 0 ) {
        console.log((ddbg()) + ' Loading ',  GLB.options.config["hubs"].length,' hubs.');
        if ( DEBUG2 ) {
            console.log( GLB.options.config["hubs"] );
        }
    } else {
        console.log((ddbg()) + ' No hubs found. HousePanel will only show special and custom tiles.');
    }

    // update the options file if we added default info
    // we must do this before customizing the room to avoid messing up baseline
    // also include flag to skip the writing of the user section
    if ( rewrite ) {
        writeOptions(GLB.options, true);
    }
    
    // get custom settings for this user
    // or create the custom config for new users
    var customfname = "hm_" + uname + ".cfg";
    if ( !fs.existsSync(customfname) ) {
        // this format is now in real json format and includes user_ tiles
        // add a signature key to flag this format
        var customopt = {};
        customopt["::CUSTOM::"] = [uname, utils.HPVERSION, timeval];
        for (var key in GLB.options) {
            if ( key==="rooms" || key==="things" || key.substr(0,5)==="user_" ) {
                customopt[key] = GLB.options[key];
            }
        }
        var str_customopt = JSON.stringify(customopt, null, 1);
        fs.writeFileSync(customfname, str_customopt);
    } else {

        if ( DEBUG3 ) {
            console.log( (ddbg()), "Customizing room setup for user: ", uname);
        }

        // read this assuming new method only
        var str = fs.readFileSync(customfname, 'utf8');
        var str1 = str.replace("\r","");
        var str2 = str1.replace("\n","");
        var opts = JSON.parse(str2);

        var opt_rooms = null;
        var opt_things = null;
        if ( opts["rooms"] ) {
            opt_rooms = opts["rooms"];
        }
        if ( opts["things"] ) {
            opt_things = opts["things"];
        }
        for (var key in opts) {
            if ( key.substr(0,5)==="user_" ) {
                GLB.options[key] = opts[key];
            }
        }
            
        // protect against having a custom name and an empty custom user info
        if ( opt_rooms && opt_things && utils.count(opt_rooms) > 0 && utils.count(opt_things) > 0 ) {
            GLB.options["rooms"] = opt_rooms;
            GLB.options["things"] = {};
            for (var room in opt_rooms) {
                if ( array_key_exists(room, opt_things) ) {
                    GLB.options["things"][room] = opt_things[room];
                }
            }
        }
    }
}

function writeOptions(options, skipuser) {
    
    if ( !options ) {
        options = GLB.options;
    }

    var d = new Date();
    var timeval = d.getTime();
    timeval = timeval.toString();
    options["time"] = utils.HPVERSION + " @ " + timeval;
    GLB.options = clone(options);
    
    // write the main options file
    var stropt =  JSON.stringify(options, null, 1);
    fs.writeFileSync("hmoptions.cfg", stropt, {encoding: "utf8", flag:"w"});

    // write the user specific options file
    // unless skipuser given to skip this
    if ( typeof skipuser==="undefined" || !skipuser ) {
        var uname = getUserName();
        if ( uname ) {
            var userfname = "hm_" + uname + ".cfg";

            // this format is now in real json format and includes user_ tiles
            // add a signature key to flag this format
            var customopt = {};
            customopt["::CUSTOM::"] = [uname, utils.HPVERSION, timeval];
            for (var key in GLB.options) {
                if ( key==="rooms" || key==="things" || key.substr(0,5)==="user_" ) {
                    customopt[key] = GLB.options[key];
                }
            }
            var str_customopt = JSON.stringify(customopt, null, 1);
            fs.writeFileSync(userfname, str_customopt, {encoding: "utf8", flag:"w"});
        }
    }
}

function curl_call(host, headertype, nvpstr, formdata, calltype, callback) {
    var request = require('request');
    var opts = {url: host};
    if ( !calltype ) {
        calltype = "GET";
    }
    opts.method = calltype;
    
    if ( nvpstr && typeof nvpstr === "object" ) {
        opts.form = nvpstr;
    } else if ( nvpstr && typeof nvpstr === "string" ) {
        opts.url = host + "?" + nvpstr;
    }
    
    if (formdata) {
        opts.formData = formdata;
    }
    
    if ( headertype ) {
        opts.headers = headertype;
    }
    request(opts, callback);
}

function getHubInfo(hub, token, endpt, clientId, clientSecret) {

    // no need to check for valid token and endpt since we can't get here unless both are valid
    var namehost = endpt + "/gethubinfo";
    var header = {"Authorization": "Bearer " + token};
    var nvpreq = {"scope": "app", "client_id": encodeURI(clientId), "client_secret": encodeURI(clientSecret)};
    curl_call(namehost, header, nvpreq, false, "POST", nameidCallback);

    function nameidCallback(err, res, body) {
        var jsonbody;
        var hubName;
        var hubId;
        if ( err ) {
            console.log( (ddbg()), "error - attempting to make hub name request.");
            return;
        }

        try {
            jsonbody = JSON.parse(body);
            hubName = jsonbody["sitename"];
            hubId = jsonbody["hubId"];
            if ( DEBUG2 ) {
                console.log( (ddbg()), "hubName request return: ", jsonbody);
            }
        } catch(e) {
            console.log("error retrieving hub name.");
            GLB.defhub = "-1";
            pushClient("reload", "/reauth");
            return;
        }

        if ( DEBUG2 ) {
            console.log( (ddbg()), "hub info: token= ", token, " endpt= ", endpt, " hubName= ", hubName, " hubId= ", hubId);
        }

        // now save our info
        hub["hubName"]  = hubName;
        hub["hubId"] = hubId;
        var hubType = hub["hubType"];
        GLB.defhub = hubId;

        // update this hub
        updateHubs(hub, hubId);
        writeOptions(GLB.options, true);

        // retrieve all devices and go back to reauth page
        getDevices(hubId, hubType, token, endpt, clientId, clientSecret, hubName, "/reauth");
    }
    return "success";

}

function getAccessToken(code, hub) {

    // these are the parameters determined here using a series of curl calls and callbacks
    var token = "";

    var hubType = hub["hubType"];
    var hubName = hub["hubName"];
    var hubHost = hub["hubHost"];
    var clientId = hub["clientId"];
    var clientSecret = hub["clientSecret"];
    var hubnum = GLB.defhub;
    var redirect = GLB.returnURL + "/oauth";

    // make the call to get the token
    var tokenhost = hubHost + "/oauth/token";
    var header = {'Content-Type' : "application/x-www-form-urlencoded"};
    var nvpreq = {"grant_type": "authorization_code", "code": encodeURI(code), "client_id": encodeURI(clientId), 
                  "client_secret": encodeURI(clientSecret), "redirect_uri": encodeURI(redirect)};
    if ( DEBUG2 ) {
        console.log( (ddbg()), "calling with nvpreq: ", nvpreq);
    }
    
    curl_call(tokenhost, header, nvpreq, false, "POST", tokenCallback);

    // callback from the token request
    async function tokenCallback(err, res, body) {
        // save the access token
        var jsonbody = JSON.parse(body);
        if ( DEBUG2 ) {
            console.log( (ddbg()), "access token return: ", jsonbody);
        }

        if ( jsonbody["error"] ) {
            console.log( (ddbg()), "Token error authorizing hub: ", hubName, " error: ", err, " ", jsonbody["error"]);
            GLB.defhub = "-1";
            pushClient("reload", "/reauth");
        } else if ( typeof jsonbody==="object" && array_key_exists("access_token", jsonbody) ) {
            token = jsonbody["access_token"];
            if (token) {
                var ephost;
                if ( hubType==="SmartThings" ) {
                    ephost = hubHost + "/api/smartapps/endpoints";
                } else if ( hubType ==="Hubitat" ) {
                    ephost = hubHost + "/apps/api/endpoints";
                } else {
                    console.log("Invalid hub type: ", hubType, " in access token request call");
                    GLB.defhub = "-1";
                    pushClient("reload", "/reauth");
                }

                // console.log("Calling endpoint with token: ", token);
                header = {"Authorization": "Bearer " + token};
                curl_call(ephost, header, false, false, "GET", endptCallback);
            }
        } else {
            console.log( (ddbg()), "Unknown error authorizing hub: ", hubName, " error: ", err, " body: ", body);
            GLB.defhub = "-1";
            pushClient("reload", "/reauth");
        }
    }        
    
    async function endptCallback(err, res, body) {
        var jsonbody;
        var endpt;
        try {
            jsonbody = JSON.parse(body);
            if ( DEBUG2 ) {
                console.log( (ddbg()), "endpoint return: ", jsonbody);
            }
        } catch(e) {
            err = e;
        }

        if ( err ) {
            console.log( (ddbg()), "getEndpoint error authorizing " + hub.hubType + " hub. error: ", err);
            GLB.defhub = "-1";
            pushClient("reload", "/reauth");
        } else {
            var endptzero = jsonbody[0];
            endpt = endptzero.uri;
        }

        if ( token && endpt ) {
            getHubInfo(hub, token, endpt, clientId, clientSecret);

        } else {
            GLB.defhub = "-1";
            console.log( (ddbg()), "getEndpoint error authorizing " + hub.hubType + " hub. bad token: ", token, " or endpt: ", endpt);
            pushClient("reload", "/reauth");
        }
    }
}

function getDevices(hubnum, hubType, hubAccess, hubEndpt, clientId, clientSecret, hubName, reloadpath) {

    // retrieve all things from ST
    if ( hubType==="SmartThings" || hubType==="Hubitat" ) {
        var stheader = {"Authorization": "Bearer " + hubAccess};
        var params = {client_secret: clientId,
                      scope: "app",
                      client_id: clientSecret};
        curl_call(hubEndpt + "/getallthings", stheader, params, false, "POST", getAllDevices);
    } else if ( hubType==="ISY" ) {
        getIsyDevices(hubnum, hubType, hubAccess, hubEndpt, clientId, clientSecret, hubName, reloadpath);
        
    } else {
        console.log( (ddbg()), "error - attempt to read an unknown hub type= ", hubType);
        pushClient("reload", reloadpath);
        // return;
    }
    function getAllDevices(err, res, body) {
        if ( err ) {
            console.log( (ddbg()), "error retrieving devices: ", err);
        } else {
            try {
                var jsonbody = JSON.parse(body);
            } catch (e) {
                console.log( (ddbg()), "error translating devices: ", e);
                jsonbody = {};
                return;
            }
            if (DEBUG1) {
                console.log( (ddbg()) + " Retrieved ", jsonbody.length, " things from hub: ", hubName);
            }    

            // configure returned array with the "id"
            if (jsonbody && typeof jsonbody === "object") {
                jsonbody.forEach(function(content) {
                    var thetype = content["type"];
                    var id = content["id"];
                    var idx = thetype + "|" + id;

                    // this is the proper place to load customizations
                    // and we have to do it for ISY too
                    var pvalue = getCustomTile(content.value, thetype, id);

                    allthings[idx] = {
                        "id": id,
                        "name": content["name"], 
                        "hubnum": hubnum,
                        "type": thetype,
                        "hint": "", 
                        "refresh": "normal",
                        "value": pvalue
                    };
                });
            }
            updateOptions(reloadpath);
        }
    }
}

function mapIsy(isyid, uom) {
    const idmap = {"ST": "switch", "OL": "onlevel", "SETLVL": "level", "BATLVL": "battery", "CV": "voltage", "TPW": "power",
                   "CLISPH": "heatingSetpoint", "CLISPC": "coolingSetpoint", "CLIHUM": "humidity", "LUMIN": "illuminance", 
                   "CLIMD": "thermostatMode", "CLIHCS": "thermostatState", "CLIFS": "thermostatFanMode",
                   "CLIFRS": "thermostatOperatingState", "CLISMD": "thermostatHold"};
    var id = isyid;
    if ( array_key_exists(isyid, idmap) ) {
        id = idmap[isyid];
    }

    return id;
}

// version that supports ISY
function getIsyDevices(hubnum, hubType, hubAccess, hubEndpt, clientId, clientSecret, hubName, reloadpath) {
    var buff = Buffer.from(hubAccess);
    var base64 = buff.toString('base64');
    var stheader = {"Authorization": "Basic " + base64};
    
    // curl_call(hubEndpt + "/config", stheader, false, false, "GET", callbackIsyConfig);
    curl_call(hubEndpt + "/nodes", stheader, false, false, "GET", getAllNodes);
    
    async function getAllNodes(err, res, body) {
        var id;
        if ( err ) {
            console.log("Error retrieving ISY nodes: ", err);
        } else {
            var result = parser.parse(body);
            var thenodes = result.nodes["node"];
            if (DEBUG1) {
                console.log( (ddbg()) + " Retrieved ", thenodes.length, " things from hub: ", hubName);
            }

            // read the real attributes and map to HP fields
            for ( var obj in thenodes ) {
                var node = thenodes[obj];
                id = node["address"];
                // id = id.replace(/ /g, "_");
                var thetype = "isy";
                var idx = thetype + "|" + id;
                var hint = node["type"].toString();

                // set hint to nothing if default of zeros is provided
                // TODO - provide a more useful mapping of hints to type names
                // until then user can still style hints using CSS
                if ( hint==="0.0.0.0" ) {
                    hint = "";
                }

                var name = node["name"];
                var pvalue = {"name": name};

                // this is the proper place to load customizations
                pvalue = getCustomTile(pvalue, thetype, id);
                // console.log("post custom: ", pvalue);

                // set bare minimum info
                // this is updated below in the callback after getting node details
                allthings[idx] = {
                    "id": id,
                    "name": name, 
                    "hubnum": hubnum,
                    "type": thetype, 
                    "hint": hint,
                    "refresh": "never",
                    "value": pvalue
                };

                if (DEBUG5) {
                    console.log( (ddbg()), "idx= ", idx," hint= ", hint, " node: ", node);
                }
            }
        }

        // now that we have all the nodes identified, get the details
        curl_call(hubEndpt + "/status", stheader, false, false, "GET", callbackStatusInfo);

        async function callbackStatusInfo(err, res, body) {
            xml2js(body, async function(xmlerr, result) {
                try {
                    if ( result ) {
                        var nodes = result.nodes.node;
                        if ( nodes ) {
                            if ( DEBUG5 ) {
                                console.log( (ddbg()), "nodes returned from status");
                            }
                            nodes.forEach(function(node) {
                                var nodeid = node["$"]["id"];
                                var idx = "isy|" + nodeid;
                                var value = clone(allthings[idx]["value"]);
                                var props = node["property"];

                                // if there are props set values
                                if ( props ) {
                                    if ( DEBUG5 ) {
                                        console.log( (ddbg()), "ISY status callback. node: ", nodeid, " properties: ", props);
                                    }
                                    setIsyFields(nodeid, value, props);
                                }
                            });
                        } else {
                            throw "Something went wrong reading status from ISY";
                        }
                    }
                } catch(e) { 
                    console.log( (ddbg()), "error - ", e);
                }
            });
        }
        
        // update things and reload page after handling all tiles
        updateOptions(reloadpath);
    }

}

function translateIsy(nodeid, objid, uom, value, val, formatted) {

    // convert levels for Insteon range
    if ( uom && uom==="100" ) {
        val = Math.floor(parseInt(val) * 100 / 255);
    }
    val = val.toString();

    if ( typeof formatted === "undefined" ) {
        formatted = "";
    }

    // convert the trigger into a subid to modify
    var subid = mapIsy(objid, uom);

    // set the HP equivalent subid for this type of node field
    // if maps are not present then the native ISY subid will show up
    var newvalue = clone(value);

    // handle special cases
    switch (objid) {

        case "ST":
            if ( (uom==="51" || uom==="100") ) {
                // newvalue["level"]= val;  // formatted.substr(0, formatted.length-1);
                if ( val!=="0" && val!=="100") {
                    newvalue["level"] = val;
                }
                if ( val==="0" ) {
                    val = "DOF";
                } else if ( val==="100" ) {
                    val = "DON";
                } else {
                    newvalue["level"] = val;
                    val = "DON";
                }
                newvalue[subid] = val;

            } else if (uom==="78") {
                val = (formatted==="Off" || val==="0") ? "DOF" : "DON";
                newvalue[subid] = val;

            } else if ( uom==="17" ) {
                if ( typeof formatted==="undefined" || formatted==="" ) {
                    formatted = val + "°F";
                }
                newvalue["temperature"]= formatted;

            } else {
                val = (formatted==="Off" || val==="0" ? "DOF" : "DON");
                newvalue[subid] = val;
            }
            break;

        case "OL":
            if ( formatted && formatted==="On" ) {
                val = "100";
            } else if ( formatted && formatted==="Off" ) {
                val = "0";
            } else if ( formatted && formatted.substr(-1) === "%" ) {
                val = formatted.substr(0, formatted.length-1);
                if ( isNaN(parseInt(val)) ) {
                    val = "0";
                }
            } else {
                if ( isNaN(parseInt(val)) ) {
                    val = "0";
                }
            }
            newvalue[subid] = val;
            newvalue["level"] = val;
            break;

        case "CLIHUM":
        case "BATLVL":
            newvalue[subid] = val;
            break;

        case "CLISPC":
        case "CLISPH":
            if ( uom==="17" && formatted==="" ) {
                formatted = val + "°F";
            } else if ( formatted==="" ) {
                formatted = val;
            }
            newvalue[subid] = formatted;
            break;

        case "RR":
            var index = parseInt(val);
            if ( uom==="25" && !isNaN(index) && index<=31 ) {
                const RRindex = ["9.0 min", "8.0 min", "7.0 min", "6.0 min", "5.0 min", "4.5 min", "4.0 min", "3.5 min",
                                 "3.0 min", "2.5 min", "2.0 min", "1.5 min", "1.0 min", "47.0 sec", "43.0 sec", "38.5 sec",
                                 "34.0 sec", "32.0 sec", "30.0 sec", "28.0 sec", "26.0 sec", "23.5 sec", "21.5 sec", "19.0 sec",
                                 "8.5 sec", "6.5 sec", "4.5 sec", "2.0 sec", "0.5 sec", "0.3 sec", "0.2 sec", "0.1 sec"];
                val = RRindex[index];
            }
            newvalue[subid] = val;
            break;

        case "CLIFRS":
            var index = parseInt(val);
            const CLHindex = ["Off", "On", "On High", "On Medium", "Circulation", "Humidity Circ", "R/L Circ", "U/D Circ", "Quiet"];
            if ( uom==="80" && !isNaN(index) && index < CLHindex.length ) {
                val = CLHindex[index];
            }
            newvalue[subid] = val;
            break;

        case "CLIHCS":
            var index = parseInt(val);
            const CLFindex = ["Idle", "Heating", "Cooling", "Off"];
            if ( uom==="25" && !isNaN(index) && index < CLFindex.length ) {
                val = CLFindex[index];
            }
            newvalue[subid] = val;
            break;
        
        default:
            newvalue[subid] = formatted ? formatted : val;
            break;

    }
    return newvalue;
}

function setIsyFields(nodeid, value, props) {
    var idx = "isy|" + nodeid;
    if ( is_array(props) ) {
        props.forEach(function(aprop) {
            var obj = aprop['$'];
            // map ISY logic to the HousePanel logic based on SmartThings and Hubitat
            var subid = mapIsy(obj.id, obj.uom);
            value["uom_" + subid] = obj.uom;
            var val = obj.value;
            value = translateIsy(nodeid, obj.id, obj.uom, value, val, obj.formatted);
            allthings[idx]["value"] = clone(value);
            pushClient(nodeid, "isy", subid, value, false, false);
        });
    }
    // updateOptions(reloadpath);
}

// updates the global options array with new things found on hub
function updateOptions(reloadpath) {

    if ( ! GLB.options ) {
        return;
    }
    var update = false;
   
    // make all the user options visible by default
    if ( !array_key_exists("useroptions", GLB.options )) {
        GLB.options["useroptions"] = utils.getTypes();
    }

    // find the largest index number for a sensor in our index
    var cnt = utils.getMaxIndex(GLB.options["index"]) + 1;

    // update the index with latest sensor information
    for (var thingid in allthings) {
        // var thesensor = allthings[thingid];
        if ( !array_key_exists(thingid, GLB.options["index"]) ||
             parseInt(GLB.options["index"][thingid])===0 ) {
            GLB.options["index"][thingid] = cnt;
            update = true;
            cnt++;
        }
    }
    
    // save the options file
    if ( update && reloadpath!==false) {
        // make exactly the right number of special tiles
        var specialtiles = utils.getSpecials();
        // $oldindex = $options["index"];
        for (var stype in specialtiles) {
            var sid = specialtiles[stype];
            var customcnt = getCustomCount(stype, sid[3]);
            createSpecialIndex(customcnt, stype, sid[0]);
        }

        writeOptions(GLB.options);
    }

    // signal clients to reload
    if ( reloadpath !== false ) {
        pushClient("reload", reloadpath);
    }
}

function setDefaults() {
     
    // generic room setup
    const defaultrooms = {
        "Kitchen": "clock|kitchen|sink|pantry|dinette" ,
        "Family": "clock|family|mud|fireplace|casual|thermostat",
        "Living": "clock|living|dining|entry|front door|foyer",
        "Office": "clock|office|computer|desk|work",
        "Bedroom": "clock|bedroom|kid|kids|bathroom|closet|master|guest",
        "Outside": "clock|garage|yard|outside|porch|patio|driveway|weather",
        "Music": "clock|sonos|music|tv|television|alexa|echo|stereo|bose|samsung|pioneer"
    };

    if ( !GLB.options ) {
        GLB.options = {};
    }
    GLB.options.config = {};

    // set defaults here
    GLB.options.config["port"] = "3080";
    GLB.options.config["skin"] = "skin-housepanel";
    GLB.options.config["kiosk"] = "false";
    GLB.options.config["webSocketServerPort"] = "1380";
    GLB.options.config["timezone"] = "America/Detroit";
    GLB.options.config["hubs"] = [];

    GLB.options.config["specialtiles"] = {"video": 4, "frame": 4, "image": 4, "blank": 2, "custom": 8};

    GLB.options.config["fast_timer"] = "0";
    GLB.options.config["slow_timer"] = "300000";
    GLB.options.config["rules"] = "false";
    GLB.options.config["accucity"] = "ann-arbor-mi";
    GLB.options.config["accuregion"] = "us";
    GLB.options.config["accucode"] = "329380";
    GLB.options.config["hubpick"] = "all";

    var uname = "default";
    var skin = "skin-housepanel";
    GLB.options.config["uname"] = uname;
    GLB.pwcrypt = IGNOREPW ? true : false;

    GLB.options.config["pword"] = {};
    GLB.options.config["pword"][uname] = ["", skin];

    GLB.options["useroptions"] = utils.getTypes();
    
    // make a default options array based on the old logic
    // protocol for the options array is an array of room names
    // where each item is an array with the first element being the order number
    // second element is an optional alternate name defaulted to room name
    // each subsequent item is then a tuple of ST id and ST type
    // encoded as ST-id|ST-type to enable an easy quick text search
    GLB.options["rooms"] = {};
    GLB.options["things"] = {};

    // if we don't have allthings yet, load the special tiles
    if ( utils.count(allthings)===0 ) {
        addSpecials();
    }

    // put the special things in the index
    if ( !array_key_exists("index", GLB.options ) ) {
        GLB.options["index"] = {};
    }
    updateOptions(false);

    // var defbid = GLB.options.index["clock|clockdigital"];
    // var defthing = [defbid, 0, 0, 1, ""];

    var k = 0;
    // foreach(array_keys($defaultrooms) as $room) {
    for (var room in defaultrooms) {
        GLB.options["rooms"][room] = k;
        GLB.options["things"][room] = [];
        k++;
    }

    // organize things into rooms
    for (var thingid in allthings) {
        var thesensor = allthings[thingid];
        var thename= thesensor["name"].toLowerCase();
        var k = GLB.options["index"][thingid];
        if ( k ) {
            for (var room in defaultrooms) {
                var checkarr = defaultrooms[room].split("|");
                checkarr.forEach(function(keyword) {
                    var islocated = thename.indexOf(keyword);
                    if ( islocated !== -1 ) {
                        var tile = [k,0,0,1,""];
                        GLB.options["things"][room].push(tile);
                    }
                });
            }
        }
    }

}

function getLoginPage() {
    var $tc = "";
    var skin = getSkin();
    $tc += utils.getHeader(skin);
    $tc += "<h2>" + utils.APPNAME + "</h2>";
    $tc += "<br /><br />";
    $tc += "<form id=\"loginform\" name=\"login\" action=\"" + GLB.returnURL + "\"  method=\"POST\">";
    $tc += utils.hidden("returnURL", GLB.returnURL);
    $tc += utils.hidden("pagename", "login");
    $tc += utils.hidden("api", "dologin");
    $tc += utils.hidden("id", "none");
    $tc += utils.hidden("type", "none");
    $tc += "<div>";
    $tc += "<label for=\"uname\" class=\"startupinp\">Username: </label>";
    $tc += "<input id=\"uname\" name=\"uname\" width=\"20\" type=\"text\" value=\"\"/>"; 
    $tc += "<br /><br />";
    $tc += "<label for=\"pword\" class=\"startupinp\">Password: </label>";
    $tc += "<input id=\"pword\" name=\"pword\" width=\"40\" type=\"password\" value=\"\"/>"; 
    $tc += "<br /><br />";
    // $tc += "<input class=\"submitbutton\" value=\"Login\" name=\"submit\" type=\"submit\" />";
    $tc += '<div id="dologin" class="formbutton">Login</div>';
    $tc += "</div>";
    $tc += "</form>";
    $tc += utils.getFooter();
    return $tc;
}

function getAuthPage(hostname, hpcode) {
    const DONATE = false;
    var $tc = "";
    var skin = getSkin();
    $tc += utils.getHeader(skin);
    $tc += "<h2>" + utils.APPNAME + " Hub Authorization</h2>";

    // provide welcome page with instructions for what to do
    // this will show only if the user hasn't set up HP
    // or if a reauth is requested or when converting old passwords
    $tc += "<div class=\"greeting\">";

    $tc +="<p>Here is where you link a SmartThings, Hubitat, or ISY hub to " +
            "HousePanel to gain access to your smart home devices. " +
            "You can link any number and combination of hubs. " + 
            "To link a hub you must have the following info: " +
            "API URL, Client ID, and Client Secret. " +
            "For ISY hubs enter your username in the ClientID field and " +
            "password in the Client Secret field, and enter the URL of your ISY hub for API Url." +
            "</p><br />";
    
    $tc += "<p><strong>*** IMPORTANT ***</strong> Information you provide here is secret and will be stored " +
            "on your server in a configuration file called <i>hmoptions.cfg</i> " + 
            "This is why HousePanel should <strong>*** NOT ***</strong> be hosted on a public-facing website. " +
            "A locally hosted website on a Raspberry Pi is the strongly recommended option. " +
            "HousePanel does periodically store anonymized and encrypted use frequency data. " + 
            "By proceeding you are agreeing to this practice.</p>";
    $tc += "</div>";

    if ( DONATE===true ) {
        $tc += '<br /><h4>Donations appreciated for HousePanel support and continued improvement, but not required to proceed.</h4> \
            <br /><div><form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_blank"> \
            <input type="hidden" name="cmd" value="_s-xclick"> \
            <input type="hidden" name="hosted_button_id" value="XS7MHW7XPYJA4"> \
            <input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!"> \
            <img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1"> \
            </form></div>';
    }
    
    // get the current settings from options file
    // legacy file support removed
    // readOptions();
    var options = GLB.options;
    var rewrite = false;
    var config = options["config"];
    
    // removed old legacy file handling since it was prone to errors
    if ( array_key_exists("hubs", config) ) {
        var authhubs = clone(config["hubs"]);
    } else {
        authhubs = [];
        rewrite = true;
    }
    
    // get version and time info
    // force rewrite of options if a new version
    if ( array_key_exists("time", options) ) {
        var time = options["time"];
        var info = time.split(" @ ");
        var version = info[0].trim();
        var timestamp = parseInt(info[1].trim());
        var d = new Date(timestamp);
        var lastedit =  d.toLocaleDateString() + "  " + d.toLocaleTimeString();
        if ( version !== utils.HPVERSION ) {
            rewrite = true;
        }
    } else {
        rewrite = true;
        lastedit = "Unknown";
        version = "Pre Version 1.7";
    }

    // last one given is saved here also in main area as the new default
    // if ( rewrite ) {
    //     config["hubs"] = authhubs;
    //     options["config"] = config;
    //     writeOptions(options);
    // }
        
    // add a new blank hub at the end for adding new ones
    // note: the type must be "New" because js uses this to do stuff
    var newhub = {"hubType": "New", "hubHost": "https://graph.api.smartthings.com", 
                  "clientId": "", "clientSecret": "",
                  "userAccess": "", "userEndpt": "", "hubName": "", "hubId": "new",
                  "hubTimer": 0, "hubAccess": "", "hubEndpt": ""};
    authhubs.push(newhub);

    var webSocketUrl = "";
    if ( config.webSocketServerPort && !isNaN(parseInt(config.webSocketServerPort)) ) {
        var icolon = hostname.indexOf(":");
        if ( icolon >= 0 ) {
            webSocketUrl = "ws://" + hostname.substr(0, icolon);
        } else {
            webSocketUrl = "ws://" + hostname;
        }
        webSocketUrl = webSocketUrl + ":" + config.webSocketServerPort;
    }
    
    $tc += utils.hidden("returnURL", GLB.returnURL);
    $tc += utils.hidden("pagename", "auth");
    $tc += utils.hidden("webSocketUrl", webSocketUrl);
    $tc += "<div class=\"greetingopts\">";
    $tc += "<h3><span class=\"startupinp\">Last update: " + lastedit + "</span></h3>";
    
    // ------------------ general settings ----------------------------------
    var numnewthings = 0;
    if ( DEBUG2 ) {
        console.log( (ddbg()), "Hub auth default hub: ", GLB.defhub);
    }
    if ( GLB.defhub && GLB.defhub!=="-1" ) {
        var defhub = GLB.defhub;
        for ( var idx in allthings) {
            var thing = allthings[idx];
            if ( thing["hubnum"] === defhub ) {
                numnewthings++;
            }
        }
        var ntc= "Hub with hubId= " + defhub + " was authorized and " + numnewthings + " devices were retrieved.";
    } else {
        defhub = authhubs[0]["hubId"];
        ntc = "";
    }

    $tc += "<div id=\"newthingcount\">" + ntc + "</div>";
    $tc += "<div class='hubopt'><label for=\"pickhub\" class=\"startupinp\">Authorize Hub: </label>";
    $tc += "<select name=\"pickhub\" id=\"pickhub\" class=\"startupinp pickhub\">";

    var i= 0;
    authhubs.forEach(function(hub) {
        var hubName = hub["hubName"];
        var hubType = hub["hubType"];
        var hubId = hub["hubId"].toString();
        if ( hubId === defhub) {
            var hubselected = "selected";
        } else {
            hubselected = "";
        }
        $tc += "<option value=\"" + hubId + "\" " + hubselected + ">Hub #" + i + " " + hubName + " (" + hubType + ")</option>";
        i++;
    });
    $tc += "</select></div>";

    $tc +="<div id=\"authhubwrapper\">";
    i = 0;
    authhubs.forEach(function(hub) {
        
        // putStats(hub);
        var hubType = hub["hubType"];
        var hubId = hub["hubId"].toString();
        if ( hubId === defhub) {
            var hubclass = "authhub";
        } else {
            hubclass = "authhub hidden";
        }

        // for each hub make a section with its own form that comes back here as a post
        $tc +="<div id=\"authhub_" + hubId + "\" hubid=\"" + hubId + "\" hubtype=\"" + hubType + "\" class=\"" + hubclass + "\">";
        $tc += "<form id=\"hubform_" + hubId + "\" class=\"houseauth\" action=\"" + GLB.returnURL + "\"  method=\"POST\">";
        $tc += utils.hidden("doauthorize", hpcode);

        // we use this div below to grab the hub type dynamically chosen
        $tc += "<div id=\"hubdiv_" + hubId + "\"><label class=\"startupinp\">Hub Type: </label>";
        $tc += "<select name=\"hubType\" class=\"startupinp\">";
        var st_select = "";
        var he_select = "";
        var isy_select = "";
        if ( hubType==="SmartThings" ) { st_select = "selected"; }
        if ( hubType==="Hubitat" ) { he_select = "selected"; }
        if ( hubType==="ISY" ) { isy_select = "selected"; }
        $tc += "<option value=\"SmartThings\" " + st_select + ">SmartThings</option>";
        $tc += "<option value=\"Hubitat\" " + he_select + ">Hubitat</option>";
        $tc += "<option value=\"ISY\" " + isy_select + ">ISY</option>";
        $tc += "</select></div>";
        
        if ( !hub["hubHost"] ) {
            hub["hubHost"] = "https://graph.api.smartthings.com";
        }
        $tc += "<div><label class=\"startupinp required\">API Url: </label>";
        $tc += "<input class=\"startupinp\" title=\"Enter the hub OAUTH address here\" name=\"hubHost\" width=\"80\" type=\"text\" value=\"" + hub["hubHost"] + "\"/></div>"; 

        $tc += "<div><label class=\"startupinp required\">Client ID: </label>";
        $tc += "<input class=\"startupinp\" name=\"clientId\" width=\"80\" type=\"text\" value=\"" + hub["clientId"] + "\"/></div>"; 

        $tc += "<div><label class=\"startupinp required\">Client Secret: </label>";
        $tc += "<input class=\"startupinp\" name=\"clientSecret\" width=\"80\" type=\"text\" value=\"" + hub["clientSecret"] + "\"/></div>"; 

        $tc += "<div><label class=\"startupinp\">Fixed Access Token: </label>";
        $tc += "<input class=\"startupinp\" name=\"userAccess\" width=\"80\" type=\"text\" value=\"" + hub["userAccess"] + "\"/></div>"; 

        $tc += "<div><label class=\"startupinp\">Fixed Endpoint: </label>";
        $tc += "<input class=\"startupinp\" name=\"userEndpt\" width=\"80\" type=\"text\" value=\"" + hub["userEndpt"] + "\"/></div>"; 

        $tc += "<div><label class=\"startupinp\">Hub Name: </label>";
        $tc += "<input class=\"startupinp\" name=\"hubName\" width=\"80\" type=\"text\" value=\"" + hub["hubName"] + "\"/></div>"; 

        $tc += utils.hidden("hubId", hubId);

        $tc += "<div><label class=\"startupinp required\">Refresh Timer: </label>";
        $tc += "<input class=\"startupinp\" name=\"hubTimer\" width=\"10\" type=\"text\" value=\"" + hub["hubTimer"] + "\"/></div>"; 

        $tc += "<input class=\"hidden\" name=\"hubAccess\" type=\"hidden\" value=\"" + hub["hubAccess"] + "\"/>"; 
        $tc += "<input class=\"hidden\" name=\"hubEndpt\" type=\"hidden\" value=\"" + hub["hubEndpt"] + "\"/>"; 
        
        $tc += "<div>";
        $tc += "<input hub=\"" + i + "\" hubid=\"" + hubId + "\" class=\"authbutton hubauth\" value=\"Authorize Hub #" + i + "\" type=\"button\" />";
        // $tc += "<input hub=\"" + i + "\" hubid=\"" + hubId + "\" class=\"authbutton hubdel\" value=\"Remove Hub #" + i + "\" type=\"button\" />";
        $tc += "</div>";
        
        $tc += "</form>";
        $tc += "</div>";
        
        i++;
    });
    $tc += "</div>";
    $tc += "<div id=\"authmessage\"></div>";
    $tc += "<br><br>";
    $tc += "<input id=\"cancelauth\" class=\"authbutton\" value=\"Return to Options Page\" name=\"cancelauth\" type=\"button\" />";
    $tc += "<button class=\"infobutton\">Return to HousePanel</button>";

    $tc += utils.getFooter();
    return $tc;
}

function createSpecialIndex(customcnt, stype, spid) {
    var oldindex = clone(GLB.options["index"]);
    var maxindex = utils.getMaxIndex(GLB.options["index"]);

    if ( !array_key_exists("specialtiles", GLB.options["config"]) ) {
        GLB.options["config"]["specialtiles"] = {};
    }
    GLB.options["config"]["specialtiles"][stype] = customcnt;

    // remove special types of this type
    var n = stype.length + 1;
    for (var idx in oldindex) {
        if ( idx.substr(0,n) === stype + "|" ) {
            delete GLB.options["index"][idx];
        }
    }

    // add back in the right number
    var theindex;
    for ( var i=0; i<customcnt; i++) {
        var k = (i + 1).toString();
        var fid = spid + k;
        var sidnum = stype + "|" + fid;
        if ( array_key_exists(sidnum, oldindex) ) {
            theindex = parseInt(oldindex[sidnum]);
            if ( theindex > maxindex ) {
                maxindex= theindex;
            }
        } else {
            maxindex++;
            theindex = maxindex;
        }
        GLB.options["index"][sidnum] = theindex;
    }
}

// routine that renumbers all the things in your options file from 1
function refactorOptions() {

    // load in custom css strings
    var updatecss = false;
    var cnt = 0;
    var options = GLB.options;
    var oldoptions = clone(GLB.options);
    options["things"] = {};
    options["index"] = {};
    var skin = getSkin();
    var customcss = readCustomCss(skin);

    var cflags = [ ["\.p\_","\."], ["\.p\_"," "], ["\.v\_","\."], ["\.v\_"," "], ["\.t\_","\."], ["\.t\_"," "], ["\.n\_","\."], ["\.n\_"," "] ];

    for (var thingid in oldoptions["index"]) {
        var idxarr = oldoptions["index"][thingid];
        
        // only keep items that are in our current set of hubs
        if ( array_key_exists(thingid, allthings) ) {
        
            // removed the old system check since this is a new day for HP
            cnt++;
            var idx = parseInt(idxarr);

            // replace all instances of the old "idx" with the new "cnt" in customtiles
            if ( customcss && idx!==cnt ) {

                cflags.forEach(function(arr) {
                    var re = new RegExp(arr[0] + idx.toString() + arr[1], "g");
                    var newval = arr[0] + cnt.toString() + arr[1];
                    customcss = customcss.replace(re, newval);
                });

                updatecss = true;
            }

            // save the index number - fixed prior bug that only did this sometimes
            options["index"][thingid] = cnt;
        }
    }

    // now replace all the room configurations
    // this is done separately now which is much faster and less prone to error
    // foreach ($oldoptions["things"] as $room => $thinglist) {
    for (var room in oldoptions["things"]) {
        options["things"][room] = [];
        var thinglist = oldoptions["things"][room];
        for ( var thingroom in thinglist ) {
            var pidpos = thinglist[thingroom];
            var pid;
            var postop = 0;
            var posleft = 0;
            var zindex = 1;
            var customname = "";
            if ( is_array(pidpos) ) {
                var pid = parseInt(pidpos[0]);
                var postop = parseInt(pidpos[1]);
                var posleft = parseInt(pidpos[2]);
                if ( pidpos.length>3 ) {
                    zindex = parseInt(pidpos[3]);
                    customname = pidpos[4];
                }
            } else {
                pid = parseInt(pidpos);
            }

            var thingid = array_search(pid, oldoptions["index"]);
            
            if ( thingid!==false && array_key_exists(thingid, options["index"]) ) {
                var newid = options["index"][thingid];
                // use the commented code below if you want to preserve any user movement
                // otherwise a refactor call resets all tiles to their baseeline position  
                // options["things"][room].push([newid,postop,posleft,zindex,customname]);
                options["things"][room].push([newid,0,0,1,customname]);
            }
        };
    }
    
    // now adjust all custom configurations
    for (var key in oldoptions) {
        
        var lines = oldoptions[key];
        var newlines;
        var calltype;
    
        if ( ( key.substr(0,5)==="user_" || key.substr(0,7)==="custom_" ) && is_array(lines) ) {

            // allow user to skip wrapping single entry in an array
            if ( !is_array(lines[0]) ) {
                lines = [lines];
            }

            newlines = [];
            for (var k in lines) {
                var msgs = lines[k];
                calltype = msgs[0].toUpperCase().trim();

                // switch to new index for links
                // otherwise we just copy the info over to options
                if ( calltype==="LINK" ) {
                    var linkid = msgs[1].toString().trim();
                    var thingid = array_search(linkid, oldoptions["index"]);
                    if ( thingid!==false && array_key_exists(thingid, options["index"]) ) {
                        msgs[1] = options["index"][thingid].toString();
                    }
                }
                newlines.push(msgs);
            }
            if ( newlines.length ) {
                options[key] = newlines;
            }
        }
    }
    
    // TODO... not yet working so don't save

    // save our updated options and our custom style sheet file
    // writeOptions(options);

    // if ( updatecss ) {
    //     writeCustomCss(1, skin, customcss);
    // }
}

// emulates the PHP function for javascript objects or arrays
function array_search(needle, arr) {
    var key = false;
    needle = needle.toString();
    if ( is_object(arr) ) {
        try {
            for (var t in arr) {
                if ( arr[t]===needle || arr[t].toString() === needle ) {
                    return t;
                }
            } 
        }
        catch(e) { key = false; }
    }
    return key;
}

function in_array(needle, arr) {
    needle = needle.toString();
    if ( !is_object(arr) ) {
        return false;
    } else {
        for (var i in arr) {
            var item = arr[i];
            if ( item===needle || item.toString()===needle ) {
                return true;
            }
        }
        return false;
    }
}

function is_array(obj) {
    if ( typeof obj === "object" ) {
        return Array.isArray(obj);
    } else {
        return false;
    }
}

function is_object(obj) {
    return ( typeof obj === "object" );
}

function array_key_exists(key, arr) {
    if ( !is_object(arr) ) {
        return false;
    }
    return ( typeof arr[key] !== "undefined" );
}

function ddbg() {
    var d = new Date();
    var dstr = d.toLocaleDateString() + "  " + d.toLocaleTimeString() + " ";
    return dstr;
}

// returns true if the index is in the room things list passed
function inroom($idx, $things) {
    var $found = false;
    var $idxint = parseInt($idx);
    for (var i in $things) {
        var $arr = $things[i];
        var $thingindex = is_array($arr) ? $arr[0] : parseInt($arr);
        if ( $idxint === $thingindex ) {
            $found = i;
            break;
        }
    }
    return $found;
}

// this is the main page rendering function
// each HousePanel tab is generated by this function call
// each page is contained within its own form and tab division
// notice the call of $cnt by reference to keep running count
function getNewPage(cnt, roomtitle, kroom, things) {
    var $tc = "";
    var roomname = roomtitle;
    $tc += "<div id=\"" + roomname + "-tab\">";
    $tc += "<form title=\"" + roomtitle + "\" action=\"#\">";
    
    // add room index to the id so can be style by number and names can duplicate
    // no longer use room number for id since it can change around
    // switched this to name - not used anyway other than manual custom user styling
    // if one really wants to style by room number use the class which includes it
    $tc += "<div id=\"panel-" + roomname + "\" title=\"" + roomtitle + "\" class=\"panel panel-" + kroom + " panel-" + roomname + "\">";

    // the things list can be integers or arrays depending on drag/drop
    var idxkeys = Object.keys(GLB.options["index"]);
    var idxvals = Object.values(GLB.options["index"]);
    things.forEach(function(kindexarr) {
        
        // get the offsets and the tile id
        var kindex = parseInt(kindexarr[0]);
        var postop = kindexarr[1];
        var posleft = kindexarr[2];
        var zindex = 1;
        var customname = "";

        if ( kindexarr.length > 3 ) {
            zindex = kindexarr[3];
            customname = kindexarr[4];
        }
        
        // get the index into the main things list
        
        // thingid = array_search(kindex, GLB.options["index"]);
        var i = idxvals.findIndex(idx => idx === kindex);
        var thingid = idxkeys[i];
        
        // if our thing is still in the master list, show it
        if (thingid && allthings[thingid]) {
            var thesensor = allthings[thingid];

            // keep running count of things to use in javascript logic
            cnt++;
            $tc += makeThing(cnt, kindex, thesensor, roomtitle, postop, posleft, zindex, customname, false);
        }
    });

    // end the form and this panel
    $tc += "</div></form>";

    // end this tab which is a different type of panel
    $tc +="</div>";
    return {tc: $tc, cnt: cnt};
}

// function to search for triggers in the name to include as classes to style
function processName(thingname, thingtype) {

    // get rid of 's and split along white space
    // but only for tiles that are not weather
    var subtype = "";
    if ( thingtype!=="weather") {
        var ignores = ["'s","*","<",">","!","{","}","-",".",",",":","+","&","%"];
        var ignore2 = ["routine","switch", "light", "switchlevel", "bulb", "momentary","contact",
                    "motion", "lock", "thermostat", "temperature", "music", "valve",
                    "illuminance", "smoke", "water",
                    "weather", "presence", "mode", "shm", "hsm", "piston", "other",
                    "clock", "blank", "image", "frame", "video", "custom", "control", "power"];
        var lowname = thingname.toLowerCase();
        var pattern = /[,;:!-\'\*\<\>\{\}\+\&\%]/g;
        var s1 = lowname.replace(pattern,"");
        var subopts = s1.split(" ");
        var k = 0;
        subopts.forEach(function(str) {
            str= str.trim();
            var numcheck = +str;
            if ( str.length>1 && ignore2.indexOf(str)===-1 && str!==thingtype && isNaN(numcheck) ) {
                if ( k < 3 ) {
                    subtype += " " + str;
                    k++;
                }
            }
        });
    }
    
    return [thingname, subtype];
}

// returns proper html to display an image, video, frame, or custom
// if some other type is requested it returns a div of requested size and skips search
// searches in main folder and media subfolder for file name
function returnFile(thingvalue, thingtype) {

    // do nothing if this isn't a special tile
    var specialtiles = utils.getSpecials();
    if ( !array_key_exists(thingtype, specialtiles) ) {
        return thingvalue;
    }

    // get the name, width, height to create
    if ( array_key_exists("name", thingvalue) ) {
        var fn = thingvalue["name"];
    } else {
        fn = specialtiles[thingtype][0];
        thingvalue["name"] = fn;
    }
    if ( array_key_exists("width", thingvalue) ) {
        var fw = thingvalue["width"];
    } else {
        fw = specialtiles[thingtype][1];
        thingvalue["width"] = fw;
    }
    if ( array_key_exists("height", thingvalue) ) {
        var fh = thingvalue["height"];
    } else {
        fh = specialtiles[thingtype][2];
        thingvalue["height"] = fh;
    }

    var grtypes;
    switch (thingtype) {
        case "image":
            grtypes = [".jpg",".png",".gif"];
            break;
        case "video":
            grtypes = [".mp4",".ogg"];
            break;
        case "frame":
            grtypes = [".html",".htm",".php"];
            break;
        case "custom":
            grtypes = [".jpg",".png",".gif",".mp4",".ogg",".html",".htm",".php"];
            break;
        // for blanks never load a file
        // but we do set the name above
        // below we set the tile size for blanks and others
        default:
            grtypes = null;
            break;
    }

    // this block sets the file name to load based on extension requested
    var $vn = "";
    var $fext = "";
    if ( grtypes ) {

        // first check names without extensions
        if (file_exists(fn)) {
            $vn = fn;
            $fext = "";
        } else if (file_exists("media/"+ fn)) {
            $vn = "media/" + fn;
            $fext = "";
        } else {

            // next check names without extensions
            grtypes.forEach(function($ext) {
                if ( $vn==="" && file_exists(fn + $ext) ) {
                    $vn = fn + $ext;
                    $fext = $ext;
                } else if ( $vn==="" && file_exists("media/" + fn + $ext) ) {
                    $vn = "media/" + fn + $ext;
                    $fext = $ext;
                }
            });
        }
    }
    
    var $v = "";

    // process things if file was found
    if ( $vn ) {

        // if file has an extension then remove the dot
        if ( $fext.length && $fext.substr(0,1)==="." ) {
            $fext = $fext.substr(1);
        }

        switch ($fext) {
            // image files
            case "jpg":
            case "png":
            case "gif":
                $v= "<img width=\"" + fw + "\" height=\"" + fh + "\" src=\"" + $vn + "\">";
                break;

            // video files
            case "mp4":
            case "ogg":
                $v= "<video width=\"" + fw + "\" height=\"" + fh + "\" autoplay>";
                $v+= "<source src=\"" + $vn + "\" type=\"video/" + $fext + "\">";
                $v+= "Video Not Supported</video>";
                break;
                
            // render web pages in a web iframe
            case "html":
            case "htm":
            case "php":
                $v = "<iframe width=\"" + fw + "\" height=\"" + fh + "\" src=\"" + $vn + "\" frameborder=\"0\"></iframe>";
                break;

            // otherwise just show the contents of the file
            default:
                try {
                    var contents = fs.readFileSync($vn);
                } catch(e) {
                    contents = "";
                }
                $v = "<div style=\"width: " + fw + "px; height: " + fh + "px;\">" + contents + "</div>";
                break;
        }
    
    // if file wasn't found just make an empty block of the requested size
    // but for custom tiles don't do this since we can use blanks to make empty block sizes
    // for custom tiles only create a block of size if there is content to be seen
    } else {
        if ( thingtype==="custom" ) {
            $v = "";
        } else {
            $v = "<div style=\"width: " + fw + "px; height: " + fh + "px;\"></div>";
        }
    }

    thingvalue[thingtype] = $v;
    return thingvalue;
}

// function to create frame2.html with AccuWeather for a city
// the City Name, Country Code, and the Location Code from AccuWeather must be provided
// getAccuWeather("ann-arbor-mi","us","329380");
function getAccuWeather($city, $region, $code) {
    const acid = "awcc1531959686475";
    const $unit = "F";

    var rcitycode = $region + "/" + $city + "/" + $code + "/weather-forecast/" + $code;
    var $tc = "<!DOCTYPE html>";
    $tc += "<html><body>";
    $tc += "<a href=\"https://www.accuweather.com/en/" + rcitycode + "\" class=\"aw-widget-legal\">";
    $tc += "</a><div id=\"" + acid + "\" class=\"aw-widget-current\"  data-locationkey=\"" + $code + "\" data-unit=\"" + $unit + "\" data-language=\"en-us\" data-useip=\"false\" data-uid=\"" + acid + "\"></div>";
    $tc += "<script type=\"text/javascript\" src=\"https://oap.accuweather.com/launch.js\"></script>";
    $tc += "</body></html>";
    fs.writeFileSync("frame2.html", $tc, {encoding: "utf8", flag:"w"});
}

function getWeatherIcon(num) {
    if ( isNaN(+num) ) {
        var iconstr = num;
    } else {
        num = num.toString();
        if ( num.length < 2 ) {
            num = "0" + num;
        }

        // uncomment this to use ST's copy. Default is to use local copy
        // so everything stays local
        var iconimg = "media/weather/" + num + ".png";
        iconstr = "<img src=\"" + iconimg + "\" alt=\"" + num + "\" width=\"80\" height=\"80\">";
    }
    return iconstr;
}

function makeThing(cnt, kindex, thesensor, panelname, postop, posleft, zindex, customname, wysiwyg) {
    var $tc = "";
    
    var bid = thesensor["id"];
    var thingvalue = setValOrder(thesensor["value"]);
    var thingtype = thesensor["type"];
    var defname = thesensor["name"] || "Unknown";

    // set type to hint if one is given
    // this is to support ISY nodes that all register as ISY types
    // so we can figure out what type of tile this is closest to
    var hint = thesensor["hint"];
    
    var hubnum = "-1";
    if ( array_key_exists("hubnum", thesensor) ) {
        hubnum = thesensor["hubnum"];
    }
    if ( array_key_exists("refresh", thesensor) ) {
        var refresh = thesensor["refresh"];
    } else {
        refresh = "normal";
    }

    var pnames = processName(thesensor["name"], thingtype);
    var thingname = pnames[0];
    var subtype = pnames[1];
    postop= parseInt(postop);
    posleft = parseInt(posleft);
    zindex = parseInt(zindex);;
    var idtag = "t-" + cnt;
    if ( wysiwyg ) {
        idtag = wysiwyg;
    }

    // set the custom name
    if ( customname ) { 
        thingvalue["name"] = customname;
    } else if (!thingvalue["name"]) {
        thingvalue["name"] = defname;
    }

    // update fields with custom settings
    // thingvalue = getCustomTile(thingvalue, thingtype, bid);

    // set the custom name
    // limit to 132 visual columns but show all for special tiles and custom names
    // now we use custom name in both places
    thingname = thingvalue["name"];
    var thingpr = thingname;
    if ( !customname && thingname && thingname.length > 132 && !array_key_exists(thingtype, utils.getSpecials()) ) {
        thingpr = thingname.substring(0,132) + " ...";
    }
            
    // check if there is a color key - use to set color
    // no longer print this first since we need to include in custom logic
    var bgcolor= "";
    if ( array_key_exists("color", thingvalue) ) {
        var cval = thingvalue["color"];
        if ( cval.match(/^#[abcdefABCDEF\d]{6}/) !== null ) {
            bgcolor = " style=\"background-color:"+cval+";\"";
        // } else {
        //     cval = " white";
        //     bgcolor = " style=\"background-color:"+cval+";\"";
        }
    }
    
    // wrap thing in generic thing class and specific type for css handling
    // IMPORTANT - changed tile to the saved index in the master list
    //             so one must now use the id to get the value of "i" to find elements
    $tc=   "<div id=\""+idtag+"\" hub=\""+hubnum+"\" tile=\""+kindex+"\" bid=\""+bid+"\" type=\""+thingtype+"\" ";
    $tc += "panel=\""+panelname+"\" class=\"thing "+thingtype+"-thing" + subtype + " p_"+kindex; 
    if ( hint ) {
        $tc += " " + hint;
    }
    $tc += "\" ";
    $tc += "refresh=\""+refresh+"\"";
    if ( (postop!==0 && posleft!==0) || zindex>1 ) {
        $tc += " style=\"position: relative; left: "+posleft+"px; top: "+postop+"px; z-index: "+zindex+";\"";
    }
    $tc += ">";

    // special handling for weather tiles
    // this allows for feels like and temperature to be side by side
    // and it also handles the inclusion of the icons for status
    if (thingtype==="weather") {
        var weathername;
        if ( customname ) {
            weathername = customname;
        } else {
            if ( typeof thingpr==="undefined" ) { thingpr = "Weather"; }
            weathername = thingpr + "<br>" + thingvalue["city"];
        }
        $tc += "<div aid=\""+ cnt +"\" class=\"thingname " + thingtype + " t_" + kindex + "\" id=\"s-" + cnt + "\">";
        $tc += weathername;
        $tc += "</div>";
        $tc += putElement(kindex, cnt, 0, thingtype, thingvalue["name"], "name");
        $tc += putElement(kindex, cnt, 1, thingtype, thingvalue["city"], "city");
        $tc += "<div class=\"weather_temps\">";
        $tc += putElement(kindex, cnt, 2, thingtype, thingvalue["temperature"], "temperature");
        $tc += putElement(kindex, cnt, 3, thingtype, thingvalue["feelsLike"], "feelsLike");
        $tc += "</div>";
        
        // use new weather icon mapping
        $tc += "<div class=\"weather_icons\">";
        var wiconstr = getWeatherIcon(thingvalue["weatherIcon"]);
        var ficonstr = getWeatherIcon(thingvalue["forecastIcon"]);
        $tc += putElement(kindex, cnt, 4, thingtype, wiconstr, "weatherIcon");
        $tc += putElement(kindex, cnt, 5, thingtype, ficonstr, "forecastIcon");
        $tc += "</div>";
        $tc += putElement(kindex, cnt, 6, thingtype, "Sunrise: " + thingvalue["localSunrise"] + " Sunset: " + thingvalue["localSunset"], "sunriseset");
        
        var j = 7;
        for ( var tkey in thingvalue ) {
            if (tkey!=="temperature" &&
                tkey!=="feelsLike" &&
                tkey!=="city" &&
                tkey!=="weather" &&
                tkey!=="weatherIcon" &&
                tkey!=="forecastIcon" &&
                tkey!=="alertKeys" && 
                typeof tkey==="string" && tkey.substring(0,5)!=="user_" ) 
            {
                var helperkey = "user_" + tkey;
                var tval = thingvalue[tkey];
                // $tc += putElement(kindex, cnt, j, thingtype, tval, tkey);
                if (  array_key_exists(helperkey, thingvalue) && thingvalue[helperkey] && thingvalue[helperkey].substr(0,2)==="::" ) {
                    var helperval = thingvalue[helperkey];
                    $tc += putLinkElement(bid, helperval, kindex, cnt, j, thingtype, tval, tkey, subtype, bgcolor);
                } else {
                    $tc += putElement(kindex, cnt, j, thingtype, tval, tkey, subtype, bgcolor);
                }
                j++;
            }
        };
        
    } else {

        // handle special tiles
        thingvalue = returnFile(thingvalue, thingtype);

// unfortunately, this no longer works because Google changed how they return image searches
// 
//        if ( $thingtype==="music" ) {
//            $thingvalue = getMusicArt($thingvalue);
//        }
        
        $tc += "<div aid=\""+cnt+"\" type=\""+thingtype+"\" title=\""+thingpr+"\" class=\"thingname "+thingtype+" t_"+kindex+"\" id=\"s-"+cnt+"\">";
        $tc += thingpr;
        $tc += "</div>";
	
        // create a thing in a HTML page using special tags so javascript can manipulate it
        // multiple classes provided. One is the type of thing. "on" and "off" provided for state
        // for multiple attribute things we provide a separate item for each one
        // the first class tag is the type and a second class tag is for the state - either on/off or open/closed
        // ID is used to send over the groovy thing id number passed in as $bid
        // for multiple row ID's the prefix is a$j-$bid where $j is the jth row
        if (typeof thingvalue === "object") {
            var j = 0;
            
            // create on screen element for each key
            // this includes a check for helper items created in tile customizer
            for ( var tkey in thingvalue ) {
                var helperkey = "user_" + tkey;
                var tval = thingvalue[tkey];
                
                // handle the new Sonos audio type which has a media type with details
                // but even this is skipped if a user field was given to override it
                if ( thingtype==="audio" && tkey==="audioTrackData" && !array_key_exists(helperkey, thingvalue) ) {
                    var audiodata = JSON.parse(tval);
                    $tc += putElement(kindex, cnt, j,   thingtype, audiodata["title"], "trackDescription", "trackDescription", bgcolor);
                    $tc += putElement(kindex, cnt, j+1, thingtype, audiodata["artist"], "currentArtist", "currentArtist", bgcolor);
                    $tc += putElement(kindex, cnt, j+2, thingtype, audiodata["album"], "currentAlbum", "currentAlbum", bgcolor);
                    $tc += putElement(kindex, cnt, j+3, thingtype, audiodata["albumArtUrl"], "trackImage", "trackImage", bgcolor);
                    $tc += putElement(kindex, cnt, j+4, thingtype, audiodata["mediaSource"], "mediaSource", "mediaSource", bgcolor);
                    j = j+5;	
                }
                
                else if ( typeof tkey==="string" && tkey.substring(0,5)!=="user_" && (typeof tval==="string" || typeof tval==="number") ) { 
                    
                    // new logic for links - they all now follow the format ::LINK::code
                    // print a hidden field for user web calls and links
                    // this is what enables customization of any tile to happen
                    // ::type::LINK::tval  or ::LINK::tval
                    // this special element is not displayed and sits inside the overlay
                    // we only process the non helpers and look for helpers in same list
                    if (  array_key_exists(helperkey, thingvalue) && thingvalue[helperkey] && thingvalue[helperkey].substr(0,2)==="::" ) {
                        var helperval = thingvalue[helperkey];
                        $tc += putLinkElement(bid, helperval, kindex, cnt, j, thingtype, tval, tkey, subtype, bgcolor);
                    } else {
                        $tc += putElement(kindex, cnt, j, thingtype, tval, tkey, subtype, bgcolor);
                    }

                    j++;
                }
            }
				
        } else {
            $tc += putElement(kindex, cnt, 0, thingtype, thingvalue, thingtype, subtype);
        }
    }
    $tc += "</div>";
    
    return $tc;
}

function putLinkElement(bid, helperval, kindex, cnt, j, thingtype, tval, tkey, subtype, bgcolor) {

    var linktype = thingtype;
    var linkbid = bid;
    var realsubid = tkey;
    var idx = thingtype + "|" + bid;

    var ipos = helperval.indexOf("::",2);
    var command = helperval.substring(2, ipos);
    var linkval = helperval.substring(ipos+2);

    // get info for links
    if ( command==="LINK" ) {
        var lidx = linkval;
        linkval = GLB.options.index[lidx];
        var idxitems = lidx.split("|");
        linktype = idxitems[0];
        linkbid = idxitems[1];

        // use the link value - if subid isn't there look for subid's that form the beginning of our link subid
        if ( array_key_exists(lidx, allthings) ) {
            var linktileval = allthings[lidx]["value"];
            if ( array_key_exists(realsubid, linktileval) ) {
                tval = linktileval[realsubid];
            } else {
                for (var ltkey in linktileval) {
                    if ( realsubid.startsWith(ltkey) ) {
                        realsubid = ltkey;
                        tval = linktileval[ltkey];
                        break;
                    }
                }
            }

            // save the value in our main array for user queries and api calls
            // note that all screen refreshes will come here again and update it
            // but we skip this for non permanent things being made for visual sake
            if ( cnt!== 0 ) {
                allthings[idx]["value"][tkey] = tval;
            }
        }
    }

    // use the original type here so we have it for later
    // but in the actual target we use the linktype
    var sibling= "<div linktype=\""+linktype+"\" value=\""+tval+"\" linkval=\""+linkval+"\" command=\""+command+"\" subid=\""+realsubid+"\" linkbid=\"" + linkbid + "\" class=\"user_hidden\"></div>";
    if ( DEBUG10 ) {
        console.log( (ddbg()), "bid: ", bid, " helperval: ", helperval, " sibling: ", sibling);
    }
    var $tc = putElement(kindex, cnt, j, linktype, tval, tkey, subtype, bgcolor, sibling, realsubid);
    return $tc;
}

// cleans up the name of music tracks for proper html page display
// no longer trim the name because that breaks album art
function fixTrack(tval) {
    if ( !tval || tval.trim()==="" ) {
        tval = "None"; 
    }
    return tval;
}

function putElement(kindex, i, j, thingtype, tval, tkey, subtype, bgcolor, sibling, realsubid) {
    var $tc = "";
    var aitkey = "a-" + i + "-" + tkey;
    var pkindex = " p_" + kindex;
    var aidi = "<div aid=\"" + i + "\"";
    var ttype = " type=\"" + thingtype + "\"";
    var colorval = "";
    if ( typeof subtype === "undefined" ) {
        subtype = "";
    } else if ( typeof subtype === "string" && subtype.substr(0,1)!==" " ) {
        subtype = " " + subtype;
    }
    if ( bgcolor && (tkey==="hue" || tkey==="saturation") ) {
        colorval = bgcolor;
    }
    if ( !tval ) { tval = ""; }
        
    // fix thermostats to have proper consistent tags
    // this is supported by changes in the .js file and .css file
    if ( tkey==="heat" || tkey==="cool" || tkey==="hue" || tkey==="saturation" ||
         tkey==="heatingSetpoint" || tkey==="coolingSetpoint" ) {
        
        // fix thermostats to have proper consistent tags
        // this is supported by changes in the .js file and .css file
        $tc += "<div class=\"overlay " + tkey + " " + subtype + " v_" + kindex + "\">";
        if (sibling) { $tc += sibling; }
        $tc += aidi + " subid=\"" + tkey + "-dn\" title=\"" + thingtype + " down\" class=\"" + thingtype + " " + tkey + "-dn" + pkindex + "\"></div>";
        $tc += aidi + " subid=\"" + tkey + "\" title=\"" + thingtype + " " + tkey + "\" class=\"" + thingtype + " " + tkey + pkindex + "\"" + colorval + " id=\"" + aitkey + "\">" + tval + "</div>";
        $tc += aidi + " subid=\"" + tkey + "-up\" title=\"" + thingtype + " up\" class=\"" + thingtype + " " + tkey + "-up" + pkindex + "\"></div>";
        $tc += "</div>";
    
    
    // process analog clocks signalled by use of a skin with a valid name other than digital
    } else if ( thingtype==="clock" && tkey==="skin" && tval && tval!=="digital" ) {
        $tc += "<div class=\"overlay "+tkey+" v_"+kindex+"\">";
        if (sibling) { $tc += sibling; }
        $tc += aidi + ttype + "\"  subid=\""+tkey+"\" title=\"Analog Clock\" class=\"" + thingtype + subtype + pkindex + "\" id=\""+aitkey+"\">" +
              "<canvas id=\"clock_"+i+"\" class=\""+tval+"\"></canvas></div>";
        $tc += "</div>";
    } else {
        // add state of thing as a class if it isn't a number and is a single word
        // also prevent dates and times from being added
        // also do not include any music album or artist names in the class
        // and finally if the value is complex with spaces or other characters, skip
        var extra;
        if ( tkey==="time" || tkey==="date" || tkey==="color" ||
                   (tkey.substr(0,6)==="event_") ||
                   tkey==="trackDescription" || tkey==="currentArtist" || 
                   tkey==="currentAlbum" || tkey==="trackImage" ||
                   tkey==="weatherIcon" || tkey==="forecastIcon" ||
                   !isNaN(+tval) || thingtype===tval || tval==="" || 
                   (tval.substr(0,5)==="track") || 
                   (tval.substr(0,7)==="number_") || 
                   (tval.substr(0,4)==="http") ||
                   (tval.indexOf(" ")!==-1) ) {
            extra = "";
        } else {
            extra = " " + tval;
        }
        
        // fix track names for groups, empty, and super long
        if (tkey==="trackDescription" || tkey==="track") {
            tval = fixTrack(tval);
        } else if (tkey==="trackImage") {
            if ( tval.substr(0,4) === "http" ) {
                tval = "<img width='120' height='120' src='" + tval + "'>";
            }
        } else if ( tkey === "battery") {
            var powmod = parseInt(tval);
            powmod = powmod - (powmod % 10);
            tval = "<div style=\"width: " + tval + "%\" class=\"ovbLevel L" + powmod.toString() + "\"></div>";
        }
        
        // for music status show a play bar in front of it
        // now use the real item name and back enable old one
        // note that we add the sibling to the music controls
        // so that linked tiles will operate properly
        // only one sibling for all the controls. The js file deals with this.
        if (tkey==="musicstatus" || (thingtype==="music" && tkey==="status") ) {
            $tc += "<div class=\"overlay music-controls" + subtype + " v_"+kindex+"\">";
            if (sibling) { $tc += sibling; }
            $tc += aidi + " subid=\"music-previous\" title=\"Previous\" class=\""+thingtype+" music-previous" + pkindex + "\"></div>";
            $tc += aidi + " subid=\"music-pause\" title=\"Pause\" class=\""+thingtype+" music-pause" + pkindex + "\"></div>";
            $tc += aidi + " subid=\"music-play\" title=\"Play\" class=\""+thingtype+" music-play" + pkindex + "\"></div>";
            $tc += aidi + " subid=\"music-stop\" title=\"Stop\" class=\""+thingtype+" music-stop" + pkindex + "\"></div>";
            $tc += aidi + " subid=\"music-next\" title=\"Next\" class=\""+thingtype+" music-next" + pkindex + "\"></div>";
            $tc += "</div>";
        }

        // ignore keys for single attribute items and keys that match types
        var tkeyshow;
        if ( (tkey===thingtype ) || 
             (tkey==="value" && j===0) ) {
            tkeyshow= "";
        // add confirm class for keys that start with c$_ so we can treat like buttons
        } else if ( tkey.substr(0,3) === "c__" ) {
            tkey = tkey.substr(3);
            tkeyshow = " " + tkey + " confirm";
        } else {
            tkeyshow = " " + tkey;
        }

        // add real sub for linked tiles
        if ( realsubid && realsubid!==tkey ) {
            tkeyshow = tkeyshow + " " + realsubid;
        }
         // include class for main thing type, the subtype, a sub-key, and a state (extra)
        // also include a special hack for other tiles that return number_ to remove that
        // this allows KuKu Harmony to show actual numbers in the tiles
        // finally, adjust for level sliders that can't have values in the content
        // hide all of the ISY uom items - couid do in CSS but this is easier and faster
        if ( thingtype==="isy" && tkey.startsWith("uom_") ) {
            $tc += "<div class=\"overlay "+tkey+" hidden v_"+kindex+"\">";
        } else {
            $tc += "<div class=\"overlay "+tkey+" v_"+kindex+"\">";
        }
        if (sibling) { $tc += sibling; }
        if ( tkey === "level" || tkey==="colorTemperature" || tkey==="volume" || tkey==="groupVolume" ) {
            $tc += aidi + ttype + " subid=\""+tkey+"\" value=\""+tval+"\" title=\""+tkey+"\" class=\"" + thingtype + tkeyshow + pkindex + "\" id=\"" + aitkey + "\"></div>";
        } else if ( thingtype==="other" && tval.substr(0,7)==="number_" ) {
            var numval = tkey.substring(8);
            $tc += aidi + ttype + " subid=\"" + tkey+"\" title=\""+tkey+"\" class=\"" + thingtype + subtype + tkeyshow + pkindex + "\" id=\"" + aitkey + "\">" + numval + "</div>";
        } else {
            if ( typeof tval==="string" && tval.substr(0,6)==="RULE::" && subtype!=="rule" ) {
                tkeyshow += " rule";
            }
            $tc += "<div aid=\""+i+"\" type=\""+thingtype+"\"  subid=\""+tkey+"\" title=\""+tkey+"\" class=\"" + thingtype + subtype + tkeyshow + pkindex + extra + "\" id=\"" + aitkey + "\">" + tval + "</div>";
        }
        $tc += "</div>";
    }
    return $tc;
}

function getCustomCount(stype, defcount) {
    var customcnt = defcount;
    if ( array_key_exists("specialtiles", GLB.options.config) ) {
        var specialarr = GLB.options.config["specialtiles"];
        if ( array_key_exists(stype, specialarr) ) {
            customcnt = parseInt(specialarr[stype]);
            if ( isNaN(customcnt) || customcnt < 1 ) { 
                customcnt = defcount; 
            }
        }
    }
    return customcnt;
}

function getCustomName(defname, idx) {
    if ( !GLB.options.rooms || !GLB.options.things || !GLB.options.index ) {
        return defname;
    }

    var rooms = GLB.options["rooms"];
    var thingoptions = GLB.options["things"];
    var tileid = GLB.options["index"][idx];
    for (var room in rooms) {
        if ( array_key_exists(room, thingoptions) ) {
           var things = thingoptions[room];
           for (var kindexarr in things) {
                 // if our tile matches and there is a custom name, use it
                if ( tileid===kindexarr[0] && kindexarr[4] && kindexarr[4]!=="" ) {
                    return kindexarr[4];
                }
           }
        }
    }
    return defname;
}

function getClock(clockname, clockid, clockskin, fmtdate, fmttime) {
    var weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    var clockname = getCustomName(clockname, "clock" + "|" + clockid);
    var d = new Date();
    var dofw = d.getDay();
    var mofy = d.getMonth();
    var weekday = weekdays[dofw];
    var month = months[mofy];
    var day = d.getDate().toString();
    if ( day < 10 ) {
        day = "0" + day.toString();
    } else {
        day = day.toString();
    }
    var year = d.getFullYear().toString();

    var dateofmonth = month + " " + day + ", " + year;
    var timeofday = d.toLocaleTimeString();
    var timezone = d.getTimezoneOffset().toString();
    var dclock = {"name": clockname, "skin": clockskin, "weekday": weekday,
        "date": dateofmonth, "time": timeofday, "tzone": timezone,
        "fmt_date": fmtdate, "fmt_time": fmttime};
    dclock = getCustomTile(dclock, "clock", clockid);
    return dclock;
}

function addSpecials() {
    // set hub number to nothing for manually created tiles
    var hubnum = "-1";

    // add digital clock tile
    // never refresh since clocks have their own refresh timer built into the javascript code
    // you will need to over-ride this with the tile customizer if you add custom fields
    var clockidd = "clockdigital";
    var dclock = getClock("Digital Clock", clockidd, "", "M d, Y", "h:i:s A");
    allthings["clock|"+clockidd] = {"id" :  clockidd, "name" :  dclock["name"], 
        "hubnum" :  hubnum, "type" :  "clock", "refresh": "never", "value" :  dclock};

    // add analog clock tile - no longer use dclock format settings by default
    var clockida = "clockanalog";
    var aclock = getClock("Analog Clock", clockida, "CoolClock:swissRail:72", "M d, Y", "h:i:s A");
    allthings["clock|"+clockida] = {"id" :  clockida, "name" :  aclock["name"], 
        "hubnum" :  hubnum, "type" :  "clock", "refresh": "never", "value" :  aclock};

    // add special tiles based on type and user provided count
    // this replaces the old code that handled only video and frame tiles
    // this also creates image and blank tiles here that used to be made in groovy
    // putting this here allows them to be handled just like other modifiable tiles
    // these tiles all refresh fast except first 4 frames that are reserved for weather
    // renamed accuweather to forecast2 for simplicity sake and to make sorting work
    var specialtiles = utils.getSpecials();
    for (var stype in specialtiles) {
        var sid = specialtiles[stype];
        var speed = (stype==="frame") ? "slow" : "normal";
        var fcnt = getCustomCount(stype, sid[3]);
        if ( fcnt ) {
            for (var i=0; i<fcnt; i++) {

                var k = (i + 1).toString();
                var fid = sid[0] + k;
                var idx = stype + "|" + fid;
                var fn = getCustomName(stype + k, idx);
                var ftile = {"name": fn};
                ftile = returnFile(ftile, stype);
                ftile = getCustomTile(ftile, stype, fid);
                allthings[idx] = {"id":  fid, "name":  ftile["name"], "hubnum":  hubnum, 
                    "type": stype, "refresh": speed, "value":  ftile};
            }
        }
    }
    
    // create the controller tile
    // keys starting with c__ will get the confirm class added to it
    // this tile cannot be customized by the user due to its unique nature
    // but it can be visually styled just like any other tile
    var controlval = {"name": "Controller", "showoptions": "Options","refresh": "Refresh","c__refactor": "Reset",
                 "c__reauth": "Re-Auth","showid": "Show Info","toggletabs": "Toggle Tabs",
                 "showdoc": "Documentation",
                 "blackout": "Blackout","operate": "Operate","reorder": "Reorder","edit": "Edit"};
    allthings["control|control_1"] = {"id":  "control_1", "name":  controlval["name"], "hubnum":  hubnum, 
                "type":  "control", "refresh": "never", "value":  controlval};
}

function getAllThings() {
    
    allthings = {};

    // add the special tiles
    addSpecials();
    updateOptions("/");

    // get all things from all configured servers
    var hubs = GLB.options.config["hubs"];
    if ( hubs && utils.count(hubs) > 0 ) {
        hubs.forEach(function(hub) {
            var hubnum = hub["hubId"];
            var accesstoken  = hub["hubAccess"];
            var hubEndpt = hub["hubEndpt"];
            var clientId = hub["clientId"];
            var clientSecret = hub["clientSecret"];
            var hubName = hub["hubName"];
            var hubType = hub["hubType"];
            getDevices(hubnum, hubType, accesstoken, hubEndpt, clientId, clientSecret, hubName, "/");
        });

    // if no hubs, force a reload to update any special tiles added above
    // otherwise we don't need to do that because a hub reload will catch that
    // } else {
    //     updateOptions("/");
    }
}

// create addon subid's for any tile
// this enables a unique customization effect
// the last parameter is only needed for LINK customizations
function getCustomTile(custom_val, customtype, customid) {
    const reserved = ["index","rooms","things","config","control","useroptions"];

    // do nothing if options are not loaded
    if ( utils.count(GLB.options.rooms)===0 || utils.count(GLB.options.index)===0 || utils.count(GLB.options.things)===0 ) {
        return custom_val;
    }

    try {
        var idx = customtype + "|" + customid;
        var rooms = GLB.options["rooms"];
        var index = GLB.options["index"];
        var thingoptions = GLB.options["things"];
        var tileid = parseInt(GLB.options["index"][idx]);
    } catch(e) {
        return custom_val;
    }
    
    // get custom tile name if it was defined in tile editor and stored
    // in the room array
    var customname= "";
    for (var room in rooms) {
        if ( array_key_exists(room, thingoptions) ) {
            var things = thingoptions[room];
            for (var kindexarr in things) {
                // only do this if we have custom names defined in rooms
                if ( is_array(kindexarr) && kindexarr.length > 3 ) {
                    var kindex = kindexarr[0];

                    // if our tile matches and there is a custom name, use it
                    if ( kindex===tileid && kindexarr[4]!=="" ) {
                        customname = kindexarr[4];
                        break;
                    }
                }
            }
        }
    }
    
    if ( customname!=="" ) {
        custom_val["name"] = customname;
    }
    
    // see if a section for this id is in options file
    var lines = false;
    if (array_key_exists("user_" + customid, GLB.options) ) {
        lines = GLB.options["user_" + customid];
    } else if ( !in_array (customid, reserved) && array_key_exists(customid, GLB.options) ) {
        lines = GLB.options[customid];
    }

    // ignores = [" ","'","*","<",">","!","{","}","-",".",",",":","+","&","%"];
    if ( lines && is_array(lines) ) {
        
        // allow user to skip wrapping single entry in an array
        // the GUI will never do this but a user might in a manual edit
        if ( !is_array(lines[0]) ) {
            lines = [lines];
        }
        
        // first remove existing ones so we can readd them in the proper order
        lines.forEach(function(msgs) {
            var subidraw = msgs[2].trim();
            var subid = subidraw.replace(/[\"\*\<\>\!\{\}\.\,\:\+\&\%]/g,""); //  str_replace(ignores, "", subidraw);
            var companion = "user_" + subid;
            delete custom_val[subid];
            delete custom_val[companion];
        });
        
        // sort the lines and add them back in the requested order
        // replacements of default items will occur in default place
        // usort(lines, sortlinefunc);
        
        // loop through each item and add to tile
        lines.forEach(function(msgs) {

           
            // check to make sure we have an array of three long
            // this strict rule is followed to enforce discipline use
            if ( is_array(msgs) && msgs.length >= 3 ) {
            
                var calltype = msgs[0].toString().toUpperCase().trim();
                var content = msgs[1].toString().trim();
                var posturl = encodeURIComponent(content);
                var subidraw = msgs[2].trim();
                var subid = subidraw.replace(/[\"\*\<\>\!\{\}\.\,\:\+\&\%]/g,""); //  str_replace(ignores, "", subidraw);
                var companion = "user_" + subid;
    
                // process web calls made in custom tiles
                // this adds a new field for the URL or LINK information
                // in a tag called user_subid where subid is the requested field
                // web call results and linked values are stored in the subid field
                if ( content && content.toLowerCase().substr(0,4) === "http" &&
                     (calltype==="PUT" || calltype==="GET" || calltype==="POST")  )
                {
                    custom_val[companion] = "::" + calltype + "::" + posturl;
                    custom_val[subid] = calltype + "::" + subid;
               
                } else if ( calltype==="LINK" ) {
                    // code for enabling mix and match subid's into custom tiles
                    // this stores the tile number so we can quickly grab it upon actions
                    // this also allows me to find the hub number of the linked tile easily
                    // and finally, the linked tile is displayable at user's discretion
                    // for this to work the link info is stored in a new element that is hidden
                    
                    var idx = array_search(content, index);

                    // changed the link logic so we don't need to know the value at link time
                    // if ( allthings && idx!== false && array_key_exists(idx, allthings) ) {
                    if ( idx !== false ) {
                        // var thesensor = allthings[idx];
                        // var pvalue = thesensor["value"];
                        // var thetype = thesensor["type"];
                
                        // if the subid exists in our linked tile add it
                        // this can replace existing fields with linked value
                        // if an error exists show text of intended link
                        // first case is if link is valid and not an existing field
                        // if ( array_key_exists(subid, pvalue) ) {
                            custom_val[companion] = "::" + calltype + "::" + idx;
                            custom_val[subid]= "LINK::" + content; // pvalue[subid];
                            
                        // final two cases are if link tile wasn't found
                        // first sub-case is if subid begins with the text of a valid key
                        // } else {
                        //     // handle user provided names that start with a valid link subid
                        //     // and there is more beyond the start than numbers
                        //     var realsubid = false;
                        //     for (var key in custom_val) {
                        //         if ( subid.indexOf(key) === 0 ) {   // strpos(subid, key) === 0 ) {
                        //             realsubid = key;
                        //             break;
                        //         }
                        //     }
                        //     if ( realsubid ) {
                        //         custom_val[companion] = "::" + thetype + "::" + calltype + "::" + content + "::" + realsubid;
                        //         custom_val[subid]= pvalue[realsubid];
                        //     } else {
                        //         custom_val[companion] = "::" + thetype + "::" + calltype + "::" + content;
                        //         custom_val[subid] = "Invalid link to tile #" + content + " with subid= " + subid;
                        //     }
                        // }
                    } else {
                        custom_val[companion] = "::" + calltype + "::0";
                        custom_val[subid] = "Link::" + subid + "=" + content;
                        console.log( (ddbg()), "Links unavailable to link #" + content + " with subid= " + subid);
                    }

                } else if ( calltype==="URL" ) {
                    custom_val[companion] = "::" + calltype + "::" + posturl;
                    custom_val[subid] = "URL::" + subid;
               
                } else if ( calltype==="RULE" ) {
                    custom_val[companion] = "::" + calltype + "::" + content;
                    custom_val[subid] = "RULE::" + subid;

                } else {
                    // code for any user provided text string
                    // we could skip this but including it bypasses the hub call
                    // which is more efficient and safe in case user provides
                    // a subid that the hub might recognize - this way it is
                    // guaranteed to just pass the text on the browser
                    calltype = "TEXT";
                    custom_val[companion] = "::" + calltype + "::" + content;
                    custom_val[subid] = content;
                }
            }
        });
    }
    return custom_val;
}

// this little gem makes sure levels are always at the end of a tile
// and it puts all user created fields at the end of tile too
function setValOrder(val) {

    var keys = Object.keys(val).sort( function(vala, valb) {

        // look for a companion
        var compa = array_key_exists("user_"+vala, val);
        var compb = array_key_exists("user_"+valb, val);

        // put all companions at the end

        if ( vala===valb ) {
            return 0;
        } else if ( vala==="level" || vala==="colorTemperature" ) {
            return 1;
        } else if ( valb==="level" || valb==="colorTemperature" ) {
            return -1;
        } else if ( vala.startsWith("user_") && valb.startsWith("user_") ) {
            return 0;
        } else if ( vala.startsWith("user_") ) {
            return 1
        } else if ( valb.startsWith("user_") ) {
            return -1
        } else if ( compa && compb ) {
            return 0;
        } else if ( compa ) {
            return 1;
        } else if ( compb ) {
            return -1;
        } else {
            return 0;
        }
    });

    var newval = {};
    keys.forEach( function(key) {
        newval[key] = val[key];
    });

    return newval;
}

// this function handles processing of all websocket calls from ISY
// used to keep clients in sync with the status of ISY operation
function processIsyMessage(isymsg) {
    xml2js(isymsg, function(err, result) {
        if ( !err && result.Event ) {
            var control = result.Event.control;
            var action = result.Event.action;
            var node = result.Event.node;
            if ( DEBUG9 ) {
                console.log( (ddbg()), "ISY event: ", isymsg, " result: ", UTIL.inspect(result, false, null, false) );
            }

            if ( is_array(node) && node.length && node[0]!=="" &&
                 is_array(control) && control.length && control[0]!=="" ) {
                var bid = node[0];
                var idx = "isy|" + bid;

                if ( allthings && allthings[idx] && allthings[idx].value && allthings[idx].type==="isy" ) {
                    var value = allthings[idx].value;
                    try {
                        var newval = action[0]["_"] || value[subid];
                        var uom = action[0]["$"]["uom"] || "";

                        // adjust the value based on precision
                        if ( action[0]["$"]["prec"] ) {
                            var prec = parseInt(action[0]["$"]["prec"]);
                            if ( ! isNaN(prec) && prec > 0 ) {
                                var pow10 = Math.pow(10,prec);
                                newval = parseFloat(newval) / pow10;
                            } else {
                                newval = parseFloat(newval);
                            }
                        }

                        newval = newval.toString();
                    } catch (e) {
                        if ( DEBUG9 ) {
                            console.log( (ddbg()), "error - webSocket returned: ", UTIL.inspect(result, false, null, false) );
                        }
                        return;
                    }

                    var newvalue = translateIsy(bid, control[0], uom, value, newval, "");
                    var subid = mapIsy(control[0], uom);
                    allthings[idx].value = newvalue;

                    pushClient(bid, "isy", subid, newvalue, false, false);

                    // process rules and links
                    if ( GLB.options.config["rules"] ==="true" || GLB.options.config["rules"] ===true ) {
                        processRules(bid, "isy", subid, newvalue);
                        processLinks(bid, "isy", subid, newvalue);
                    }
                    if ( DEBUG9 ) {
                        console.log("ISY webSocket updated node: ", bid, " trigger:", control[0], " uom: ", uom, " newval: ", newval, " value: ", newvalue);
                    }
                }
            }
        }
    });
}

function processRules(bid, thetype, trigger, pvalue) {

    // go through all things that could be links for this tile
    var userid = "user_" + bid;

    if ( DEBUG11 ) {
        console.log( (ddbg()), "RULE debug...");
    }

    // if this tile has no rule, do nothing
    if ( !array_key_exists(userid, GLB.options) ) {
        return;
    }

    // go through all tiles with a new rule type
    var idx = thetype + "|" + bid;
    try {
        var index = GLB.options["index"];
        var tileid = index[idx].toString();
    } catch (e) {
        console.log( (ddbg()), "webSocket RULE error: id: ", bid, " type: ", thetype, " trigger: ", trigger, " error: ", e);
        return;
    }
    
    // rule structure
    // you cannot safely mix the logic of "or" with the logic of "and"
    // if num=subid>=xx or num=subid=on or num=subid=off... , num=subid=value=attr, num=subid=value=attr, ...
    // if num=subid>=xx and num=subid=on and num=subid=off... , num=subid=value=attr, num=subid=value=attr, ...
    // for example...
    // user_custome_1 : [ [RULE, "if 12=switch==on and 167=switch==on, 28=switch=on, 12=switch=on", myrule, 1], 
    //                   [RULE, "if 71=state==away or 42=presence==absent", 19=thermostatMode=heat, 19=heatingSetpoint=72, 14=lock=lock, rule2, 2] ]

    const regsplit = /[,;]/;
    const ifpattern = /(if)\s+(.*)/;
    const rulepattern = /(\d*)\s*=\s*(\w+)\s*([=|!|<|>])(=?)\s*(\w+)/;
    const actpattern = /(\d+)\s*=\s*(\w+)\s*=\s*(\w+)\s*=?\s*(.*)/;
    
    // print some debug info
    var items = GLB.options[userid];
    if ( DEBUG11 ) {
        console.log( (ddbg()), "RULE: id: ", bid, " type: ", thetype, " trigger: ", trigger, " tileid: ", tileid, " userid: ", userid, " rules: ", UTIL.inspect(items, false, null, false));
    }

    // loop through all the custom elements of this tile looking for rules
    items.forEach( function(item) {

        // process custom entries that are rules
        // the subid it is tied to is ignored as is the order number
        // so we only need to get item[0] and item[1]
        if ( item[0]==="RULE" ) {
            var linkval = item[1].trim();
            var isrule = false;
            var isfirst = true;

            // split the test line between commas and semi-colons
            var testcommands = linkval.split(regsplit);

            // only proceed if there are at least two parts and the first part starts with "if "
            if ( testcommands.length > 1 && testcommands[0].startsWith("if") ) {


                // get the if and the rule and continue if in the right format
                var iftest = testcommands[0].match(ifpattern);
                var rulestr = (iftest && iftest.length>1 && iftest[2]) ? iftest[2] : "";
                if ( DEBUG11 ) {
                    console.log( (ddbg()), "RULE debug: iftest: ", iftest, " rulestr: ", rulestr);
                }
            
                if ( iftest[1]==="if" && rulestr ) {

                    // get the rule set
                    var ruleset = rulestr.split(" ");
                    var doand = true;
                    if ( DEBUG11 ) {
                        console.log( (ddbg()), "RULE debug: rulseset: ", ruleset);
                    }
    
                    // loop through each one and add to test
                    ruleset.forEach( function(rule) {

                        rule = rule.trim();
                        if ( DEBUG11 ) {
                            console.log( (ddbg()), "RULE debug: rule: ", rule);
                        }
    
                        // set rule mode based on word - if it is "and" then use and logic
                        if ( rule==="and" || rule==="&&" ) {
                            doand = true;

                        // if the separator word is "or" then use or logic
                        } else if ( rule==="or" || rule==="||" ) {
                            doand = false;

                        // otherwise we are on an element so interpret the test
                        } else {
                            var ruleparts = rule.match(rulepattern);
                            if ( DEBUG11 ) {
                                console.log( (ddbg()), "RULE debug: before rule: ", doand, " ", rule, " isrule: ", isrule);
                            }
    
                            // compute the test if this test part has the required elements
                            if ( ruleparts ) {
                                var ruletileid = parseInt(ruleparts[1]);
                                var rulesubid = ruleparts[2];
                                var ruleop = ruleparts[3];
                                var ruleop2 = ruleparts[4];
                                if ( ruleop2 ) { ruleop = ruleop + ruleop2; }
                                var rulevalue = ruleparts[5];

                                var ifvalue = false;

                                // if zero given use the current tile
                                if ( isNaN(ruletileid) || ruletileid===0 ) {
                                    ifvalue = pvalue[rulesubid];
                                } else {
                                    // find the tile index and proceed with activating the rule
                                    var ridx = array_search(ruletileid, GLB.options["index"]);
                                    try {
                                        var ritems = ridx.split("|");
                                        var rtype = ritems[0];
                                        // var rid = ritems[1];
                                        ifvalue = allthings[ridx]["value"][rulesubid];
                                    } catch (e) {
                                        ifvalue = false;
                                    }
                                }

                                // fix up ISY hubs
                                if ( rtype==="isy" && rulevalue==="on" ) { rulevalue = "DON"; }
                                if ( rtype==="isy" && rulevalue==="off" ) { rulevalue = "DOF"; }

                                if ( DEBUG11 ) {
                                    console.log( (ddbg()), "RULE debug: ruleop: ", ruleop, " ridx: ", ridx, " ifvalue: ", ifvalue, "rulevalue: ", rulevalue, " ruletileid: ", ruletileid, " parts: ", ruleparts );
                                }

                                    // get the rule check if the requested subid is recognized
                                if ( ruleop && ifvalue!==false ) {

                                    var ismatch = ( 
                                        ( (ruleop==="=" || ruleop==="==") && (ifvalue===rulevalue) ) ||
                                        ( (ruleop==="!" || ruleop==="!=") && (ifvalue!==rulevalue) ) ||
                                        ( (ruleop==="<" ) && (ifvalue <  rulevalue) ) ||
                                        ( (ruleop==="<=") && (ifvalue <= rulevalue) ) ||
                                        ( (ruleop===">" ) && (ifvalue >  rulevalue) ) ||
                                        ( (ruleop===">=") && (ifvalue >= rulevalue) ) 
                                    );

                                    // apply and/or logic to the final rule determination
                                    if ( doand ) {
                                        isrule = isfirst ? ismatch : isrule && ismatch;
                                    } else {
                                        isrule = isfirst ? ismatch : isrule || ismatch;
                                    }
                                }
                            }

                            // flag that we are not on the first loop now
                            isfirst = false;
                        }

                        // report state of test
                        if ( DEBUG11 ) {
                            console.log( (ddbg()), "RULE debug: after rule: ", doand, " ", rule, " isrule: ", isrule);
                        }
            
                    });
                }
            } else {
                isrule = false;
            }

            if ( DEBUG11 ) {
                console.log( (ddbg()), "RULE debug: isrule: ", isrule);
            }
            if ( isrule ) {

                // perform all of the commands if we meet the if test
                for (var i= 1; i<testcommands.length; i++) {
                    var autostr = testcommands[i];

                    // get the parts of the auto exec
                    var autoexec = autostr.match(actpattern);
                    if ( autoexec ) {
                        var rtileid = autoexec[1];
                        var rsubid = autoexec[2];
                        var rvalue = autoexec[3];
                        var rswattr = autoexec[4] ? autoexec[4] : "";

                        if ( DEBUG11 ) {
                            console.log( (ddbg()), "RULE debug: rtileid: ", rtileid, " rsubid: ", rsubid, " rvalue: ", rvalue, " rswattr: ", rswattr);
                        }
            
                        // find the tile index and proceed with activating the rule
                        var ridx = array_search(rtileid, GLB.options["index"]);
                        if ( ridx ) {
                            var idxitems = ridx.split("|");
                            var rswtype = idxitems[0];
                            var rswid = idxitems[1];

                            // fix up ISY hubs
                            if ( rswtype==="isy" && rvalue==="on" ) { rvalue = "DON"; }
                            if ( rswtype==="isy" && rvalue==="off" ) { rvalue = "DOF"; }

                            if ( rsubid==="level" || rsubid==="colorTemperature" ) {
                                rswattr= "level";
                            } else if ( rsubid==="switch") {
                                rswattr="";
                            } else if ( !rswattr ) {
                                swattr= swtype + " p_" + rtileid + " " + rswval;
                            }
                            var hubid = allthings[ridx]["hubnum"];
                            var hub = findHub(hubid);
                            if ( hub ) {
                                callHub(hub, rswid, rswtype, rvalue, rswattr, rsubid, false, false);
                            }
                        }


                    }
                }
                
            }

        }

    });

}

function processLinks(bid, thetype, trigger, pvalue) {

    // go through all things that could be links for this tile
    var userid = "user_" + bid;

    // if this tile has no link, do nothing
    if ( !array_key_exists(userid, GLB.options) ) {
        return;
    }

    // determine the type of trigger
    var ontrigger = false;
    if ( trigger==="motion" && (pvalue.motion ==="active" || pvalue.switch ==="DON") ) {
        ontrigger = "on";
    } else if ( trigger==="motion" && (pvalue.motion ==="inactive" || pvalue.switch ==="DOF") ) {
        ontrigger = "off";
    } else if ( trigger==="contact" && (pvalue.contact ==="open"  || pvalue.switch ==="DON") ) {
        ontrigger = "on";
    } else if ( trigger==="contact" && (pvalue.contact ==="closed" || pvalue.switch ==="DOF") ) {
        ontrigger = "off";
    } else if ( trigger==="switch" && (pvalue.switch ==="on" || pvalue.switch ==="DON") ) {
        ontrigger = "on";
    } else if ( trigger==="switch" && (pvalue.switch ==="off" || pvalue.switch ==="DOF") ) {
        ontrigger = "off";
    }

    // debug info
    var idx = thetype + "|" + bid;
    if ( DEBUG9 ) {
        console.log( (ddbg()), "linked trigger: ", trigger, " on trigger: ", ontrigger, " idx: ", idx, " pvalue: ", pvalue);
    }

    if ( !ontrigger ) {
        return;
    }

    var items = GLB.options[userid];
    var linkidx;
    items.forEach( function(item) {

        // process only links
        if ( item[0]==="LINK" ) {
            var tilenum = parseInt(item[1]);
            var linksubid = item[2];

            // auto trigger any linked field that is a switch
            // this has to start with the name switch
            if ( isNaN(tilenum) || !linksubid.startsWith("switch") )  {
                console.log( (ddbg()), "error - either a non-integer provided or not a switch in LINK attempt. tilenum: ", item[1], " subid: ", linksubid);
                linkidx = false;
            } else {
                if ( DEBUG9 ) {
                    console.log( (ddbg()), "Processing LINK for tilenum: ", tilenum, " subid: ", item[2]);
                }
                linkidx = array_search(tilenum, GLB.options.index);
            }

            if ( linkidx!==false ) {
                var linktype = allthings[linkidx]["type"];

                // fix up isy devices
                if ( linktype==="isy" && ontrigger==="on" ) { ontrigger = "DON"; }
                if ( linktype==="isy" && ontrigger==="off" ) { ontrigger = "DOF"; }

                var linkbid = allthings[linkidx]["id"];
                var hubId = allthings[linkidx]["hubnum"];
                var hub = findHub(hubId);

                // hub, swid, swtype, swval, swattr, subid, linkinfo, popup
                callHub(hub, linkbid, linktype, ontrigger, "", "switch");

                // push to clients immediately
                // Note: this isn't really needed since callHub also pushes status when done
                // but we can do it here to create instant feedback
                // the code is commented out because I want to mirror what is actually happening
                // pushClient(linkbid, linktype, "switch", {switch: ontrigger}, false, false);
                // pushClient(linkbid, linktype, linksubid, {switch: ontrigger}, false, false);
            }
        }

    });

}

function pushClient(swid, swtype, subid, body, linkinfo, popup) {
    // send the new results to all clients
    var entry = {};
    if ( typeof subid === "undefined" ) { subid= ""; }
    entry["id"] = swid;
    entry["type"] = swtype;
    entry["clientcount"] = clients.length;
    entry["trigger"] = subid;
    if ( typeof popup!=="undefined" && popup===true ) {
        entry["popup"] = "popup";
    } else {
        entry["popup"] = "";
    }
    var pvalue;

    if ( typeof body === "undefined" || body==="" || !body ) {
        pvalue = {};
    } else if ( typeof body === "string") {
        pvalue = JSON.parse(body);
    } else if ( typeof body === "object") {
        pvalue = body;
    } else {
        console.log( (ddbg()), "warning - unrecognized body in hub push update: ", body);
        return;
    }

    if ( pvalue["password"] ) { delete pvalue["password"]; }
        
    // remove color for now until we get it fixed - but report it so I can inspect
    if ( pvalue["color"] ) {
        console.log( (ddbg()), "webSocket color: ", pvalue.color);
        delete( pvalue["color"] );
    }

    // save the result to push to all clients
    entry["value"] = pvalue;
    if ( DEBUG9 ) {
        console.log( (ddbg()), "pushClient: ", UTIL.inspect(entry, false, null, false), " linkinfo: ", linkinfo);
    }

    // update the main array with changed push values
    if ( swid!=="reload" && swid!=="popup" ) {
        var idx = swtype + "|" + swid;
        var lidx = "";
        var lsubid = "";
        var lreal = "";
        if ( linkinfo && is_array(linkinfo) ) {
            lidx = linkinfo[1] + "|" + linkinfo[0];
            lsubid = linkinfo[2];
            lreal = linkinfo[3];
            // entry["LINK"] = linkinfo;
        }

        if ( array_key_exists(idx, allthings) ) {
            for (var thekey in pvalue) {
                allthings[idx]["value"][thekey] = pvalue[thekey];

                // update the link that triggered if this was a link
                // we do something similar on the client side to change
                // all linked things that match this
                if ( lidx && lsubid && lreal && lreal===thekey ) {
                    allthings[lidx]["value"][lsubid] = pvalue[thekey];
                }
            }
        }
    }

    for (var i=0; i < clients.length; i++) {
        entry["client"] = i+1;
        clients[i].sendUTF(JSON.stringify(entry));
    }

}

function callHub(hub, swid, swtype, swval, swattr, subid, linkinfo, popup) {
    var access_token = hub["hubAccess"];
    var endpt = hub["hubEndpt"];
    if ( DEBUG6 ) {
        console.log( (ddbg()), "callHub: access: ", access_token, " endpt: ", endpt, " subid: ", subid, " attr: ", swattr);
    }

    var isyresp = {};
    if ( hub["hubType"]==="SmartThings" || hub["hubType"]==="Hubitat" ) {
        var host = endpt + "/doaction";
        var header = {"Authorization": "Bearer " + access_token};
        var nvpreq = {"swid": swid,  
                    "swattr": swattr,
                    "swvalue": swval, 
                    "swtype": swtype};
        if ( subid && subid!=="none" ) { nvpreq["subid"] = subid; }
        curl_call(host, header, nvpreq, false, "POST", getHubResponse);

    // this module below is the equivalent of the ST and HE groovy app
    // for ISY where the logic for handling actions is provided
    // compare this to the doAction function in HousePanel.groovy
    } else if ( hub["hubType"]==="ISY" ) {
        var buff = Buffer.from(access_token);
        var base64 = buff.toString('base64');
        var isyheader = {"Authorization": "Basic " + base64};
        var cmd;

        switch(subid) {

            case "level":
                // for now semd both level commands since either could be expected
                // one is for Insteon other is for Polyglot nodes
                // later we will flag this in the item
                var cmd1 = "/nodes/" + swid + "/cmd/SETLVL/" + swval;
                curl_call(endpt + cmd1, isyheader, false, false, "GET", getNodeResponse);

                // convert percentage to 0 - 256 range for Insteon
                var irange = Math.floor(parseInt(swval) * 255 / 100);
                var cmd2 = "/nodes/" + swid + "/cmd/DON/" + irange;
                curl_call(endpt + cmd2, isyheader, false, false, "GET", getNodeResponse);
                isyresp[subid] = swval;
                isyresp["switch"] = "DON";

                // comment this code to preserve the prior dimmer setting; 
                // otherwise the onlevel is set to current level
                // the default behavior for Insteon lights would be to comment this
                // but I kept it here to make them work like all other hubs
                var cmd3 = "/nodes/" + swid + "/cmd/OL/" + irange;
                isyresp["onlevel"] = swval;
                curl_call(endpt + cmd3, isyheader, false, false, "GET", getNodeResponse);
                break;

            case "switch":
                // handle toggle command - note that the GUI will never produce a toggle swval command
                // but the RULE logic can and so can users when using api calls
                if ( swval==="toggle" ) {
                        var currentval = allthings["isy|"+swid]["value"]["switch"];
                        swval = currentval==="DON" ? "DOF" : "DON";
                }
                cmd = "/nodes/" + swid + "/cmd/" + swval;
                curl_call(endpt + cmd, isyheader, false, false, "GET", getNodeResponse);
                isyresp[subid] = swval;
                break;

            case "heatingSetpoint-up":
                var newval = extractTemp(swval);
                if ( !isNaN(newval) ) { 
                    newval++;
                    cmd = "/nodes/" + swid + "/cmd/CLISPH/" + newval.toString();
                    curl_call(endpt + cmd, isyheader, false, false, "GET", getNodeResponse);
                } else {
                    console.log( (ddbg()), "error: thermostat set point cannot be interpreted.  value: ", swval);
                }
                break;

            case "heatingSetpoint-dn":
                var newval = extractTemp(swval);
                if ( !isNaN(newval) ) { 
                    newval--;
                    cmd = "/nodes/" + swid + "/cmd/CLISPH/" + newval.toString();
                    curl_call(endpt + cmd, isyheader, false, false, "GET", getNodeResponse);
                } else {
                    console.log( (ddbg()), "error: thermostat set point cannot be interpreted.  value: ", swval);
                }
                break;
    
        default:
            console.log( (ddbg()), "Command " + subid + " not yet supported for ISY tiles. value: ", swval);

        }
    }
    
    function extractTemp(val) {
        var newval;
        if ( swval.substr(-1)==="F" || swval.substr(-1)==="C" ) {
            newval = parseInt(swval.substr(0, swval.length-2));
        } else {
            newval = parseInt(swval);
        }
        return newval;
    }

    async function getHubResponse(err, res, body) {
        // var response = body;
        if ( err ) {
            console.log( (ddbg()), "Error calling hub: ", err);
        } else {
            if ( DEBUG7 ) {
                console.log( (ddbg()), "doAction: ", swid, " type: ", swtype, " subid: ", subid, " value: ", body);
            }
            // update all clients - this is actually not needed if your server is accessible to websocket updates
            // It is left here because my dev machine sometimes doesn't get websocket pushes
            // you can comment this if your server gets pushes reliable
            // leaving it here causes no harm other than processing the visual update twice
            if ( body ) {
                pushClient(swid, swtype, subid, body, linkinfo, popup);
            }
        }
    }

    async function getNodeResponse(err, res, body) {
        if ( err ) {
            console.log( (ddbg()), "Error calling ISY node: ", err);
        } else {
            var result = parser.parse(body);
            var rres = result.RestResponse;
            if ( DEBUG7 ) {
                console.log( (ddbg()), "ISY doAction: ", rres, " value: ", isyresp, " linkinfo: ", linkinfo);
            }
            // update all clients - this is actually not needed if your server is accessible to websocket updates
            // because ISY will push state updates via a websocket
            // and that will process a similar pushClient but for only those things that change
            // It is left here because my dev machine sometimes doesn't get websocket pushes
            // you can comment this if your server gets pushes reliable
            // leaving it here causes no harm other than processing the visual update twice
            if ( rres && rres.status.toString()==="200" ) {
                pushClient(swid, swtype, subid, isyresp, linkinfo, popup);
            }
        }
    }

}

function queryHub(hub, swid, swtype, popup) {
    var access_token = hub["hubAccess"];
    var endpt = hub["hubEndpt"];
    if ( hub["hubType"]==="SmartThings" || hub["hubType"]==="Hubitat" ) {
        var host = endpt + "/doquery";
        var header = {"Authorization": "Bearer " + access_token};
        var nvpreq = {"swid": swid, "swtype": swtype};
        curl_call(host, header, nvpreq, false, "POST", getQueryResponse);
    } else if ( hub["hubType"]==="ISY" ) {
        var buff = Buffer.from(access_token);
        var base64 = buff.toString('base64');
        var header = {"Authorization": "Basic " + base64};
        var cmd = "/nodes/" + swid;
        curl_call(endpt + cmd, header, false, false, "GET", getNodeQueryResponse);
    }
    
    async function getQueryResponse(err, res, body) {
        if ( err ) {
            console.log( (ddbg()), "Error requesting hub node query: ", err);
        } else {
            if ( DEBUG5 ) {
                console.log( (ddbg()), "doQuery: ", swid, " type: ", swtype, " value: ", body);
            }
            if ( body ) {
                pushClient(swid, swtype, "none", body, null, popup);
            }
        }
    }

    function getNodeQueryResponse(err, res, body) {
        if ( err ) {
            console.log( (ddbg()), "Error requesting ISY node query: ", err);
        } else {
            var result = parser.parse(body);

            xml2js(body, async function(xmlerr, result) {
                try {
                    if ( result ) {
                        var nodeid = result.nodeInfo.node[0]["address"];
                        if ( nodeid ) {
                            var idx = "isy|" + nodeid;
                            var value = clone(allthings[idx]["value"]);
                            var props = result.nodeInfo.properties[0].property;
                            setIsyFields(nodeid, value, props); // result.nodeInfo);
                        } else {
                            throw "Something went wrong reading node from ISY in getNodeQueryResponse";
                        }
                    }
                } catch(e) { 
                    console.log( (ddbg()), "error in getNodeQueryResponse: ", e);
                }
            });
        }

    }
}

function findHub(hubid) {
    var hub =  GLB.options.config["hubs"][0];
    for (var h in  GLB.options.config["hubs"]) {
        var ahub =  GLB.options.config["hubs"][h];
        if ( ahub["hubId"]===hubid ) { hub = ahub; }
    }
    return hub;
}

// update the hubs array with a new hub value of a certain ID
// if not found the hub is added
function updateHubs(newhub, oldid) {
    var num = 0;
    oldid = oldid.toString();
    var found = false;

    // every hub that matches gets updated
    // should only be one but just in case
    GLB.options.config.hubs.forEach(function(hub) {
        if ( hub["hubId"].toString() === oldid ) {
            GLB.options.config.hubs[num] = clone(newhub);
            found = true;
        }
        num++;
    });

    // if not found then add new hub
    if ( !found ) {
        GLB.options.config.hubs.push(newhub);
    }
    return found;
}

function doAction(hubid, swid, swtype, swval, swattr, subid, tileid, command, linkval, protocol) {

    var response = {};
    var idx;

    if ( (swid==="none" || swtype==="none" || swtype==="" || swid==="" || swid==="0") && tileid )  {
        idx = array_search(tileid, GLB.options["index"]);
        if ( idx===false || idx.indexOf("|")===-1 ) {
            return "error - invalid tile: " + tileid;
        }
        var items = idx.split("|");
        swtype = items[0];
        swid = items[1];
    } else {
        idx = swtype + "|" + swid;
    }
    var specialtiles = utils.getSpecials();

    // handle clocks
    if ( (typeof command==="undefined" || command==="") && swid==="clockdigital") {
        response = getClock("Digital Clock", "clockdigital", "", "M d, Y", "h:i:s A");
    } else if ( (typeof command==="undefined" || command==="") && swid==="clockanalog" ) {
        response = getClock("Analog Clock", "clockanalog", "CoolClock:swissRail:72", "M d, Y", "h:i:s A");
    
    // handle types that just return the current status
    } else if   (   (typeof command==="undefined" || command==="") && 
                    (  swtype==="contact" || swtype==="presence" || swtype==="motion" || subid==="temperature" || swtype==="weather" 
                       // || ( command==="LINK" && (subid==="contact" || subid==="presence" || subid==="motion" || subid==="name" || subid==="temperature") )
                    )
                ) {
        response = allthings[idx]["value"];
        
    // send name, width, height to returnFile routine to get the html tag
    } else if ( (typeof command==="undefined" || command==="") && array_key_exists(swtype, specialtiles) ) {
        var thingvalue = allthings[idx]["value"];
        thingvalue = returnFile(thingvalue, swtype);
        response = thingvalue;
    } else {

        // get the hub to call
        if ( hubid==="auto" ) {
            hubid = allthings[idx]["hubnum"];
        }
        var hub = findHub(hubid);

        // first check if this subid has a companion link or post element
        // and if so, handle differently using the linked info or making a web service call
        // this requires alloptions to be loaded which is true if an active session
        // which is fine because linked tiles don't make sense for API calls anyway
        // use command to signal this - HUB is usual case which makes hub call
        if ( command==="" || !command ) {
            linkval = "";
            command = "HUB";
        }
    
        switch(command) {

            case "POST":
            case "PUT":
            case "GET":
                var posturl = decodeURIComponent(linkval);
                curl_call(posturl, false, false, false, command, urlCallback);
                break;
            
            case "TEXT":
                response = allthings[idx]["value"];
                response[subid] = linkval;
                break;

            case "LINK":
                var lidx = array_search(linkval, GLB.options["index"]);

                if ( lidx ) {
                    var $linked_hubnum = allthings[lidx]["hubnum"];
                    var $linked_swtype = allthings[lidx]["type"];
                    var $linked_swid = allthings[lidx]["id"];
                    var $linked_val = allthings[lidx]["value"];

                    // make hub call if requested and if the linked tile has one
                    var $lhub = findHub($linked_hubnum);

                    // if the link subid is in the linked tile then it is the real subid
                    // otherwise it is a duplicate with info after subid so lets find the real one
                    // this is what allows us to have the same subid referenced to different tiles
                    if ( array_key_exists(subid, $linked_val) ) {
                        var $realsubid = subid;
                    } else {
                        $realsubid = false;
                        for (var key in $linked_val) {
                            if ( subid.indexOf(key) === 0 ) {   //  strpos($subid, key) === 0 ) {
                                $realsubid = key;
                                break;
                            }
                        }
                    }
                    
                    // make the action call on the linked thing
                    // the hub callback now handles the linked resposnes properly
                    // if link is to something static, show it
                    if ( $realsubid==="contact" || $realsubid==="presence" || $realsubid==="motion" || $realsubid==="name"|| subid==="temperature" || 
                         $linked_swtype==="contact" || $linked_swtype==="presence" || $linked_swtype==="motion" || $linked_swtype==="weather") {
                        response = $linked_val;
                    } else if ( $realsubid ) {
                        var linkinfo = [swid, swtype, subid, $realsubid];
                        callHub($lhub, $linked_swid, $linked_swtype, swval, swattr, $realsubid, linkinfo, false);
                        response = "success";
                    }
                }
                break;

            case "RULE":
                var rulecommands = linkval.split(",");
                rulecommands.forEach(function(rule) {
                    rule = rule.trim();
                    var rulepair = rule.split("=");

                    // skip rules that are designed to auto-trigger via webSockets
                    if ( rulepair[0]!=="if" ) {

                        var tileid = parseInt(rulepair[0]);

                        // only process rules that have the required number of fields and a valid tile number
                        if ( rulepair.length>=3 && !isNaN(tileid) ) {
                            subid = rulepair[1].toString().trim();
                            swval = rulepair[2].toString().trim();

                            idx = array_search(tileid, GLB.options["index"]);
                            if ( idx ) {
                                items = idx.split("|");
                                swtype = items[0];
                                swid = items[1];

                                // fix up ISY hubs
                                if ( swtype==="isy" && swval==="on" ) { swval = "DON"; }
                                if ( swtype==="isy" && swval==="off" ) { swval = "DOF"; }
                                
                                if ( rulepair.length > 3 ) {
                                    swattr = rulepair[3].toString().trim();
                                } else if ( subid==="level" || subid==="colorTemperature" ) {
                                    swattr="level";
                                } else if ( subid==="switch") {
                                    swattr="";
                                } else {
                                    swattr= swtype + " p_" + tileid + " " + swval;
                                }
                                hubid = allthings[idx]["hubnum"];
                                var hub = findHub(hubid);
                                if ( hub ) {
                                    callHub(hub, swid, swtype, swval, swattr, subid, false, false);
                                }
                            }
                        }
                    }
                });
                response = "success";
                break;

            case "HUB":
                callHub(hub, swid, swtype, swval, swattr, subid, false, false);
                response = "success";
                break;

            default:
                response = "error";
        }


    }

    async function urlCallback(err, res, body) {
        var webresponse = {};
        if ( err ) {
            webresposne[subid] = command + ": error";
        } else if ( typeof body === "object" ) {
            webresponse[subid] = JSON.stringify(body);
        } else {
            webresponse[subid] = body;
        }
        // push the response to the clients
        pushClient(swid, swtype, subid, webresponse);
    }

    // while (!finished) { }
    return response;
}

function doQuery(hubid, swid, swtype, tileid, protocol) {
    var result;
    if ( (swid==="all") || (swid==="fast"  && swtype==="fast") || (swid==="slow" && swtype==="slow") ) {
        result = {};
        for (var idx in (allthings || {}) ) {
            var res = allthings[idx];
            var item = GLB.options["index"][idx];
            result[item] = res;
        }
    } else {
        if ( (swid==="none" || swtype==="none" || swtype==="" || swid==="" || swid==="0") && tileid )  {
            idx = array_search(tileid, GLB.options["index"]);
            if ( idx===false || idx.indexOf("|")===-1 ) {
                return "error - invalid tile: " + tileid;
            }
            var items = idx.split("|");
            swtype = items[0];
            swid = items[1];
        } else {
            idx = swtype + "|" + swid;
        }

        if ( allthings && array_key_exists(idx, allthings) && array_key_exists("value", allthings[idx]) ) {
            // return current value and send updated value after hub call to clients and popup window
            if ( hubid==="auto" ) {
                hubid = allthings[idx]["hubnum"];
            }
            var hub = findHub(hubid);
            result = allthings[idx]["value"];
            if ( result["password"] ) {
                delete result["password"];
            }

            // only query the hub which pushes update to GUI if we queried using POST
            // which normally is only from GUI but user could use POST so beware
            // that if you use the HP api in POST mode that all clients will be updated
            // whenever you query a tile. To avoid this use the GET method to query a tile
            // note that actions will always update clients to keep them in sync
            if ( protocol==="POST" ) {
                queryHub(hub, swid, swtype, false);
            }
        } else {
            result = "error - invalid api request. hubid= " + hubid + " id= " + swid + " type= " + swtype + " tile= " + tileid;
        }
    }
    return result;
}

function setOrder(swid, swtype, swval, swattr) {
    var updated = false;
    var result = "error";
    var options = clone(GLB.options);

    // if the options file doesn't exist here something went wrong so skip
    if (options) {
        // now update either the page or the tiles based on type
        switch(swtype) {
            case "rooms":
                options["rooms"] = {};
                for (var roomname in swval) {
                    var roomid = parseInt(swval[roomname]);
                    options["rooms"][roomname] = roomid;
                }
                updated = true;
                result = "success"; // options["rooms"];
                break;

            case "things":
                if (array_key_exists(swattr, options["rooms"])) {
                    options["things"][swattr] = [];
                    swval.forEach(function(valarr) {
                        var val = parseInt(valarr[0]);
                        var vname = valarr[1];
                        var newthing = [val,0,0,1,vname];
                        options["things"][swattr].push(newthing);
                    });
                    updated = true;
                    result = "success"; // options["things"][swattr];
                }
                break;
                
            default:
                result = "error";
                break;
        }

        if (updated) {
            writeOptions(options);
        }
    }
    
    return result;
}

function setPosition(swid, swtype, swval, swattr) {
    
    var updated = false;
    var options = GLB.options;
    var panel = swval["panel"];
    var tile = parseInt(swval["tile"]);
    
    // first find which index this tile is
    // note that this code will not work if a tile is duplicated on a page
    // such duplication is not allowed by the UI anyway but in the
    // event that a user edits hmoptions.cfg to have duplicates
    // the code will get confused here and in other places
    // $i = array_search($tile, $options["things"][$panel]);
    var moved = false;
    var idx;
    for ( var i in options["things"][panel]) {
        var arr = options["things"][panel][i];
        if ( is_array(arr) ) {
            idx = parseInt(arr[0]);
        } else {
            idx = parseInt(arr);
        }
        if ( tile === idx) {
            moved = i;
            updated = true;
            break;
        }
    }

    if ( updated && moved!==false ) {
        // change the room index to an array of tile, top, left
        // now we also save zindex and a tile custom name
        var top = parseInt(swattr["top"]);
        var left = parseInt(swattr["left"]);
        var zindex = parseInt(swval["zindex"]);
        var customname = "";
        if ( array_key_exists("custom", swval) ) {
            customname = swval["custom"];
        }
        var newtile = [tile, top, left, zindex, customname];
        options["things"][panel][moved] = newtile;
        writeOptions(options);
        var result = "success";
        if ( DEBUG7 ) {
            console.log( (ddbg()), "new tile position for tile: ", tile," to: (", top, ",", left, ",", zindex, ")");
        }
    } else {
        result = "error";
        console.log( (ddbg()), "error - position for tile: ", tile," was not found to change");
    }
    return result;
    
}

function addThing(bid, thingtype, panel, cnt) {
    
    var idx = thingtype + "|" + bid;
    var options = GLB.options;
    var tilenum = parseInt(options["index"][idx]);
    var thesensor = allthings[idx];
    var tilename = thesensor["name"];
    
    // get the count number from the t- field
    try {
        cnt = parseInt(cnt);
    } catch(e) {
        console.log( (ddbg()), "error - in addThing cnt value is invalid: ", cnt);
        return "error";
    }

    var lastid = options["things"][panel].length - 1;
    var lastitem = options["things"][panel][lastid];

    var ypos = parseInt(lastitem[1]);
    var xpos = parseInt(lastitem[2]);
    var zindex = 1;
    if ( lastitem.length > 3 ) {
        zindex = parseInt(lastitem[3]);
    }

    // protect against off screen values
    if ( xpos < -400 || xpos > 400 || ypos < -400 || ypos > 400 ) {
        xpos = 0;
        ypos = 0;
    }
    
    // add it to our system in the requested room/panel
    options["things"][panel].push([tilenum, ypos, xpos, zindex, tilename]);
    writeOptions(options);
    
    // make a new tile based on the dragged information
    var thing = makeThing(cnt, tilenum, thesensor, panel, ypos, xpos, zindex, "", "");
    
    return thing;
}

function delThing(bid, thingtype, panel, tile) {
    
    var idx = thingtype + "|" + bid;
    var retcode = "error";
    
    if ( panel && array_key_exists(panel, GLB.options["things"]) &&
                   array_key_exists(idx, GLB.options["index"]) ) {

        var optionthings = clone(GLB.options["things"][panel]);

        // as a double check the options file tile should match
        // if it doesn't then something weird triggered drag drop
        // note - if there are duplicates the first one will be deleted
        var tilenum = parseInt(GLB.options["index"][idx]);
        if ( parseInt(tile) === tilenum ) {

            // remove tile from this room
            for (var key in optionthings) {
                var thing = optionthings[key];
                if ( (is_array(thing) && parseInt(thing[0]) === tilenum) ||
                     (!is_array(thing) && parseInt(thing) === tilenum) ) {

                    delete optionthings[key];
                    retcode = "success";
                    break;
                }
            }   

            if ( retcode === "success" ) {
                // options.things[panel] = array_values(options["things"][panel]);
                GLB.options["things"][panel] = [];
                optionthings.forEach(function(orderthing) {
                    GLB.options["things"][panel].push(orderthing);
                })
                writeOptions(GLB.options);
            } else {
                console.log( (ddbg()), "error - could not safely delete tile: ", tile, " with id: ", bid, " from room: ", panel);
            }
        }
    }
    return retcode;
}

function delPage(pagename) {
    
    var options = GLB.options;
    var retcode;

    // check if room exists - ignore number matches
    if ( utils.count(options["rooms"]) <= 1 ) {
        retcode = "error - page= " + pagename + " is the only page remaining. Cannot delete the last page.";
    } else if ( array_key_exists(pagename, options["rooms"]) &&
                array_key_exists(pagename, options["things"]) ) {
        delete options["rooms"][pagename];
        delete options["things"][pagename];
        writeOptions(options);
        retcode = "success";
    } else {
        retcode = "error - cannot find page= " + pagename + " to delete.";
    }
    return retcode;
}

function addPage() {
    var pagenum = 0;
    var options = GLB.options;
    
    // get the largest room number
    for ( var roomname in options["rooms"] ) {
        var roomnum = parseInt(options["rooms"][roomname]);
        pagenum = roomnum > pagenum ? roomnum : pagenum;
    }
    pagenum++;

    // get new room default name in sequential order
    var newname = "Newroom1";
    var num = 1;
    while ( array_key_exists(newname, options["rooms"]) ) {
        $num++;
        $newname = "Newroom" + num.toString();
    }
    options["rooms"][newname] = pagenum;
    
    // put a digital clock in all new rooms so they are not empty
    var clockid = options["index"]["clock|clockdigital"];
    var clock = [clockid, 0, 0, 1, ""];
    options["things"][newname] = [clock];

    writeOptions(options);
    return newname;
}

function getInfoPage(returnURL, pathname) {

    var configoptions = GLB.options["config"];
    var skin = configoptions["skin"];
    var hubs = configoptions["hubs"];
    var specialtiles = utils.getSpecials();
    
    var $tc = "";
    var skin = getSkin();
    $tc += utils.getHeader(skin);
    $tc += "<h3>" + utils.APPNAME + " Information Display</h3>";

    $tc += "<form>";
    $tc += utils.hidden("returnURL", returnURL);
    $tc += utils.hidden("pathname", pathname);
    $tc += utils.hidden("pagename", "info");
    $tc += "</form>";
    $tc += "<div class=\"infopage\">";
    $tc += "<div class='bold'>Site url = " + returnURL + "</div>";
    $tc += "<div class='bold'>Skin folder = " + skin + "</div>";
    $tc += "<div class='bold'>" + hubs.length + " Hubs active</div>";
    $tc += "<hr />";
    
    var num = 0;
    hubs.forEach (function(hub) {
        // putStats(hub);
        var hubType = hub["hubType"];
        var hubName = hub["hubName"];
        var hubHost = hub["hubHost"];
        var hubId = hub["hubId"];
        var clientId = hub["clientId"];
        var clientSecret = hub["clientSecret"];
        var access_token = hub["hubAccess"];
        var endpt = hub["hubEndpt"];
        $tc += "<div class='bold'>Hub #" + num + "</div>";
        $tc += "<div class='bold'>Hub Name = " + hubName + "</div>";
        $tc += "<div>Type = " + hubType + "</div>";
        $tc += "<div>Hub ID = " + hubId + "</div>";
        $tc += "<div>Hub Host URL = " + hubHost + "</div>";
        $tc += "<div>Client ID = " + clientId + "</div>";
        $tc += "<div>Client Secret = " + clientSecret + "</div>";
        $tc += "<div>AccessToken = " + access_token + "</div>";
        $tc += "<div>Endpoint = " + endpt + "</div>";
        if ( (num + 1) < hubs.length ) {
            $tc += "<hr />";
        }
        num++;
    });

    $tc += "</div>";

    if ( clients.length > 0 ) {
        var str = "<p>Currently connected to " + clients.length + " clients.</p>";
        str = str + "<br><hr><br>";
        for (var i=0; i < clients.length; i++) {
            str = str + "Client #" + i + " host= " + clients[i].socket.remoteAddress + " <br>";
        }
        str = str + "<br><hr><br>";
        $tc +=  str;
    }
    

    $tc += "<button class=\"showhistory\">Show Dev Log</button>";
    $tc += "<div id=\"devhistory\" class=\"infopage hidden\">";
    $tc += "<pre>" + utils.DEV + "</pre>";
    $tc += "</div>";
    
    $tc += "<br><br><h3>List of Authorized Things</h3>";
    $tc += "<table class=\"showid\">";
    $tc += "<thead><tr><th class=\"thingname\">Name</th><th class=\"thingarr\">Value Array" + 
        "</th><th class=\"infotype\">Type" + 
        "</th><th class=\"infoid\">Thing id" +
        "</th><th class=\"hubid\">Hub" +
        "</th><th class=\"infonum\">Tile Num</th></tr></thead>";

    for (var bid in allthings) { // as $bid => $thing) {
        var thing = allthings[bid];
        var value = "";
        if ( is_object(thing["value"]) ) {
            for (var key in thing["value"] ) {
                var val = thing["value"][key];
                value += " ";
                if ( array_key_exists(key, specialtiles) ) {
                    value += key + "= <strong>embedded " + key + "</strong><br/>";
                } else if ( thing["type"]==="custom" && typeof val==="object" ) { 
                    value += "Custom Array..."; 
                } else if ( typeof val==="object" ) {
                    value += key + "=" + JSON.stringify(val);
                } else if ( typeof val === "string" && val.length > 128 ) {
                    val = val.substr(0,124) + " ...";
                    value += key + "=" + val + "<br/>";
                } else if ( typeof val==="string" ) {
                    value += key + "=" + val;
                } else {
                    value += key + "=" + val.toString();
                }
            }
        } else {
            value = thing["value"];
            if ( value.length > 128 ) {
                value = value.substr(0,124) + " ...";
            }
        }
        // limit size of the field shown
        
        var hubnum = thing["hubnum"];
        if ( hubnum === -1 || hubnum === "-1" ) {
            var hubstr = "None<br><span class=\"typeopt\"> (" + hubnum + ": None)</span>";
        } else {
            var hub = findHub(hubnum);
            var hubType = hub["hubType"];
            var hubName = hub["hubName"];
            var hubstr = hubName + "<br><span class=\"typeopt\"> (" + hubnum + ": " + hubType + ")</span>";
        }
        
        $tc += "<tr><td class=\"thingname\">" + thing["name"] +
            "</td><td class=\"thingarr\">" + value +
            "</td><td class=\"infotype\">" + thing["type"] +
            "</td><td class=\"infoid\">" + thing["id"] +
            "</td><td class=\"hubid\">" + hubstr + 
            "</td><td class=\"infonum\">" + GLB.options["index"][bid] + "</td></tr>";
    }
    $tc += "</table>";
    $tc += "<button class=\"infobutton fixbottom\">Return to HousePanel</button>";

    $tc += utils.getFooter();
    return $tc;
}

function hubFilters(hubpick, ncols) {
    var $options = GLB.options;
    var $useroptions = $options["useroptions"];
    var $configoptions = $options["config"];
    var $hubs = $configoptions["hubs"];
    var $thingtypes = utils.getTypes();

    var retpage = GLB.returnURL;
    var $tc = "";
    $tc+= "<form id=\"filteroptions\" class=\"options\" name=\"filteroptions\" action=\"" + retpage + "\"  method=\"POST\">";
    
    // if more than one hub then let user pick which one to show
    var hubpick = "all";
    if ( $configoptions["hubpick"] ) {
        hubpick = $configoptions["hubpick"];
    }
    if ( utils.count($hubs) > 1 ) {
        $tc+= "<div class=\"filteroption\">Hub Filters: ";
        var $hid = "hopt_all";
        var checked = (hubpick==="all") ? " checked='1'" : "";
        $tc+= "<div class='radiobutton'><input id='" + $hid + "' type='radio' name='huboptpick' value='all'"  + checked + "><label for='" + $hid + "'>All Hubs</label></div>";
        $hid = "hopt_none";
        checked = (hubpick==="none") ? " checked='1'" : "";
        $tc+= "<div class='radiobutton'><input id='" + $hid + "' type='radio' name='huboptpick' value='none'" + checked + "><label for='" + $hid + "'>No Hub</label></div>";
        var $hubcount = 0;
        $hubs.forEach(function($hub) {
            var $hubName = $hub["hubName"];
            var $hubType = $hub["hubType"];
            var $hubId = $hub["hubId"];
            $hid = "hopt_" + $hubcount;
            checked = (hubpick===$hubId) ? " checked='1'" : "";
            $tc+= "<div class='radiobutton'><input id='" + $hid + "' type='radio' name='huboptpick' value='" + $hubId + "'" + checked + "><label for='" + $hid + "'>" + $hubName + " (" + $hubType + ")</label></div>";
            $hubcount++;
        });
        $tc+= "</div>";
    }

    // buttons for all or no filters
    $tc+= "<br /><div class=\"filteroption\">Thing Filters: ";
    $tc+= "<div id=\"allid\" class=\"smallbutton\">All</div>";
    $tc+= "<div id=\"noneid\" class=\"smallbutton\">None</div>";
    $tc+= "</div>";

    $tc+= "<div class='filteroption'>Select Things to Display: <br/>";
    $tc+= "<table class=\"useroptions\"><tr>";
    var $i= 0;
    for (var $iopt in $thingtypes) {
        var $opt = $thingtypes[$iopt];
        $i++;
        if ( in_array($opt, $useroptions ) ) {
            $tc+= "<td><input id=\"cbx_" + $i + "\" type=\"checkbox\" name=\"useroptions[]\" value=\"" + $opt + "\" checked=\"1\">";
        } else {
            $tc+= "<td><input id=\"cbx_" + $i + "\" type=\"checkbox\" name=\"useroptions[]\" value=\"" + $opt + "\">";
        }
        $tc+= "<label for=\"cbx_" + $i + "\" class=\"optname\">" + $opt + "</label></td>";
        if ( $i % ncols == 0 && $i < utils.count($thingtypes) ) {
            $tc+= "</tr><tr>";
        }
    }
    $tc+= "</tr></table>";
    $tc+= "</div><hr>";
    $tc+= "</form>";

    return $tc;
}

function getCatalog(hubpick) {

    var $tc = "";
    var useroptions = GLB.options["useroptions"];
    $tc += "<div id=\"catalog\">";
    $tc += hubFilters(hubpick, 2);
    var i= 0;

    for(var idx in allthings) {
        var thesensor = allthings[idx];
        var bid = thesensor["id"];
        var thingtype = thesensor["type"];
        var thingname = thesensor["name"];
        var hubId = thesensor["hubnum"].toString();
        var cat = "cat-" + i.toString();
        if ( hubId==="-1" ) {
            hubId = "none";
        }

        if ( thingname.length > 23 ) {
            var thingpr = thingname.substr(0,23) + " ...";
        } else {
            thingpr = thingname;
        }
        
        if (in_array(thingtype, useroptions) && (hubpick===hubId || hubpick==="all")) {
            var hide = "";
        } else {
            hide = "hidden ";
        }

        $tc += "<div id=\"" + cat + "\" bid=\"" + bid + "\" type=\"" + thingtype + "\" hubid=\"" + hubId + "\" ";
        $tc += "panel=\"catalog\" class=\"thing " + hide + "catalog-thing\">"; 
        $tc += "<div class=\"thingname\">" + thingpr + "</div>";
        $tc += "<div class=\"thingtype\">" + thingtype + "</div>";
        $tc +="</div>";
        i++;
    }
    $tc += "</div>";
    return $tc;
}

// this used to create input blocks for auth page
// it was modified for use now on the options page
function tsk($timezone, $skin, $uname, $port, $webSocketServerPort, $fast_timer, $slow_timer) {

    var $tc= "";
    $tc += "<form id=\"userpw\" class=\"options\" name=\"userpw\" action=\"" + GLB.returnURL + "\"  method=\"POST\">";

    $tc += "<div class=\"filteroption\">";
    $tc += "<div class='inp'><label class=\"startupinp\">Skin Folder: </label>";
    $tc += "<input id=\"skinid\" class=\"startupinp\" name=\"skin\" width=\"80\" type=\"text\" value=\"" + $skin + "\"/></div>"; 
    
    $tc += "<div><label class=\"startupinp\">Timezone: </label>";
    $tc += "<input id=\"newtimezone\" class=\"startupinp\" name=\"timezone\" width=\"80\" type=\"text\" value=\"" + $timezone + "\"/></div>"; 

    $tc += "<div><label class=\"startupinp\">Main App Port: </label>";
    $tc += "<input id=\"newport\" class=\"startupinp\" name=\"port\" width=\"20\" type=\"text\" value=\"" + $port + "\"/></div>"; 

    $tc += "<div><label class=\"startupinp\">WebSocket Port: </label>";
    $tc += "<input id=\"newsocketport\" class=\"startupinp\" name=\"webSocketServerPort\" width=\"20\" type=\"text\" value=\"" + $webSocketServerPort + "\"/></div>"; 

    // $tc += "<div><label class=\"startupinp\">Fast Timer: </label>";
    // $tc += "<input id=\"newfast_timer\" class=\"startupinp\" name=\"fast_timer\" width=\"20\" type=\"text\" value=\"" + $fast_timer + "\"/></div>"; 

    // $tc += "<div><label class=\"startupinp\">Slow Timer: </label>";
    // $tc += "<input id=\"newslow_timer\" class=\"startupinp\" name=\"slow_timer\" width=\"20\" type=\"text\" value=\"" + $slow_timer + "\"/></div>"; 

    $tc += "<div><label for=\"uname\" class=\"startupinp\">Username: </label>";
    $tc += "<input id=\"uname\" class=\"startupinp\" name=\"uname\" width=\"20\" type=\"text\" value=\"" + $uname + "\"/></div>"; 

    $tc += "<div><label for=\"pword\" class=\"startupinp\">Set New Password: </label>";
    $tc += "<input id=\"pword\" class=\"startupinp\" name=\"pword\" width=\"80\" type=\"password\" value=\"\"/></div>"; 
    
    $tc += "<div><label></label><span class='indent typeopt'>(blank to keep prior)</span></div>";
    $tc += "<div></div><br />";
    $tc += "</div>";
    $tc += "</form>";

    return $tc;
    
}

function getOptionsPage(pathname) {
    var retpage = GLB.returnURL;
    var $thingtypes = utils.getTypes();
    var $specialtiles = utils.getSpecials();

    var $options = GLB.options;
    var $roomoptions = $options["rooms"];
    var $thingoptions = $options["things"];
    var $indexoptions = $options["index"];
    var $useroptions = $options["useroptions"];
    var $configoptions = $options["config"];
    var skin = getSkin();
    var $port = $configoptions["port"];
    var $webSocketServerPort = $configoptions["webSocketServerPort"];
    var $fast_timer = $configoptions["fast_timer"];
    var $slow_timer = $configoptions["slow_timer"];
    var $kioskoptions = $configoptions["kiosk"];
    var $ruleoptions = $configoptions["rules"];
    var $timezone = $configoptions["timezone"];
    var $uname = getUserName();

    var hubpick = "all";
    if ( $configoptions["hubpick"] ) {
        hubpick = $configoptions["hubpick"];
    }
    
    var $tc = "";
    $tc += utils.getHeader(skin);
    $tc += "<h3>" + utils.APPNAME + " Options</h3>";
    $tc += "<div class=\"formbutton formauto\"><a href=\"" + retpage + "\">Cancel and Return to HousePanel</a></div>";
    
    // $tc += "<div id=\"optionstable\" class=\"optionstable\">";

    $tc += utils.hidden("returnURL", retpage);
    $tc += utils.hidden("pathname", pathname);
    $tc += utils.hidden("pagename", "options");

    $tc += hubFilters(hubpick, 7);
    $tc += tsk($timezone, skin, $uname, $port, $webSocketServerPort, $fast_timer, $slow_timer);

    $tc += "<form id=\"optionspage\" class=\"options\" name=\"options\" action=\"" + retpage + "\"  method=\"POST\">";

    $tc += "<div class=\"filteroption\">";
    $tc += "Specify number of special tiles: ";
    for (var $stype in $specialtiles) {
        var sid = $specialtiles[$stype];
        var $customcnt = getCustomCount($stype, sid[3]);
        var $stypeid = "cnt_" + $stype;
        $tc+= "<br /><label for=\"$stypeid\" class=\"kioskoption\"> " + $stype +  " tiles: </label>";
        $tc+= "<input class=\"specialtile\" id=\"" + $stypeid + "\" name=\"" + $stypeid + "\" width=\"10\" type=\"number\"  min='0' max='99' step='1' value=\"" + $customcnt + "\" />";
    }
    $tc+= "</div>";

    $tc += "<div class=\"filteroption\">";
    $tc += "Other options: <br/>";
    $tc += "<label for=\"kioskid\" class=\"kioskoption\">Kiosk Mode: </label>";    
    var $kstr = ($kioskoptions===true || $kioskoptions==="true" || $kioskoptions==="1" || $kioskoptions==="yes") ? "checked" : "";
    $tc+= "<input id=\"kioskid\" width=\"24\" type=\"checkbox\" name=\"kiosk\"  value=\"" + $kioskoptions + "\" " + $kstr + "/>";
    $tc += "<label for=\"ruleid\" class=\"kioskoption\">Enable Rules? </label>";
    var $rstr = ($ruleoptions===true || $ruleoptions==="true" || $ruleoptions==="1" || $ruleoptions==="yes") ? "checked" : "";
    $tc += "<input id=\"ruleid\" width=\"24\" type=\"checkbox\" name=\"rules\"  value=\"" + $ruleoptions + "\" " + $rstr + "/>";
    $tc += "</div>";

    var $accucity = $configoptions["accucity"];
    var $accuregion = $configoptions["accuregion"];
    var $accucode = $configoptions["accucode"];      // ann-arbor-mi code is 329380
    $tc += "<div class=\"filteroption\">";
    $tc += "<label for=\"accucityid\" class=\"kioskoption\">Accuweather City: <input id=\"accucityid\" width=\"180\" ";
    $tc += "type=\"text\" name=\"accucity\"  value=\"" + $accucity + "\" />";
    $tc += "<label for=\"accuregionid\" class=\"kioskoption\">Region: <input id=\"accuregionid\" width=\"6\" type=\"text\" name=\"accuregion\"  value=\"" + $accuregion + "\"/>";
    $tc += "<label for=\"accucodeid\" class=\"kioskoption\">Code: <input id=\"accucodeid\" width=\"40\" type=\"text\" name=\"accucode\"  value=\"" + $accucode + "\"/>";
    $tc += "</div>";
    
    // now display the table of all the rooms and thing options
    $tc += "<br /><br />";
    $tc += "<table class=\"headoptions\"><thead>";
    $tc += "<tr><th class=\"thingname\">Thing Name (type)</th>";
    $tc += "<th class=\"hubname\">Hub</th>";
   
    // list the room names in the proper order
    // for ($k=0; $k < count($roomoptions); $k++) {
    for (var $roomname in $roomoptions) {
        $tc+= "<th class=\"roomname\">" + $roomname;
        $tc+= "</th>";
    }
    $tc += "</tr></thead>";
    $tc += "</table>";
    $tc += "<div class='scrollvtable'>";
    $tc += "<table class=\"roomoptions\">";
    $tc += "<tbody>";

    // sort the things
    // uasort(allthings, "mysortfunc");
    
    // now print our options matrix
    // $rowcnt = 0;
    var $evenodd = true;
    var $hub;
    for (var $thingid in allthings) {
        var $thesensor = allthings[$thingid];
        // if this sensor type and id mix is gone, skip this row
        
        var $thingname = $thesensor["name"];
        var $thetype = $thesensor["type"];
        var $hubnum = $thesensor["hubnum"];
        if ( $hubnum === -1 || $hubnum==="-1" ) {
            $hub = null;
            var $hubType = "None";
            var $hubStr = "None";
            var $hubId = "none";
        } else {
            $hub = findHub($hubnum);
            $hubType = $hub["hubType"];
            $hubStr = $hub["hubName"];
            $hubId = $hub["hubId"];
        }

        // get the tile index number
        var $thingindex = $indexoptions[$thingid].toString();
        
        // write the table row
        if ( array_key_exists($thetype, $specialtiles) ) {
            var $special = " special";
        } else {
            $special = "";
        }
        var $odd = $evenodd = false;
        if (in_array($thetype, $useroptions)) {
            $evenodd = !$evenodd;
            $evenodd ? $odd = " odd" : $odd = "";
            $tc+= "<tr type=\"" + $thetype + "\" tile=\"" + $thingindex + "\" class=\"showrow" + $odd + $special + "\">";
        } else {
            $tc+= "<tr type=\"" + $thetype + "\" tile=\"" + $thingindex + "\" class=\"hiderow" + $special + "\">";
        }
        
        $tc+= "<td class=\"thingname\">";
        $tc+= $thingname + "<span class=\"typeopt\"> (" + $thetype + ")</span>";
        $tc+= "</td>";
        
        $tc+= "<td class=\"hubname\" hubId=\"" + $hubId + "\">";
        $tc+= $hubStr + " (" + $hubType + ")";
        $tc+= "</td>";

        // loop through all the rooms
        // this addresses room bug
        for ( var $roomname in $roomoptions ) {
            
            // get the name of this room for this column
            // $roomname = array_search($k, $roomoptions);
            // $roomlist = array_keys($roomoptions, $k);
            // $roomname = $roomlist[0];
            if ( array_key_exists($roomname, $thingoptions) ) {
                var $things = $thingoptions[$roomname];
                                
                // now check for whether this thing is in this room
                $tc+= "<td>";
                
                var $ischecked = false;
                var $idx;
                for (var i in $things) {
                    var $arr = $things[i];
                    if ( is_array($arr) ) {
                        $idx = $arr[0].toString();
                    } else {
                        $idx = $arr.toString();
                    }
                    if ( $idx === $thingindex ) {
                        $ischecked = true;
                        break;
                    }
                }
                
                if ( $ischecked ) {
                    $tc+= "<input type=\"checkbox\" name=\"" + $roomname + "[]\" value=\"" + $thingindex + "\" checked=\"1\" >";
                } else {
                    $tc+= "<input type=\"checkbox\" name=\"" + $roomname + "[]\" value=\"" + $thingindex + "\" >";
                }
                $tc+= "</td>";
            }
        }
        $tc+= "</tr>";
    }

    $tc+= "</tbody></table>";
    $tc+= "</div>";
    $tc+= "<div id='optionspanel' class=\"processoptions\">";
    $tc +='<div id="optSave" class="formbutton">Save</div>';
    $tc +='<div id="optReset" class="formbutton">Reset</div>';
    $tc +='<div id="optCancel" class="formbutton">Cancel</div><br>';
    $tc+= "</div>";
    $tc+= "</form>";
    
    // $tc+= "</div>";

    $tc += utils.getFooter();

    return $tc;
}

// renders the main page
function mainPage(proto, hostname, pathname) {
    var $tc = "";

    var thingoptions = GLB.options["things"];
    var roomoptions = GLB.options["rooms"];
    var config = GLB.options.config;
    var skin = getSkin();
    var kioskmode = GLB.options.config["kiosk"];
    if ( kioskmode === "true" || kioskmode===1 || kioskmode==="yes" ) {
        kioskmode = true;
    } else {
        kioskmode = false;
    }
    GLB.returnURL = proto + "://" + hostname
    console.log( (ddbg()), "Displaying main HousePanel web page: ", GLB.returnURL);

    $tc += utils.getHeader(skin);

    if ( GLB.newuser ) {
        $tc += "<div class=\"greeting\"><strong>Welcome New User!</strong><br/ >You should first try to link your smart home hubs, using the Hub Auth button below. ";
        $tc += "You can also explore all that HousePanel has to offer by experimenting with the two clock tiles placed in each room. ";
        $tc += "When you are done, they can be removed in Edit mode or from the Options page. Click on the ? mark in the upper right corner. ";
        $tc += "to access the full online manual. Have fun!</div>";
        GLB.newuser = false;
    }

    if ( DEBUG3 ) {
        console.log( (ddbg()), GLB.options);
    }
    // make sure our active skin has a custom file
    if ( !fs.existsSync(skin + "/customtiles.css") ) {
        writeCustomCss(1, skin, "");
    }
    
    // new wrapper around catalog and things but excluding buttons
    $tc += '<div id="dragregion">';
    $tc += '<div id="tabs"><ul id="roomtabs">';

    // show all room with whatever index number assuming unique
    for (var room in roomoptions) {
        var k = roomoptions[room];
        if ( thingoptions[room] ) {
            var adder= "<li roomnum=\"" + k + "\" class=\"tab-" + room + "\"><a href=\"#" + room + "-tab\">" + room + "</a></li>";
            $tc += adder;
        }
    }
    $tc += '</ul>';

    // changed this to show rooms in the order listed
    // this is so we just need to rewrite order to make sortable permanent
    var cnt = 0;
    for (var room in roomoptions) {
        var k = roomoptions[room];
        if ( thingoptions[room] ) {
            var things = thingoptions[room];
            var pgobj = getNewPage(cnt, room, k, things);
            $tc += pgobj.tc;
            cnt = pgobj.cnt;
        }
    }

    // include doc button and username that is logged in
    var uname = getUserName();
    $tc += '<div id="showversion" class="showversion">';
    $tc += '<span id="infoname">' + uname + "</span><span> - V" + utils.HPVERSION + '</span>';
    $tc += '<div id="showdocs"><a href="http://www.housepanel.net" target="_blank">?</a></div>';
    $tc += "</div>";

    // end of the tabs
    $tc += "</div>";

    // set the websock servername as same as hosted page but different port
    var webSocketUrl = "";
    if ( config.webSocketServerPort && !isNaN(parseInt(config.webSocketServerPort)) ) {
        var icolon = hostname.indexOf(":");
        if ( icolon >= 0 ) {
            webSocketUrl = "ws://" + hostname.substr(0, icolon);
        } else {
            webSocketUrl = "ws://" + hostname;
        }
        webSocketUrl = webSocketUrl + ":" + config.webSocketServerPort;
    }
    
    // include form with useful data for js operation
    $tc += "<form id='kioskform'>";
    $tc += utils.hidden("pagename", "main");

    // save the socket address for use on js side
    // var webSocketUrl = config.webSocketServerPort ? ("ws://" + serverName + ":" + config.webSocketServerPort) : "";
    $tc += utils.hidden("webSocketUrl", webSocketUrl);

    // save Node.js address for use on the js side
    $tc += utils.hidden("returnURL", GLB.returnURL);
    $tc += utils.hidden("pathname", pathname);
    $tc += utils.hidden("skinid", skin, "skinid");

    // show user buttons if we are not in kiosk mode
    if ( !kioskmode ) {
        $tc += "<div id=\"controlpanel\">";
        $tc +='<div id="showoptions" class="formbutton">Options</div>';
        $tc +='<div id="refresh" class="formbutton">Refresh</div>';
        // $tc +='<div id="refactor" class="formbutton confirm">Refactor</div>';
        $tc +='<div id="reauth" class="formbutton confirm">Hub Auth</div>';
        $tc +='<div id="showid" class="formbutton">Show Info</div>';
        $tc +='<div id="toggletabs" class="formbutton">Hide Tabs</div>';
        $tc +='<div id="blackout" class="formbutton">Blackout</div>';

        $tc += "<div class=\"modeoptions\" id=\"modeoptions\"> \
          <input id=\"mode_Operate\" class=\"radioopts\" type=\"radio\" name=\"usemode\" value=\"operate\" checked><label for=\"mode_Operate\" class=\"radioopts\">Operate</label> \
          <input id=\"mode_Reorder\" class=\"radioopts\" type=\"radio\" name=\"usemode\" value=\"reorder\" ><label for=\"mode_Reorder\" class=\"radioopts\">Reorder</label> \
          <input id=\"mode_Edit\" class=\"radioopts\" type=\"radio\" name=\"usemode\" value=\"edit\" ><label for=\"mode_Edit\" class=\"radioopts\">Edit</label> \
          <input id=\"mode_Snap\" class=\"radioopts\" type=\"checkbox\" name=\"snapmode\" value=\"snap\"><label for=\"mode_Snap\" class=\"radioopts\">Grid Snap?</label> \
        </div><div id=\"opmode\"></div>";
        $tc +="</div>";
    }
    $tc += "</form>";

    // end drag region enclosing catalog and main things
    $tc += "</div>";

    $tc += utils.getFooter();
        
    return $tc;
}

function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
}


function saveFilters(body) {
    if ( DEBUG3 ) {
        console.log( (ddbg()), "filters save request: ", body);
    }
    var rewrite = false;
    var result = {};

    if ( body.useroptions ) {
        GLB.options["useroptions"] = body.useroptions;
        result.useroptions = body.useroptions;
        rewrite = true;
    }

    if ( typeof body.huboptpick !== "undefined" ) {
        GLB.options["config"]["hubpick"] = body.huboptpick;
        result.huboptpick = body.huboptpick;
        rewrite = true;
    }

    if ( rewrite ) {
        writeOptions(GLB.options, true);
    }
    return result;
}

function saveUserPw(body) {
    if ( DEBUG3 ) {
        console.log( (ddbg()), "password save request: ", body);
    }

    // get current options;
    // readOptions();

    // get the username and passwords
    var olduname = getUserName();
    var uname = olduname;
    var oldhash = "";
    var hash = "";
    var defskin;
    if ( GLB.options.config["skin"] ) {
        defskin = GLB.options.config["skin"];
    } else {
        defskin = "skin-housepanel";
        GLB.options.config["skin"] = defskin;
    }
    
    // get default pw and its skin
    // or set up default if isn't configured
    if (array_key_exists("pword", GLB.options.config)) {
        if ( array_key_exists(uname, GLB.options.config["pword"]) ) {
            var pwords = GLB.options.config["pword"];
            oldhash = pwords[uname][0];
            defskin = pwords[uname][1];
            GLB.options.config["skin"] = defskin;
        }
    } else {
        GLB.options.config["pword"] = {};
        GLB.options.config["pword"][uname] = [oldhash, defskin];
    }

    var skin = defskin;
    var result = {};

    for (var key in body) {
        var val = body[key];

        //skip the returns from the submit button and the flag
        if (key==="skin") {
            skin = val;
        } else if ( key==="timezone" ) {
            GLB.options.config["timezone"] = val;
        } else if ( key==="port" ) {
            var port = parseInt(val);
            if ( !isNaN(port) ) {
                GLB.options.config["port"] = port;
                var loc = GLB.returnURL.indexOf(":", 7);
                result.port = port;
                result.returnURL = GLB.returnURL.substr(0, loc) + ":" + port.toString();
            }
        } else if ( key==="webSocketServerPort" ) {
            var wsport = parseInt(val);
            if ( !isNaN(wsport) ) {
                GLB.options.config["webSocketServerPort"] = wsport;
            }
        } else if ( key==="fast_timer" ) {
            GLB.options.config["fast_timer"] = parseInt(val);
        } else if ( key==="slow_timer" ) {
            GLB.options.config["slow_timer"] = parseInt(val);
        } else if ( key==="uname" ) {
            uname = val.trim();
            if ( uname==="" ) {
                uname = olduname;
            }
            result.uname = uname;
        } else if ( key==="pword" ) {
            val = val.trim();
            if ( val!=="" ) {
                hash = pw_hash(val);
            } else {
                hash = "";
            }
        }
    }

    // now that we have all the new facts, set up password field
    // process username and password settings and save in skin specific loc
    // includes logic to bundle the skin with this user so that
    // now each user can use their own skin if they want

    // if password field is blank and user name is the same, keep old password
    if ( olduname===uname && hash==="" ) {
        hash = oldhash;
    }
    GLB.options.config["uname"] = uname;

    // 
    // set the skin and replace the custom file with that skin's version
    // but first check to make sure it is a valid name
    if ( !fs.existsSync(skin + "/housepanel.css") ) {
        skin = defskin;
        if ( !fs.existsSync(skin + "/housepanel.css") ) {
            skin = "skin-housepanel";
        }
    }

    // make sure our default skin has a custom file
    if ( !fs.existsSync(skin + "/customtiles.css") ) {
        writeCustomCss(1, skin, "");
    }
    // set default skin to this skin - although it shouldn't be used ever
    GLB.options["config"]["skin"] = skin;


    // save the skin in my user specific setting
    GLB.options.config["pword"][uname] = [hash, skin];
    GLB.options.config["skin"] = skin;

    GLB.pwcrypt = hash;

    // set some return values
    result.hash = hash;
    result.skin = skin;
    console.log( (ddbg()), "saveuserpw processed: ", result, " uname: ", uname, " oldpw: ", oldhash, " newpw: ", hash);

    // write options to file
    writeOptions( GLB.options, true);

    return result;
}

// process user options page
function processOptions($optarray) {

    if (DEBUG4) {
        console.log( (ddbg()), "Process Options - Before Processing");
        console.log( (ddbg()), UTIL.inspect(GLB.options, false, null, false));
    }
    var $specialtiles = utils.getSpecials();
    var $options = clone(GLB.options);;

    // start with a blank slate
    $options["things"] = {};
    for( var $room in GLB.options["rooms"]) {
        $options["things"][$room] = [];  // clone(GLB.options["things"][$roomname]);
    }

    // var $oldoptions = clone(GLB.options);
    var $configoptions = $options["config"];
    var $roomnames = Object.keys($options["rooms"]);
    if ( !is_object($configoptions["specialtiles"]) ) {
        $configoptions["specialtiles"] = {};
    }

    // // use clock instead of blank for default only tile
    var $onlytile = GLB.options["index"]["clock|clockdigital"];
    var onlyarr = [$onlytile,0,0,1,""];

    // // checkbox items simply will not be there if not selected
    $configoptions["kiosk"] = "false";
    $configoptions["rules"] = "false";

    // force all three to be given for change to happen
    var $city = "";
    var $region = "";
    var $code = "";

    // // get all the rooms checkboxes and reconstruct list of active things
    // // note that the list of checkboxes can come in any random order
    for (var key in $optarray) {
        var $val = $optarray[key];

        //skip the returns from the submit button and the flag
        if (key==="options" || key==="api" || key==="useajax" ) {
            continue;
        } else if ( key==="kiosk") {
            $configoptions["kiosk"] = "true";
        } else if ( key==="rules") {
            $configoptions["rules"] = "true";
        } else if ( key==="accucity" ) {
            $city = $val.trim();
        } else if ( key==="accuregion" ) {
            $region = $val.trim();
        } else if ( key==="accucode" ) {
            $code = $val.trim();
        
        // handle user selected special tile count
        } else if ( key.substr(0,4)==="cnt_" ) {
            var $stype = key.substr(4);
            if ( array_key_exists($stype, $specialtiles) ) {
                var $spid = $specialtiles[$stype][0];
                var $customcnt = parseInt($val);
                createSpecialIndex($customcnt, $stype, $spid);
                $configoptions["specialtiles"] = clone(GLB.options["config"]["specialtiles"]);
                
            }
        
        // made this more robust by checking room name being valid
        } else if ( in_array(key, $roomnames) && is_array($val) ) {
            var $roomname = key;
            
            // first save the existing order of tiles if still there
            // this will preserve user drag and drop positions
            // but if a tile is removed then all tiles after it will be
            // shown shifted as a result
            var $lasttop = 0;
            var $lastleft = 0;
            var $lastz = 1;

            // first put all existing tiles in the room
            // this retains the existing order
            GLB.options["things"][$roomname].forEach(function(newtile) {
                var tnum = parseInt(newtile[0]);
                var rnum = array_search(tnum, $val);
                if ( rnum!==false ) {
                    $options["things"][$roomname].push(newtile);
                }
            });

            // get the index offset of last existing tile
            if ( $options["things"][$roomname].length > 0 ) {
                var lastitem = $options["things"][$roomname].length -1;
                var arr = $options["things"][$roomname][lastitem];
                $lasttop = arr[1];
                $lastleft = arr[2];
                $lastz = arr[3];

                // set position to next to last one unless it is moved a lot
                // the 400 distance is subjective but works in most cases
                if ( $lasttop < -400 || $lasttop > 400 || $lastleft < -400 || $lastleft > 400 ) {
                    $lasttop = 0;
                    $lastleft = 0; 
                }
            }

            // add any new ones that were not there before
            $val.forEach(function($tilestr) {
                var $tilenum = parseInt($tilestr);
                if ( inroom($tilenum, GLB.options["things"][$roomname]) === false ) {
                    var newtile = [$tilenum,$lasttop,$lastleft, $lastz, ""];
                    $options["things"][$roomname].push(newtile);
                }
            });

            var rmnum = $options["rooms"][$roomname];
            if ( (DEBUG4 && rmnum===0) || DEBUG9 ) {
                console.log( (ddbg()),"Roomname: ", $roomname, " Room num: ", rmnum, " After: ", $options["things"][$roomname]);
            }
            
            // put a clock in a room if it is empty
            if ( $options["things"][$roomname].length === 0  ) {
                $options["things"][$roomname].push(onlyarr);
            }
        }
    }
    
    // everything from this point on is after processing the options table
    // start by handling the weather
    if ( $city && $region && $code ) {
        $configoptions["accucity"] = $city;
        $configoptions["accuregion"] = $region;
        $configoptions["accucode"] = $code;
        getAccuWeather($city, $region, $code);
    }
    
    // save the configuration parameters in the main options array
    $options["config"] = $configoptions;
    
    if (DEBUG4) {
        console.log( (ddbg()), "Process Options - After Processing");
        console.log( (ddbg()), UTIL.inspect(GLB.options, false, null, false));
    }

    // write options to file
    writeOptions($options);
}

function changePageName($oldname, $pagename) {
 
    var retcode = "success";
    var options = GLB.options;
    if ( $oldname && $pagename && array_key_exists($oldname, options["rooms"]) ) {
        options["rooms"][$pagename] = options["rooms"][$oldname];
        options["things"][$pagename] = clone(options["things"][$oldname]);
        delete options["rooms"][$oldname];
        delete options["things"][$oldname];
        writeOptions(options);
    } else {
        console.log( (ddbg()), "old page name not valid: ", $oldname);
        retcode = "error - old page name not valid: " + $oldname;
    }
    return retcode;
}

function updateNames(type, tileid, oldname, newname) {
    var result;
    if ( type === "page" ) {
        var newname = newname.replace(/ /g, "_");
        result = changePageName(oldname, newname);
    } else {
        var options = GLB.options;
        var updcss = false;
        var nupd = 0;
        tileid = parseInt(tileid);
        oldname = newname;
        for (var room in options["things"]) {
            var things = options["things"][room];
        
            // look for matching options item
            // and update to new value if it changed
            // also guard against old style that wasn't an array
            // or arrays that were not at least 4 elements long
            // the 4th element of the array is the custom name
            things.forEach(function(tiles, k) {
                if ( is_array(tiles) && tiles.length>3 &&
                     (parseInt(tiles[0]) === tileid) && tiles[4]!==newname  ) {
                    oldname = tiles[4];
                    tiles[4] = newname;
                    options["things"][room][k] = tiles;
                    nupd++;
                    updcss = true;
                }

            });
        }
        if ( updcss ) {
            writeOptions(options);
            result = "success " + nupd.toString() + " names changed for type= " + type + " oldname= " + oldname + " newname= " + newname;
        } else {
            result = "success but nothing updated for type= " + type + " oldname= " + oldname + " newname= " + newname;
        }
    }
    return result;
}

function getIcons(icondir, category) {
    var skin = getSkin();

    // change over to where our icons are located
    var activedir = path.join(__dirname, skin, icondir);

    // TODO - get function to return a directory listing
    // $dirlist = scandir($activedir);
    var dirlist = fs.readdirSync(activedir);
    var allowed = ["png","jpg","jpeg","gif"];
    var $tc = "";

    dirlist.forEach( function(filename) {
        var froot = path.basename(filename);
        var ext = path.extname(filename).slice(1);
        var filedir = path.join(skin, icondir, froot);

        if ( in_array(ext, allowed) ) {
            $tc += '<div class="cat ' + category + '">';
            $tc += '<img src="' + filedir +'" class="icon" title="' + froot + '" />';
            $tc += '</div>';
        }
    });
    return $tc;
}

function pw_hash(pword) {

    var hash;
    if ( typeof pword !== "string"  || !pword || !pword.trim() ) {
        hash = "";
    } else {
        pword = pword.trim();
        var thehash = crypto.createHash("sha256");
        thehash.update(pword);
        hash = thehash.digest('hex');
    }
    return hash;
}

function pw_verify(pword, hash) {
    return (pw_hash(pword) === hash);
}

function addCustom(swid, swtype, swval, swattr, subid) {
    var reserved = ["index","rooms","things","config","control","time","useroptions"];
    var options = GLB.options;
    var userid = "user_" + swid;

    // legacy custom types
    if ( array_key_exists(swid, options) && 
            !in_array (swid, reserved) && 
            !array_key_exists(userid, options) ) {
        userid = swid;
    }

    var oldcustoms;
    if ( array_key_exists(userid, options) ) {
        oldcustoms = clone(options[userid]);
    } else {
        oldcustoms = [];
    }

    // handle encryption
    swattr = swattr.toString();
    subid = subid.toString();
    if ( subid==="password" ) {
        swattr = pw_hash(swattr);
    }
    
    var newitem = [swval, swattr, subid];
    var newoptitem = [];
    var doneit = false;

    oldcustoms.forEach( function(val) {
        if ( val[2].toString() === subid ) {
            if ( !doneit ) {
                newoptitem.push(newitem);
                doneit = true;
            }
        } else {
            newoptitem.push(val);
        }
    });

    if ( !doneit ) {
        newoptitem.push(newitem);
    }

    options[userid] = newoptitem;
    writeOptions(options);
    var idx = swtype + "|" + swid;
    
    // make the new custom field using the updated options above
    var thingval = getCustomTile(allthings[idx]["value"], swtype, swid);

    // save it in the main array - no need for sessions in Node
    allthings[idx]["value"] = thingval;

    return thingval;
}

function delCustom(swid, swtype, swval, swattr, subid) {
    var reserved = ["index","rooms","things","config","control","useroptions"];
    var userid = "user_" + swid;

    swattr = swattr.toString();
    subid = subid.toString();

    // legacy custom types
    if ( array_key_exists(swid, GLB.options) && 
            !in_array (swid, reserved) && 
            !array_key_exists(userid, GLB.options) ) {
        userid = swid;
    }

    if ( array_key_exists(userid, GLB.options) ) {

        var oldlines = clone(GLB.options[userid]);
        if ( ! is_array(oldlines[0]) ) {
            oldlines = [oldlines];
        }

        // make new list of customs without the deleted item
        var lines = [];
        oldlines.forEach( function(newitem) {
            if ( newitem[2].toString() !== subid ) {
                lines.push(newitem);
            }
        });

        // either remove or update the main options array
        if ( lines.length === 0 ) {
            delete GLB.options[userid];
        } else {
            GLB.options[userid] = lines;
        }

        writeOptions(GLB.options);
    }
    
    var idx = swtype + "|" + swid;
    var companion = "user_" + subid;
    var thingval = allthings[idx]["value"];
    
    // remove this field and any companion if it exists
    delete thingval[subid];
    if ( array_key_exists(companion, thingval) ) {
        delete thingval[companion];
    }
    allthings[idx]["value"] = thingval;

    // make the new custom field using the updated options above
    thingval = getCustomTile(thingval, swtype, swid);
   
    // save it in the main array - no need for sessions in Node
    allthings[idx]["value"] = thingval;
    return thingval;
}

function apiCall(body, protocol) {
    var config = GLB.options.config;
    var hubs = GLB.options.config["hubs"];

    if ( body['useajax'] ) {
        var api = body['useajax'];
    } else {
        api = body['api'] || "";
    }
    var swid = body["id"] || "none";
    var swtype = body["type"] || "none";
    var swval = body["value"] || "";
    var swattr = body["attr"] || "";
    var subid = body["subid"] || "";
    var tileid = body["tile"] || "";
    var command = body["command"] || "";
    var linkval = body["linkval"] || "";

    if ( DEBUG9 ) {
        console.log( (ddbg()), "api call: protocol: ", protocol, " body: ", UTIL.inspect(body, false, null, true) );
    }
    if ( hubs && hubs.length ) {
        var defhub = hubs[0]["hubId"];
    } else {
        defhub = "-1";
    }
    var hubid = body["hubid"] || "auto";
    if ( body["hubnum"] ) {
        var hubnum = parseInt(body["hubnum"]);
        if ( !isNaN(hubnum) && hubnum >=0 && hubnum < hubs.length ) {
            hubid = hubs[hubnum]["hubId"];
        } else {
            hubid = "auto";
        }
    }

    // handle multiple api calls but only for tiles since nobody would ever give a list of long id's
    if ( tileid && tileid.indexOf(",") !== -1 ) {
        var multicall = true;
        var tilearray = tileid.split(",");
    } else {
        multicall = false;
    }

    var result;
    switch (api) {
        
        case "doaction":
            if ( multicall ) {
                result = [];
                tilearray.forEach(function(atile) {
                    if ( DEBUG8 ) {
                        console.log( (ddbg()), "doaction multicall: hubid: ", hubid, " swid: ", swid, " swval: ", swval, " swattr: ", swattr, " subid: ", subid, " atile: ", atile);
                    }
                    var aresult = doAction("auto", "", "", swval, swattr, subid, atile, "", "", protocol);
                    result.push(aresult);
                });
            } else {
                if ( DEBUG8 ) {
                    console.log( (ddbg()), "doaction: hubid: ", hubid, " swid: ", swid, " swval: ", swval, " swattr: ", swattr, " subid: ", subid, " tileid: ", tileid);
                }
                result = doAction(hubid, swid, swtype, swval, swattr, subid, tileid, command, linkval, protocol);
            }
            break;
            
        case "doquery":
            if ( multicall ) {
                result = [];
                tilearray.forEach(function(atile) {
                    var aresult = doQuery("auto", "", "", atile, protocol);
                    result.push(aresult);
                });
            } else {
                result = doQuery(hubid, swid, swtype, tileid, protocol);
            }
            break;

        case "status":
            var activehubs = GLB.options.config ? utils.count(GLB.options.config.hubs) : 0;
            var thingcount = utils.count(allthings);
            var username = GLB.options.config.uname || "";
            result = {"state": "active", "hubs": activehubs, "clients": clients.length, "things": thingcount, "username": username};
            break;

        case "wysiwyg2":
            // if we sorted the user fields in the customizer, save them
            if ( is_array(swattr) ) {
                GLB.options["user_" + swid] = swattr;
                writeOptions(GLB.options);
            }
            var idx = swtype + "|" + swid;
            var thing = allthings[idx];
            result = makeThing(0, tileid, thing, "wysiwyg", 0, 0, 99, "", api);
            break;

        case "wysiwyg":
            if ( swtype==="page" ) {
                // make the fake tile for the room for editing purposes
                var faketile = {"panel": "panel", "name": swval, "tab": "Tab Inactive", "tabon": "Tab Selected"};
                var thing = { "id": "r_" + swid, "name": swval, 
                              "hubnum": -1, "type": "page", "value": faketile};
                // result = makeThing(0, tileid, thing, swval, 0, 0, 99, "", api);
                result = makeThing(0, tileid, thing, "wysiwyg", 0, 0, 99, "", api);
            } else {
                var idx = swtype + "|" + swid;
                var thing = allthings[idx];
                result = makeThing(0, tileid, thing, "wysiwyg", 0, 0, 99, "", api);
            }
            break;

        case "pageorder":
            result = setOrder(swid, swtype, swval, swattr);
            break;

        case "dragdrop":
            if ( protocol==="POST" ) {
                result = setPosition(swid, swtype, swval, swattr);
            } else {
                result = "error - api call [" + api + "] is only supported in " + protocol + " mode.";
            }
            break;

        case "dragmake":
            if ( protocol==="POST" ) {
                result = addThing(swid, swtype, swval, swattr);
            } else {
                result = "error - api call [" + api + "] is only supported in " + protocol + " mode.";
            }
            break;
    
        case "dragdelete":
            if ( protocol==="POST" ) {
                result = delThing(swid, swtype, swval, swattr);
            } else {
                result = "error - api call [" + api + "] is only supported in " + protocol + " mode.";
            }
            break;

        case "pagedelete":
            if ( protocol==="POST" ) {
                result = delPage(swval);
            } else {
                result = "error - api call [" + api + "] is only supported in " + protocol + " mode.";
            }
            break;
    
        case "pageadd":
            if ( protocol==="POST" ) {
                result = addPage();
            } else {
                result = "error - api call [" + api + "] is only supported in " + protocol + " mode.";
            }
            break;

        case "getcatalog":
            result = getCatalog(swattr);
            break;
            
        case "refactor":
            if ( protocol==="POST" ) {
                // TODO: this does not yet work so it was removed from menu
                // note really needed any more - it just renumbers tiles
                // the same effect can be had by deleting your hmoptions.cfg file
                // but this will remove all customizations. This routine attempted to save them but it isn't working right now
                // refactorOptions();
                getAllThings();
                result = "success";
            } else {
                result = "error - api call [" + api + "] is only supported in " + protocol + " mode.";
            }
            break;
    
        case "refresh":
            getAllThings();
            result = "success";
            break;
        
        // the GUI will never ask to reload options but a user might when making an api call
        case "getoptions":
            var reload = ( body['swattr']==="reload" );
            if ( reload ) {
                readOptions();
            }
            result = GLB.options;
            break;
        
        case "getthings" :
            var reload = ( body['swattr']==="reload" );
            if ( reload && protocol==="POST" ) {
                getAllThings();
            }
            result = clone(allthings);
            break;
                
        case "gethubs" :
           result = hubs;
           break;

        case "filteroptions":
            if ( protocol==="POST" ) {
                result = saveFilters(body);
            } else {
                result = "error - api call [" + api + "] is only supported in " + protocol + " mode.";
            }
        break;

        case "saveuserpw":
            if ( protocol==="POST" ) {
                result = saveUserPw(body);
            } else {
                result = "error - api call [" + api + "] is only supported in " + protocol + " mode.";
            }
            break;

        case "savetileedit":
            var partnum = parseInt(swid);
            var skin = getSkin();
            result = writeCustomCss(partnum, skin, swval);
            break;

        case "saveoptions":
            if ( protocol==="POST" ) {
                processOptions(body);
                result = "success";
            } else {
                result = "error - api call [" + api + "] is only supported in " + protocol + " mode.";
            }
            break;

        case "updatenames":
            result = updateNames(swtype, tileid, swval, swattr);
            break;
        
        case "dologin":
            if ( protocol==="POST" ) {
                var uname = body["uname"].trim();
                var pword = body["pword"].trim();
                if ( pword!=="" ) {
                    var thehash = crypto.createHash("sha256");
                    thehash.update(pword);
                    pword = thehash.digest('hex');
                }
                GLB.options["config"]["uname"] = uname;
                writeOptions(GLB.options, true);

                // check to see if the provided username is valid
                // and that the passwords match
                var result = "error";
                var pwords = GLB.options["config"]["pword"];

                if ( DEBUG8 ) {
                    console.log( (ddbg()), "dologin: uname= ", uname, " pword: [", pword, "] body: ", body, " pwords: ", pwords);
                }

                // check for matching passwords
                if ( array_key_exists(uname, pwords ) ) {
                    var pw = pwords[uname];
                    if ( pw[0] === pword || IGNOREPW ) {
                        GLB.pwcrypt = pw[0];
                    } else {
                        GLB.pwcrypt = false;
                    }
                    result = "success";
                }
            } else {
                result = "error - api call [" + api + "] is only supported in POST mode.";
            }
            break;

        case "pwhash":
            var result;
            if ( swtype==="hash" ) {
                result = pw_hash(swval);
            } else if ( swtype==="verify" ) {
                if ( pw_verify(swval, swattr) ) {
                    result = "success";
                } else {
                    result = "error";
                }
            } else {
                result = "error";
            }
            break;

        case "addcustom":
            var result = {}
            result.value = addCustom(swid, swtype, swval, swattr, subid);
            readOptions();
            result.options = GLB.options;
            result.things = allthings;
            break;

        case "delcustom":
            var result = {}
            result.value = delCustom(swid, swtype, swval, swattr, subid);
            readOptions();
            result.options = GLB.options;
            result.things = allthings;
            break;
            
        case "geticons":
            var result = getIcons(swval, swattr);
            break;

        case "hubauth":

            // now load the new data
            var hub = {};
            hub["hubType"] = body.hubType;
            hub["hubHost"] = body.hubHost;
            hub["clientId"] = body.clientId;
            hub["clientSecret"] = body.clientSecret;
            hub["userAccess"] = body.userAccess;
            hub["userEndpt"] = body.userEndpt;
            hub["hubName"] = body.hubName;
            hub["hubId"] = body.hubId;
            hub["hubAccess"] = body.hubAccess;
            hub["hubEndpt"] = body.hubEndpt;
            hub["hubTimer"] = body.hubTimer;

            // if user provides hub access info, use it
            // for ISY hubs we know the endpoint as /rest so use it

            if ( body.hubType==="ISY" ) {
                body.userEndpt = body.hubHost + "/rest";
                hub["userEndpt"] = body.userEndpt;
            }

            if ( body.userEndpt ) {
                // remove trailing slash if it is there
                if ( body.userEndpt.substr(-1) === "/" ) {
                    body.userEndpt = body.userEndpt.substr(0, body.userEndpt.length -1);
                }
                hub["hubEndpt"] = body.userEndpt;
                if (body.hubType==="ISY") {
                    body.userAccess = body.clientId + ":" + body.clientSecret;
                    hub["userAccess"] = body.userAccess;
                    hub["hubAccess"] = hub["userAccess"];
                    hub.hubId = "isy01";

                    // use default name if one not given
                    if ( hub["hubName"].trim()==="" ) {
                        hub["hubName"] = "ISY";
                    }
                }
            }

            if ( body.userAccess && body.hubType!=="ISY" ) {
                hub["hubAccess"] = body.userAccess;
            }

            // if this is a new hub and no name given, give it one
            if ( body.hubId==="new" && !hub.hubName ) {
                hub.hubName = "New " + hub.hubType;
            }

            // update existing or add a new hub
            updateHubs(hub, body.hubId);
            writeOptions(GLB.options, true);
            hubs = GLB.options.config.hubs;

            if (DEBUG2) {
                console.log( (ddbg()), "There are " + hubs.length + " hubs are available after hubauth.");
                console.log( (ddbg()), "hubs: ", hubs);
            }

            // now authorize them
            // handle direct access including ISY hubs first
            var hubnum = hub["hubId"];
            var hubName = hub["hubName"];
            var hubType = hub["hubType"];
            var host = hub["hubHost"];
            var clientId = hub["clientId"];
            var clientSecret = hub["clientSecret"];
            GLB.defhub = hubnum;
            if ( (hub["userAccess"] && hub["userEndpt"]) || body.hubType==="ISY" ) {

                // get all new devices and update the options index array
                // this forces page reload with all the new stuff
                // notice the reference to /reauth in the call to getDevices
                // this makes the final read redirect back to reauth page
                var accesstoken  = hub["hubAccess"];
                var hubEndpt = hub["hubEndpt"];

                // for ISY we can go right to getting devices
                // for ST and HE we need to use getHubInfo to first get hubId and hubName
                // and then we call devices from there given the async nature of Node
                // this is much like what happens in the getAccessToken function in the OAUTH flow
                if ( body.hubType==="ISY" ) {
                    getDevices(hubnum, hubType, accesstoken, hubEndpt, clientId, clientSecret, hubName, "/reauth");
                } else {
                    getHubInfo(hub, accesstoken, hubEndpt, clientId, clientSecret);
                }

                // writeOptions(GLB.options, true);
                // getDevices(hubnum, hubType, accesstoken, hubEndpt, clientId, clientSecret, hubName, "/reauth");
                result = {action: "things", hubType: hubType, hubName: hubName};
                if ( DEBUG2 ) {
                    console.log( (ddbg()), "Device retrieval initiated: ", result);
                }

            // here we start an oauth flow
            // we complete the flow later when redirection happens back to /oauth GET call
            } else {
                var returnloc = GLB.returnURL + "/oauth";
                result = {action: "oauth", host: host, hubName: hubName, clientId: clientId, clientSecret: clientSecret, url: returnloc};
                if ( DEBUG2 ) {
                    console.log( (ddbg()), "OAUTH flow initiated: ", result);
                }
            }
    
            break;
    
        case "hubdelete":
            // TODO - implement hubDelete() function
            console.log( (ddbg()), "Hub deletion is not yet supported...");
            result = "success";
            break;

        case "cancelauth":
            // by returning success we signal a redirection to the options page
            result = "success";
            break;

        case "showoptions":
        case "showid":
        case "reauth":
        case "showid":
        case "logout":
        case "trackupdate":
                var result = "error - [" + api + "] API call is no longer supported. Try loading browser with: " + GLB.returnURL + "/" + api;
                console.log( (ddbg()), result);
                break;
                
        case "reset":
            if ( protocol==="GET" ) {
                readOptions();
                GLB.options.config["pword"] = {};
                GLB.options.config["pword"]["default"] = ["", "skin-housepanel"];
                GLB.options. config["uname"] = "default";
                GLB.pwcrypt = true;
                writeOptions(GLB.options, true);
                pushClient("reload", "/logout");
                result = getLoginPage();
            } else {
                result = "error - api call [" + api + "] is only supported in " + protocol + " mode.";
            }
            break;

        default:
            result = "error - unrecognized " + protocol + " api call: " + api;
            break;
    }
    return result;

}

// ***************************************************
// beginning of main routine
// ***************************************************
var d = new Date();
var hpcode = d.getTime();
GLB.hpcode = hpcode.toString();

// read the config file and get array of hubs
readOptions();

var uname = getUserName();
try {
    GLB.pwcrypt = GLB.options.config.pword[uname][0];
} catch (e) {
    GLB.pwcrypt = (IGNOREPW || GLB.newuser) ? true : false;
}

if ( DEBUG5 ) {
    console.log( (ddbg()), "Index: ", UTIL.inspect(GLB.options, false, null, false));
}

var config = GLB.options.config;
// var hubs = config["hubs"];
var port = config["port"];
if ( !port ) {
    port = 3080;
}
GLB.defhub = "-1";

// start our main server
try {
    // the Node.js app loop - can be invoked by client or back end
    app = express();
    app.use(bodyParser.json());
    app.use(bodyParser.urlencoded({ extended: true }));
    var dir = path.join(__dirname, '');
    app.use(express.static(dir));

    // list on the port
    app.listen(port, function () {
        console.log((ddbg()) + "HousePanel Node.js Server is running on port: ", port);
    });
    applistening = true;
    
} catch (e) {
    console.log((ddbg()) + 'HousePanel Node.js Server could not be started on port: ', port);
    app = null;
    applistening = false;
}

// retrieve all nodes/things
// client pages are refreshed when each hub is done reading
if ( applistening ) {
    getAllThings();

    var maxroom = 0;
    if ( array_key_exists("things", GLB.options) && 
        array_key_exists("rooms", GLB.options) ) {
        var thingoptions = GLB.options["things"];
        for (var roomname in thingoptions) {
            var thinglist = thingoptions[roomname];
            if ( thinglist.length > maxroom ) {
                maxroom = thinglist.length;
            }
        }
    }
}

// create the HTTP server for handling sockets
server = http.createServer(function(req, res) {
});

// set up server for a two way socket communication with the browser
if ( server && config.webSocketServerPort ) {
    // create the webSocket server
    wsServer = new webSocketServer({
        httpServer: server
    });
    server.listen(config.webSocketServerPort, function() {
        console.log((ddbg()) + "webSocket Server is listening on port: ", config.webSocketServerPort);
    });
    serverlistening = true;
} else {
    serverlistening = false;
    console.log((ddbg()) + "webSocket port not valid. webSocketServerPort= ", config.webSocketServerPort);
}


// make websocket connection to any ISY hub
// unlike ST and HE below, communication from ISY happens over a real webSocket
var isyhub = false;
var wshost;
for (var h in GLB.options.config["hubs"]) {
    var hub = GLB.options.config["hubs"][h];
    wshost = false;
    if ( hub["hubType"]==="ISY" && hub["hubEndpt"] && hub["hubAccess"] ) { 

        var hubhost = hub["hubEndpt"];
        if ( hubhost.startsWith("https://") ) {
            wshost = "wss://" + hubhost.substr(8);
        } else if ( hubhost.startsWith("http://") ) {
            wshost = "ws://" + hubhost.substr(7);
        }
    }

    // set up socket for ISY hub if one is there
    if ( wshost ) {
        var wsclient = new webSocketClient();
        var buff = Buffer.from(hub["hubAccess"]);
        var base64 = buff.toString('base64');
        var origin = "com.universal-devices.websockets.isy";
        var header = {"Authorization": "Basic " + base64, "Sec-WebSocket-Protocol": "ISYSUB",  
                    "Sec-WebSocket-Version": "13", "Origin": "com.universal-devices.websockets.isy"};
        wshost = wshost + "/subscribe";

        wsclient.on("connectFailed", function(err) {
            console.log( (ddbg()), "Connection failure to ISY socket: ", err.toString(), " wshost: ", wshost, " header: ", header);
        });

        wsclient.on("connect", function(connection) {
            console.log( (ddbg()), "Success connecting to ISY socket. Listening for messages...");

            // handle incoming state messages from ISY
            // this will be ignored if the node isn't in our list
            connection.on("message", function(msg) {
                if ( msg.type==="utf8" ) {
                    processIsyMessage(msg.utf8Data);
                }
            });
        
            connection.on("error", function(err) {
                console.log( (ddbg()), "Connection error to ISY socket: ", err.toString());
            });
        
            connection.on("close", function() {
                console.log( (ddbg()), "Connection closed to ISY socket");
            });
        
        });

        wsclient.connect(wshost, "ISYSUB", origin, header);
    }
}

    
// handler functions for HousePanel
// this is where we render the baseline web page for the dashboard
if ( app && applistening ) {

    // define all the mime types that can be rendered
    var mime = {
        html: 'text/html',
        txt: 'text/plain',
        css: 'text/css',
        gif: 'image/gif',
        jpg: 'image/jpeg',
        png: 'image/png',
        svg: 'image/svg+xml',
        js: 'application/javascript'
    };

    app.get('*', function (req, res) {
        
        var hostname = req.protocol + "://" + req.headers.host;
        console.log((ddbg()) + " serving page at: ", hostname);
        var $tc;

        if ( req.path==="/" || typeof req.path==="undefined" || req.path==="/undefined" || req.path==="undefined" ) {

            // read options upon a reload
            // readOptions();
            uname = getUserName();
            
            // set the global variable so other functions can return here
            var queryobj = req.query || {};
            var isquery = (utils.count(queryobj) > 0);

            // allow user to manually reset things with this code
            // the hub auth flow is handled with the /reauth path later below
            // this removes all user accounts and logs everyone out
            if ( isquery && queryobj.code && (queryobj.code==="reset") ) {
                readOptions();
                GLB.options.config["pword"] = {};
                GLB.options.config["pword"]["default"] = ["", "skin-housepanel"];
                GLB.options.config["uname"] = "default";
                GLB.pwcrypt = true;
                writeOptions(GLB.options, true);
                pushClient("reload", "/logout");
                $tc = "Logging out all clients..."; // getLoginPage();

            // handle user provided get api calls
            } else if ( isquery ) {
                console.log( (ddbg()), "api call: ",  queryobj);
                $tc = apiCall(queryobj, "GET");

            // display the main page if password matches
            // or if we don't have a pw
            } else if ( IGNOREPW || GLB.newuser || GLB.pwcrypt===true || (array_key_exists(uname, GLB.options.config["pword"]) && GLB.pwcrypt===GLB.options.config["pword"][uname][0]) ) {
                // reset for next refresh
                GLB.defhub = "-1";
                
                // set this to always see new user welcome message
                // otherwise, comment it out
                // GLB.newuser = true;

                GLB.pwcrypt===config["pword"][uname][0];
                console.log( (ddbg()), "login accepted. uname = ", uname, " pwcrypt = ", GLB.pwcrypt);
                $tc = mainPage(req.protocol, req.headers.host, req.path);

            } else {
                console.log( (ddbg()), "login rejected. uname= ", uname, " pwcrypt= ", GLB.pwcrypt, " configpw= ", GLB.options.config["pword"][uname][0]);
                $tc = getLoginPage();
            }
            res.send($tc);
            res.end();

        } else if ( req.path==="/showid") {
            // readOptions();
            $tc = getInfoPage(GLB.returnURL, req.path);
            res.send($tc);
            res.end();

        } else if ( req.path==="/showoptions") {
            // readOptions();
            $tc = getOptionsPage(req.path);
            res.send($tc);
            res.end();

        } else if ( req.path==="/logout") {
            // readOptions();
            $tc = getLoginPage();
            GLB.pwcrypt = false;
            res.send($tc);
            res.end();

        } else if ( req.path==="/reauth") {
            // readOptions();
            d = new Date();
            hpcode = d.getTime();
            GLB.hpcode = hpcode.toString();
            var $tc = getAuthPage(req.headers.host, GLB.hpcode);
            res.send($tc);
            res.end();

        } else if ( req.path==="/oauth") {
            var queryobj = req.query || {};
            if ( queryobj["code"] ) {
                var hubnum = GLB.defhub;
                var hub = findHub(hubnum);

                // get token, endpt, and retrieve devices
                // this goes through a series of callbacks
                // and ends with a pushClient to update the auth page
                getAccessToken(queryobj["code"], hub);
            } else {
                GLB.defhub = "-1";
            }
            d = new Date();
            hpcode = d.getTime();
            GLB.hpcode = hpcode.toString();
            var $tc = getAuthPage(req.headers.host, GLB.hpcode);
            res.send($tc);
            res.end();

        } else if ( req.path==="/reset") {
            readOptions();
            getAllThings();
            res.send("Resetting...");
            res.end();

        } else {
            var file = path.join(dir, req.path.replace(/\/$/, '/index.html'));
            if (file.indexOf(dir + path.sep) !== 0) {
                res.status(403).end('Forbidden');
            }
            if ( DEBUG1 ) {
                console.log( (ddbg()) + " Loading module: ", req.path, " as: ", file);
            }
            var type = mime[path.extname(file).slice(1)] || 'text/plain';
            var s = fs.createReadStream(file);
            s.on('open', function () {
                res.set('Content-Type', type);
                // res.type(type)
                s.pipe(res);
            });
            s.on('error', function () {
                res.set('Content-Type', 'text/plain');
                res.status(404).end(req + ' Not found');
            });
        }
    });
    
    app.put('*', function(req, res) {
        console.log( (ddbg()), "PUT api calls not yet supported. requested put: ", req.path);
        res.end();
    });

// ***************************************************
// these are server treatments for processing jQuery
// ***************************************************
    
    app.post("/", function (req, res) {

        // handle two types of messages posted from hub
        // the first initialize type tells Node.js to update elements
        if ( req.body['msgtype'] == "initialize" ) {
            res.json('hub info updated');
            console.log( (ddbg()), "New hub authorized; updating things in hpserver.");
            readOptions();
            getAllThings();
        
        // handle callbacks from ST and HE here
        // for ISY this is done via websockets above
        } else if ( req.body['msgtype'] == "update" ) {
            console.log( (ddbg()), "Received update msg from hub. ", req.body["hubid"], " body: ", req.body);

            // loop through all things for this hub
            // remove music trackData field that we don't know how to handle
            var cnt = 0;
            // for (var num= 0; num< allthings.length; num++) {
            for (var idx in allthings) {

                var entry = allthings[idx];
                if ( entry.id == req.body['change_device'].toString() &&
                    req.body['change_attribute']!='trackData' &&
                    entry['value'][req.body['change_attribute']] != req.body['change_value'] )
                {
                    cnt = cnt + 1;
                    entry['value'][req.body['change_attribute']] = req.body['change_value'];
                    if ( entry['value']['trackData'] ) { delete entry['value']['trackData']; }
                    console.log( (ddbg()), 'Updating tile #',entry['id'],' from trigger:', req.body['change_attribute'] );
                    pushClient(entry.id, entry.type, req.body['change_attribute'], entry['value'])

                    // process rules and links
                    if ( GLB.options.config["rules"] ==="true" || GLB.options.config["rules"] ===true ) {
                        processRules(bid, entry.type, subid, newvalue);
                        processLinks(entry.id, entry.type, req.body['change_attribute'], entry['value']);
                    }

                }
            }
            res.json('pushed new status info to ' + cnt + ' tiles');

        // handle all api calls upon the server from js client here
        } else if ( typeof req.body['useajax']!=="undefined" || typeof req.body["api"]!=="undefined" ) {
            var result = apiCall(req.body, "POST");
            res.json(result);
            // res.end();
        
        // handle unknown requests
        } else {
            console.log((ddbg()) + "hpserver received unknown message.", req.body);
            res.json('hpserver received unknown message.');
        }

    });
}

// This callback function handles new connections and closed connections
if ( wsServer && serverlistening ) {
    wsServer.on('request', function(request) {
        console.log( (ddbg()), 'Connecting websocket to: ', request.origin);

        // accept connection - you should check 'request.origin' to make sure that
        // client is connecting from your website
        // (http://en.wikipedia.org/wiki/Same_origin_policy)
        var connection = request.accept(null, request.origin); 
        
        // shut down any existing connections to same remote host
        var host = connection.socket.remoteAddress;
        var i = 0;
        while ( i < clients.length ) {
            var oldhost = clients[i].socket.remoteAddress;
            if ( oldhost===host ) {
                clients.splice(i, 1);
            } else {
                i++;
            }
        }

        // report index of the connection
        // we no longer rely on this to close prior connections
        // instead we just shut down any that match
        var index = clients.push(connection) - 1;
        console.log( (ddbg()), 'Connection accepted. Client #' + index + " host=" + host);

        // user disconnected - remove all clients that match this socket
        connection.on('close', function(reason, description) {
            var host = connection.socket.remoteAddress;
            console.log( (ddbg()), "Peer: ", host, " disconnected. for: ", reason, " desc: ", description);

            // remove clients that match this host
            // clients.splice(indexsave, 1);
            var i = 0;
            while ( i < clients.length ) {
                var oldhost = clients[i].socket.remoteAddress;
                if ( oldhost===host ) {
                    clients.splice(i, 1);
                } else {
                    i++;
                }
            }
        });

    });
}
