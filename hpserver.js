"use strict";
process.title = 'hpserver';

// debug options
var DEBUG1 = false;
var DEBUG2 = false;
var DEBUG3 = true;
var DEBUG4 = true;
var DEBUG5 = false;
var DEBUG6 = true;

// websocket and http servers
var webSocketServer = require('websocket').server;
var path = require('path');
var http = require('http');
var fs = require('fs');
var express = require('express');
var bodyParser = require('body-parser');
// var parseString = require('xml2js').parseString;
var parser = require('fast-xml-parser');
var crypto = require('crypto');

// load supporting modules
var utils = require("./utils");

// global variables are all part of GLB object plus clients and allthings
var GLB = {};
// list of currently connected clients (users)
var clients = [];
// array of all tiles in all hubs
var allthings = {};

// server variables
var server;
var wsServer;
var app;
var applistening = false;
var serverlistening = false;

var CRYPTSALT ='HP$by%KW';
var BYPASSPW = false;

function file_exists(fname) {
    return fs.existsSync(fname);
}

function getUserName() {
    return "default";
}

// get the active user and skin
function getSkin() {
    var uname = getUserName();
    var pwords = GLB.options["config"]["pword"];
    var skin;
    if ( !pwords || !is_array(pwords) || count(pwords)===0 ) {
        skin = "skin-housepanel";
    } else if ( uname && array_key_exists(uname, pwords) ) {
        pword = pwords[uname];
        if ( is_array(pword) ) {
            skin = pword[1];
        } else {
            skin = GLB.options["config"]["skin"];
        }
    } else {
        skin = "skin-housepanel";
    }
    return skin;
}

// read in customtiles ignoring the comments
// updated this to properly treat /*   */ comment blocks
function readCustomCss(skin) {
    var fname = "skin/customtiles.css";
    var contents = fs.readFileSync(fname, 'utf8');
    return contents;
}

// call to write Custom Css Back to customtiles.css
function writeCustomCss(partnum, skin, str) {
    var results;
    // proceed only if there is a main css file in this skin folder
    if ( skin && file_exists(skin + "/housepanel.css") ) {
        var d = new Date();
        var today = d.toLocaleString();
        var fixstr = "";
        var opts = "a";

        // if this is the first part then rewrite the file
        // while preserving the header
        if ( partnum===1 ) {
            var ipos = str.indexOf("*---*/");
            opts = "w";

            // preserve the header info and update it with date
            if ( !str || ipos=== -1 ) {
                fixstr += "/* HousePanel Generated Tile Customization File */\n";
                if ( str ) {
                    fixstr += "/* Updated: " + today + " *---*/\n";
                } else {
                    fixstr += "/* Created: " + today + " *---*/\n";
                }
                fixstr += "/* ********************************************* */\n";
                fixstr += "/* ****** DO NOT EDIT THIS FILE DIRECTLY  ****** */\n";
                fixstr += "/* ****** EDITS MADE MAY BE REPLACED      ****** */\n";
                fixstr += "/* ****** WHENEVER TILE EDITOR IS USED    ****** */\n";
                fixstr += "/* ********************************************* */\n";
            } else {
                fixstr += "/* HousePanel Generated Tile Customization File */\n";
                fixstr += "/* Updated: " + today + " *---*/\n";
                ipos = ipos + 7;
                str = str.substring(ipos);
            }
        }

        // fix addition of backslashes before quotes on some servers
        if ( str && str.length ) {
            var str3 = str.replace("\\\"","\"");
            fixstr += str3;
        }

        // write to specific skin folder if the location is valid
        try {
            fs.writeFileSync(skin + "/customtiles.css", fixstr, {encoding: "utf8", flag: opts});
            console.log("custom CSS file saved in skin folder: ", skin, " of size: ", fixstr.length," part #", partnum);
            results = "success";
        } catch (e) {
            console.log(e);
            console.log("Error attempting to save custom CSS file in skin folder: ", skin," part #", partnum);
            results = "error - " + e;
        }
    } else {
        results = "error - invalid skin: " + skin;
    }
    return results;
}

function readOptions(reset) {

    // read options file here since it could have changed
    var fname = "hmoptions.cfg";
    try {
        if ( !fs.existsSync(fname) ) {
            console.log((new Date()) + ' hmoptions.cfg file not found. HousePanel will not function properly.');
            return null;
        }
        GLB.options = JSON.parse(fs.readFileSync(fname, 'utf8'));
        GLB.config = GLB.options.config;
        GLB.hubs = GLB.config.hubs;
    } catch(e) {
        console.log((new Date()) + ' hmoptions.cfg file found but could not be processed.');
        GLB.options = null;
        GLB.config = null;
        GLB.hubs = null;
    }

    if ( GLB.options ) {
        var options = GLB.options;
        var timeval = GLB.options["time"];
        var info = timeval.split(" @ ");
        var version = info[0];

        console.log((new Date()) + ' Config file found from HP Version ', version);
        if ( GLB.hubs && GLB.hubs.length > 0 ) {
            console.log((new Date()) + ' Loaded ', GLB.hubs.length,' hubs.');
            if ( DEBUG5 ) {
                console.log(GLB.hubs);
            }
        } else {
            console.log((new Date()) + ' No hubs found. HousePanel will only show special and custom tiles.');
        }
        
        // make the room config file to support custom users
        var uname = getUserName();
        if ( uname ) {
            
            // $uname = trim($_COOKIE["uname"]);
            var customfname = "hm_" + uname + ".cfg";
            var key;
            if ( reset || !fs.existsSync(customfname) ) {
                // this format is now in real json format and includes user_ tiles
                // add a signature key to flag this format
                var customopt = {};
                customopt["::CUSTOM::"] = [uname, utils.HPVERSION, timeval];
                for (key in options) {
                    if ( key==="rooms" || key==="things" || key.substr(0,5)==="user_" ) {
                        customopt[key] = options[key];
                    }
                }
                var str_customopt = JSON.stringify(customopt, null, 1);
                fs.writeFileSync(customfname, str_customopt);
            } else {

                // read this assuming new method only
                var str = fs.readFileSync(customfname, 'utf8');
                var str1 = str.replace("\r","");
                var str2 = str1.replace("\n","");
                var str3 = str2.replace("\t","");
                var opts = JSON.parse(str3);

                var opt_rooms = null;
                var opt_things = null;
                if ( opts["rooms"] ) {
                    opt_rooms = opts["rooms"];
                }
                if ( opts["things"] ) {
                    opt_things = opts["things"];
                }
                for (key in opts) {
                    if ( key.substr(0,5)==="user_" ) {
                        GLB.options[key] = opts[key];
                    }
                }
                    
                // protect against having a custom name and an empty custom user info
                if ( opt_rooms && opt_things && utils.count(opt_rooms) > 0 && utils.count(opt_things) > 0 ) {
                    GLB.options["rooms"] = opt_rooms;
                    GLB.options["things"] = {};
                    for (var room in opt_rooms) {
                        if ( array_key_exists(room, opt_things) ) {
                            GLB.options["things"][room] = opt_things[room];
                        }
                    }
                }
            }
        }
    }
    // console.log(GLB.options["things"]);
    
    return GLB.options;
}

function writeOptions(options) {
    
    if ( !options ) {
        return;
    }

    var d = new Date();
    var timeval = d.getTime();
    options["time"] = utils.HPVERSION + " @ " + timeval;
    GLB.options = clone(options);
    
    // write the main options file
    var stropt =  JSON.stringify(options, null, 1);
    fs.writeFileSync("hmoptions.cfg", stropt, {encoding: "utf8", flag:"w"});
    
    // write the user specific options file
    var uname = getUserName();
    if ( uname ) {
        var userfname = "hm_" + uname + ".cfg";

        // this format is now in real json format and includes user_ tiles
        // add a signature key to flag this format
        var customopt = {};
        customopt["::CUSTOM::"] = [uname, utils.HPVERSION, timeval];
        for (var key in GLB.options) {
            if ( key==="rooms" || key==="things" || key.substr(0,5)==="user_" ) {
                customopt[key] = GLB.options[key];
            }
        }
        var str_customopt = JSON.stringify(customopt, null, 1);
        fs.writeFileSync(userfname, str_customopt, {encoding: "utf8", flag:"w"});
    }
}

function curl_call(host, headertype, nvpstr, formdata, calltype, callback) {
    var request = require('request');
    var opts = {url: host};
    if ( !calltype ) {
        calltype = "GET";
    }
    opts.method = calltype;
    
    if ( nvpstr && typeof nvpstr === "object" ) {
        opts.form = nvpstr;
    } else if ( nvpstr && typeof nvpstr === "string" ) {
        opts.url = host + "?" + nvpstr;
    }
    
    if (formdata) {
        opts.formData = formdata;
    }
    
    if ( headertype ) {
        opts.headers = headertype;
    }
    request(opts, callback);
}

function getDevices(hubnum, hubAccess, hubEndpt, clientId, clientSecret, hubName, hubType) {

    // retrieve all things from ST
    if ( hubType==="SmartThings" || hubType==="Hubitat" ) {
        var stheader = {"Authorization": "Bearer " + hubAccess};
        var params = {client_secret: clientId,
                      scope: "app",
                      client_id: clientSecret};
        curl_call(hubEndpt + "/getallthings", stheader, params, false, "POST", getAllDevices);
    } else if ( hubType==="ISY" ) {
        var buff = Buffer.from(hubAccess);
        var base64 = buff.toString('base64');
        stheader = {"Authorization": "Basic " + base64};
        // console.log(stheader);
        curl_call(hubEndpt + "/nodes", stheader, false, false, "GET", getAllNodes);
        
    } else {
        console.log("Error: attempt to read an unknown hub type= ", hubType);
        return;
    }
    
    function getAllNodes(err, res, body) {
        var id;
        if ( err ) {
            console.log("Error retrieving ISY nodes: ", err);
        } else {
            var result = parser.parse(body);
            var thenodes = result.nodes["node"];
            if (DEBUG6) {
                console.log((new Date()) + " Retrieved ", thenodes.length, " things from hub: ", hubName);
            }    
            for ( var obj in thenodes ) {
                var node = thenodes[obj];
                id = node["address"];
                var thetype = "isy";
                var idx = thetype + "|" + id;
                var hint = node["type"].toString();
                var name = node["name"];
                var thevalue = {"name": name, "switch": "DOF"};
                if (DEBUG5) {
                    console.log("idx= ", idx," hint= ", hint, " thing= ", thevalue);
                }
                allthings[idx] = {
                    "id": id,
                    "name": name, 
                    "hubnum": hubnum,
                    "type": thetype, 
                    "refresh": "normal",
                    "value": thevalue
                };
                if (DEBUG5) {
                    console.log("ISY thing: ", allthings[idx]);
                }
            }
            updateOptions();
        }
    }
    
    function getAllDevices(err, res, body) {
        if ( err ) {
            console.log("Error retrieving devices: ", err);
        } else {
            try {
                var jsonbody = JSON.parse(body);
            } catch (e) {
                console.log("Error translating devices: ", e);
                jsonbody = {};
                return;
            }
            if (DEBUG6) {
                console.log((new Date()) + " Retrieved ", jsonbody.length, " things from hub: ", hubName);
            }    

            // configure returned array with the "id"
            if (jsonbody && typeof jsonbody === "object") {
                jsonbody.forEach(function(content) {
                    var thetype = content["type"];
                    var id = content["id"];
                    var idx = thetype + "|" + id;
                    allthings[idx] = {
                        "id": id,
                        "name": content["name"], 
                        "hubnum": hubnum,
                        "type": thetype, 
                        "refresh": "normal",
                        "value": content["value"]
                    };
                });
            }
            updateOptions();
        }
    }
}

// // returns the maximum index from the options
// function getMaxIndex() {
//     var maxindex = 0;
//     for ( var key in GLB.options["index"] ) {
//         var value = parseInt(GLB.options["index"][key]);
//         maxindex = ( value > maxindex ) ? value : maxindex;
//     }
//     return maxindex;
// }

// updates the global options array with new things found on hub
function updateOptions() {

    if ( ! GLB.options ) {
        return;
    }
   
    // make all the user options visible by default
    if ( !array_key_exists("useroptions", GLB.options )) {
        GLB.options["useroptions"] = utils.getTypes();
    }

    // find the largest index number for a sensor in our index
    var cnt = utils.getMaxIndex(GLB.options["index"]) + 1;

    // update the index with latest sensor information
    for (var thingid in allthings) {
        var thesensor = allthings[thingid];
        if ( !array_key_exists(thingid, GLB.options["index"]) ||
             parseInt(GLB.options["index"][thingid])===0 ) {
            GLB.options["index"][thingid] = cnt;
            cnt++;
        }
    }
    
    // make exactly the right number of special tiles
    var specialtiles = utils.getSpecials();
    // $oldindex = $options["index"];
    for (var stype in specialtiles) {
        var sid = specialtiles[stype];
        var customcnt = getCustomCount(stype);
        GLB.options = createSpecialIndex(customcnt, stype, sid[0]);
    }

    // save the options file
    writeOptions(GLB.options);
    // console.log("Updated options, rooms: ", GLB.options.rooms, " things: ", GLB.options.things);

    // signal clients to reload
    pushClient("reload", "reload");
}

function createSpecialIndex(customcnt, stype, spid) {
    var oldindex = GLB.options["index"];
    var maxindex = utils.getMaxIndex(oldindex);

    if ( !array_key_exists("specialtiles", GLB.options["config"]) ) {
        GLB.options["config"]["specialtiles"] = {};
    }
    GLB.options["config"]["specialtiles"][stype] = customcnt;

    // remove all special types of this type
    var n = stype.length + 1;
    for (var idx in oldindex) {
        if ( idx.substr(0,n) === stype + "|" ) {
            delete GLB.options["index"][idx];
        }
    }

    // add back in the requested number
    var theindex;
    for ( var i=0; i<customcnt; i++) {
        var k = (i + 1).toString();
        var fid = spid + k;
        var sidnum = stype + "|" + fid;
        if ( array_key_exists(sidnum, oldindex) ) {
            theindex = parseInt(GLB.options["index"][sidnum]);
            if ( theindex > maxindex ) {
                maxindex= theindex;
            }
        } else {
            maxindex++;
            theindex = maxindex;
        }
        GLB.options["index"][sidnum] = theindex;
    }

    return GLB.options;
}

// function hidden(pname, pvalue, id) {
//     var inpstr = "<input type='hidden' name='" + pname + "'  value='" + pvalue + "'";
//     if (id) { inpstr += " id='" + id + "'"; }
//     inpstr += " />";
//     return inpstr;
// }

// function getTypes() {
//     var thingtypes = [
//         "routine","switch", "light", "switchlevel", "bulb", "momentary","contact",
//         "motion", "lock", "thermostat", "temperature", "music", "audio", "valve",
//         "door", "illuminance", "smoke", "water",
//         "weather", "presence", "mode", "shm", "hsm", "piston", "other",
//         "clock", "blank", "image", "frame", "video", "custom", "control", "power"
//     ];
//     return thingtypes;
// }

// routine that renumbers all the things in your options file from 1
function refactorOptions() {

    // load in custom css strings
    var updatecss = false;
    var cnt = 0;
    var options = readOptions(true);
    var oldoptions = options;
    options["useroptions"] = utils.getTypes();
    options["things"] = {};
    options["index"] = {};
    var skin = getSkin();
    var customcss = readCustomCss(skin);

    // foreach ($oldoptions["index"] as $thingid => $idxarr) {
    for (var thingid in oldoptions["index"]) {
        var idxarr = oldoptions["index"][thingid];
        
        // only keep items that are in our current set of hubs
        if ( array_key_exists(thingid, allthings) ) {
        
            // removed the old system check since this is a new day for HP
            cnt++;
            var idx = idxarr.toString().trim();

            // replace all instances of the old "idx" with the new "cnt" in customtiles
            if ( customcss && idx!==cnt ) {
                $customcss = customcss.replace(".p_" + idx + ".", ".p_" + cnt + ".");
                $customcss = customcss.replace(".p_" + idx + " ", ".p_" + cnt + " ");

                $customcss = customcss.replace(".v_" + idx + ".", ".v_" + cnt + ".");
                $customcss = customcss.replace(".v_" + idx + " ", ".v_" + cnt + " ");

                $customcss = customcss.replace(".t_" + idx + ".", ".t_" + cnt + ".");
                $customcss = customcss.replace(".t_" + idx + " ", ".t_" + cnt + " ");

                $customcss = customcss.replace(".n_" + idx + ".", ".n_" + cnt + ".");
                $customcss = customcss.replace(".n_" + idx + " ", ".n_" + cnt + " ");

                updatecss = true;
            }

            // save the index number - fixed prior bug that only did this sometimes
            options["index"][thingid] = cnt;
        }
    }

    // now replace all the room configurations
    // this is done separately now which is much faster and less prone to error
    // foreach ($oldoptions["things"] as $room => $thinglist) {
    for (var room in oldoptions["things"]) {
        options["things"][room] = [];
        var thinglist = oldoptions["things"][room];
        thinglist.forEach( function(pidpos, key) {    
            var pid;
            var postop = 0;
            var posleft = 0;
            var zindex = 1;
            var customname = "";
            if ( is_array(pidpos) ) {
                var pid = parseInt(pidpos[0]);
                var postop = parseInt(pidpos[1]);
                var posleft = parseInt(pidpos[2]);
                if ( pidpos.length>3 ) {
                    zindex = parseInt(pidpos[3]);
                    customname = pidpos[4];
                }
            } else {
                pid = parseInt(pidpos);
            }

            var thingid = array_search(pid, oldoptions["index"]);
            
            if ( thingid!==false && array_key_exists(thingid, options["index"]) ) {
                var newid = $options["index"][thingid];
                // use the commented code below if you want to preserve any user movement
                // otherwise a refactor call resets all tiles to their baseeline position  
                // options["things"][room].push([newid,postop,posleft,zindex,customname]);
                options["things"][room].push([newid,0,0,1,customname]);
            }
        });
    }
    
    // now adjust all custom configurations
    for (var key in oldoptions) {
        
        var lines = oldoptions[key];
        var newlines;
        var calltype;
    
        if ( ( key.substr(0,5)==="user_" || key.substr(0,7)==="custom_" ) && is_array(lines) ) {
            
            // allow user to skip wrapping single entry in an array
            if ( !is_array(lines[0] ) ) {
                msgs = lines;
                calltype = msgs[0].toUpperCase().trim();
                if ( calltype==="LINK" ) {
                    var linkid = parseInt(msgs[1].trim());
                    var thingid = array_search(linkid, oldoptions["index"]);
                    if ( thingid!==false && array_key_exists(thingid, options["index"]) ) {
                        msgs[1] = options["index"][thingid];
                    }
                }
                newlines = msgs;
            } else {
                newlines = [];
                for (msgs in lines) {
                    calltype = msgs[0].toUpperCase().trim();

                    // switch to new index for links
                    // otherwise we just copy the info over to options
                    if ( calltype==="LINK" ) {
                        var linkid = parseInt(msgs[1].trim());
                        var thingid = array_search(linkid, oldoptions["index"]);
                        if ( thingid!==false && array_key_exists(thingid, options["index"]) ) {
                            msgs[1] = options["index"][thingid];
                        }
                    }
                    newlines.push(msgs);
                }
            }
            options[key] = newlines;
        }
    }
    
    // save our updated options and our custom style sheet file
    writeOptions(options);
    writeCustomCss(1, skin, customcss);
    
}

// emulates the PHP function for javascript objects or arrays
function array_search(needle, arr) {
    var key = false;
    needle = needle.toString();
    if ( is_object(arr) ) {
        try {
            for (var t in arr) {
                if ( arr[t]===needle || arr[t].toString() === needle ) {
                    return t;
                }
            } 
        }
        catch(e) { key = false; }
    }
    return key;
}

function in_array(needle, arr) {
    needle = needle.toString();
    if ( !is_object(arr) ) {
        return false;
    } else {
        for (var i in arr) {
            var item = arr[i];
            if ( item===needle || item.toString()===needle ) {
                return true;
            }
        }
        return false;
    }
}

function is_array(obj) {
    if ( typeof obj === "object" ) {
        return Array.isArray(obj);
    } else {
        return false;
    }
}

function is_object(obj) {
    return ( typeof obj === "object" );
}

function array_key_exists(key, arr) {
    if ( !is_object(arr) ) {
        return false;
    }
    return ( typeof arr[key] !== "undefined" );
}


// returns true if the index is in the room things list passed
function inroom($idx, $things) {
    var $found = false;
    var $idxint = parseInt($idx);
    for (var i in $things) {
        var $arr = $things[i];
        var $thingindex = is_array($arr) ? $arr[0] : parseInt($arr);
        if ( $idxint === $thingindex ) {
            $found = true;
            break;
        }
    }
    return $found;
}

// this is the main page rendering function
// each HousePanel tab is generated by this function call
// each page is contained within its own form and tab division
// notice the call of $cnt by reference to keep running count
function getNewPage(cnt, roomtitle, kroom, things, kioskmode) {
    var $tc = "";
    var roomname = roomtitle;
    $tc += "<div id=\"" + roomname + "-tab\">";
        $tc += "<form title=\"" + roomtitle + "\" action=\"#\">";
        
        // add room index to the id so can be style by number and names can duplicate
        // no longer use room number for id since it can change around
        // switched this to name - not used anyway other than manual custom user styling
        // if one really wants to style by room number use the class which includes it
        $tc += "<div id=\"panel-" + roomname + "\" title=\"" + roomtitle + "\" class=\"panel panel-" + kroom + " panel-" + roomname + "\">";

        // the things list can be integers or arrays depending on drag/drop
        var idxkeys = Object.keys(GLB.options["index"]);
        var idxvals = Object.values(GLB.options["index"]);
        things.forEach(function(kindexarr) {
            
            // get the offsets and the tile id
            var kindex = kindexarr[0];
            var postop = kindexarr[1];
            var posleft = kindexarr[2];
            var zindex = 1;
            var customname = "";

            if ( kindexarr.length > 3 ) {
                zindex = kindexarr[3];
                customname = kindexarr[4];
            }
            
            // get the index into the main things list
            
            // thingid = array_search(kindex, GLB.indexoptions);
            var idx;
            var i = idxvals.findIndex(idx => idx === kindex);
            var thingid = idxkeys[i];
            
            // if our thing is still in the master list, show it
            if (thingid && allthings[thingid]) {
                var thesensor = allthings[thingid];

                // keep running count of things to use in javascript logic
                cnt++;
                $tc += makeThing(cnt, kindex, thesensor, roomtitle, postop, posleft, zindex, customname, false);
            }
        });

        // end the form and this panel
        $tc += "</div></form>";

    // end this tab which is a different type of panel
    $tc +="</div>";
    return {tc: $tc, cnt: cnt};
}

// function to search for triggers in the name to include as classes to style
function processName(thingname, thingtype) {

    // get rid of 's and split along white space
    // but only for tiles that are not weather
    var subtype = "";
    if ( thingtype!=="weather") {
        var ignores = ["'s","*","<",">","!","{","}","-",".",",",":","+","&","%"];
        var ignore2 = ["routine","switch", "light", "switchlevel", "bulb", "momentary","contact",
                    "motion", "lock", "thermostat", "temperature", "music", "valve",
                    "illuminance", "smoke", "water",
                    "weather", "presence", "mode", "shm", "hsm", "piston", "other",
                    "clock", "blank", "image", "frame", "video", "custom", "control", "power"];
        var lowname = thingname.toLowerCase();
        var pattern = /[,;:!-\'\*\<\>\{\}\+\&\%]/g;
        var s1 = lowname.replace(pattern,"");
        var subopts = s1.split(" ");
        var k = 0;
        subopts.forEach(function(str) {
            str= str.trim();
            var numcheck = +str;
            if ( str.length>1 && ignore2.indexOf(str)===-1 && str!==thingtype && isNaN(numcheck) ) {
                if ( k < 3 ) {
                    subtype += " " + str;
                    k++;
                }
            }
        });
    }
    
    return [thingname, subtype];
}

function getWeatherIcon(num) {
    if ( isNaN(+num) ) {
        var iconstr = num;
    } else {
        num = num.toString();
        if ( num.length < 2 ) {
            num = "0" + num;
        }

        // uncomment this to use ST's copy. Default is to use local copy
        // so everything stays local
        // $iconimg = "https://smartthings-twc-icons.s3.amazonaws.com/" . $num . ".png";
        var iconimg = "media/weather/" + num + ".png";
        iconstr = "<img src=\"" + iconimg + "\" alt=\"" + num + "\" width=\"80\" height=\"80\">";
    }
    return iconstr;
}

function makeThing(cnt, kindex, thesensor, panelname, postop, posleft, zindex, customname, wysiwyg) {
    var $tc = "";
    
    var bid = thesensor["id"];
    var thingvalue = thesensor["value"];
    var thingtype = thesensor["type"];
    
    var hubnum = "-1";
    if ( array_key_exists("hubnum", thesensor) ) {
        hubnum = thesensor["hubnum"];
    }
    if ( array_key_exists("refresh", thesensor) ) {
        var refresh = thesensor["refresh"];
    } else {
        refresh = "normal";
    }

    var pnames = processName(thesensor["name"], thingtype);
    var thingname = pnames[0];
    var subtype = pnames[1];
//    if ( thingtype==="presence" ) {
//        console.log("name debug: ", thingname, " subtype= ", subtype, pnames);
//    }
    
    // if ( $thingtype==="control" ) { $subtype= " " . thesensor["name"]; }
    
    postop= parseInt(postop);
    posleft = parseInt(posleft);
    zindex = parseInt(zindex);;
    var idtag = "t-" + cnt;
    if ( wysiwyg ) {
        idtag = wysiwyg;
    }

    // set the custom name
    if ( customname ) { 
        thingvalue["name"] = customname;
    }

    // update fields with custom settings
    thingvalue = getCustomTile(thingvalue, thingtype, bid);

    // set the custom name
    // limit to 132 visual columns but show all for special tiles and custom names
    // now we use custom name in both places
    thingname = thingvalue["name"];
    var thingpr = thingname;
    if ( !customname && thingname && thingname.length > 132 && !array_key_exists(thingtype, utils.getSpecials()) ) {
        thingpr = thingname.substring(0,132) + " ...";
    }
    
    // wrap thing in generic thing class and specific type for css handling
    // IMPORTANT - changed tile to the saved index in the master list
    //             so one must now use the id to get the value of "i" to find elements
    $tc=   "<div id=\""+idtag+"\" hub=\""+hubnum+"\" tile=\""+kindex+"\" bid=\""+bid+"\" type=\""+thingtype+"\" ";
    $tc += "panel=\""+panelname+"\" class=\"thing "+thingtype+"-thing" + subtype + " p_"+kindex+"\" "; 
    $tc += "refresh=\""+refresh+"\"";
    if ( (postop!==0 && posleft!==0) || zindex>1 ) {
        $tc += " style=\"position: relative; left: "+posleft+"px; top: "+postop+"px; z-index: "+zindex+";\"";
    }
    $tc += ">";

    // special handling for weather tiles
    // this allows for feels like and temperature to be side by side
    // and it also handles the inclusion of the icons for status
    if (thingtype==="weather") {
        var weathername;
        if ( customname ) {
            weathername = customname;
        } else {
            if ( typeof thingpr==="undefined" ) { thingpr = "Weather"; }
            weathername = thingpr + "<br>" + thingvalue["city"];
        }
        $tc += "<div aid=\""+ cnt +"\" class=\"thingname " + thingtype + " t_" + kindex + "\" id=\"s-" + cnt + "\">";
        $tc += weathername;
        $tc += "</div>";
        $tc += putElement(kindex, cnt, 0, thingtype, thingvalue["name"], "name");
        $tc += putElement(kindex, cnt, 1, thingtype, thingvalue["city"], "city");
        $tc += "<div class=\"weather_temps\">";
        $tc += putElement(kindex, cnt, 2, thingtype, thingvalue["temperature"], "temperature");
        $tc += putElement(kindex, cnt, 3, thingtype, thingvalue["feelsLike"], "feelsLike");
        $tc += "</div>";
        
        // use new weather icon mapping
        $tc += "<div class=\"weather_icons\">";
        var wiconstr = getWeatherIcon(thingvalue["weatherIcon"]);
        var ficonstr = getWeatherIcon(thingvalue["forecastIcon"]);
        $tc += putElement(kindex, cnt, 4, thingtype, wiconstr, "weatherIcon");
        $tc += putElement(kindex, cnt, 5, thingtype, ficonstr, "forecastIcon");
        $tc += "</div>";
        $tc += putElement(kindex, cnt, 6, thingtype, "Sunrise: " + thingvalue["localSunrise"] + " Sunset: " + thingvalue["localSunset"], "sunriseset");
        $tc += putElement(kindex, cnt, 7, thingtype, thingvalue["localSunrise"], "localSunrise");
        $tc += putElement(kindex, cnt, 8, thingtype, thingvalue["localSunset"], "localSunset");
        
        var j = 9;
        for ( var tkey in thingvalue ) {
            if (tkey!=="temperature" &&
                tkey!=="feelsLike" &&
                tkey!=="city" &&
                tkey!=="weather" &&
                tkey!=="weatherIcon" &&
                tkey!=="forecastIcon" &&
                tkey!=="alertKeys" &&
                tkey!=="localSunrise" &&
                tkey!=="localSunset" ) 
            {
                var tval = thingvalue[tkey];
                $tc += putElement(kindex, cnt, j, thingtype, tval, tkey);
                j++;
            }
        };
        
    } else {

        // handle special tiles
        // TODO...
//        if ( array_key_exists(thingtype, specialtiles) ) 
//        {
//            $fn = $thingvalue["name"];
//            if ( array_key_exists("width", $thingvalue) ) {
//                $fw = $thingvalue["width"];
//            } else {
//                $fw = $specialtiles[$thingtype][1];
//            }
//            if ( array_key_exists("height", $thingvalue) ) {
//                $fh = $thingvalue["height"];
//            } else {
//                $fh = $specialtiles[$thingtype][2];
//            }
//            $thingvalue[$thingtype] = returnFile($fn, $fw, $fh, $thingtype );
//        }
//        if ( $thingtype==="music" ) {
//            $thingvalue = getMusicArt($thingvalue);
//        }
        
        $tc += "<div aid=\""+cnt+"\" type=\""+thingtype+"\" title=\""+thingpr+"\" class=\"thingname "+thingtype+" t_"+kindex+"\" id=\"s-"+cnt+"\">";
        $tc += thingpr;
        $tc += "</div>";
	
        // create a thing in a HTML page using special tags so javascript can manipulate it
        // multiple classes provided. One is the type of thing. "on" and "off" provided for state
        // for multiple attribute things we provide a separate item for each one
        // the first class tag is the type and a second class tag is for the state - either on/off or open/closed
        // ID is used to send over the groovy thing id number passed in as $bid
        // for multiple row ID's the prefix is a$j-$bid where $j is the jth row
        if (typeof thingvalue === "object") {
            var j = 0;
            var sibling = "";
            
            // check if there is a color key - use to set color
            // no longer print this first since we need to include in custom logic
            var bgcolor= "";
            if ( array_key_exists("color", thingvalue) ) {
                var cval = thingvalue["color"];
                if ( cval.match(/^#[abcdefABCDEF\d]{6}/) !== null ) {
                    bgcolor = " style=\"background-color:"+cval+";\"";
                }
            }
            
            // create on screen element for each key
            // this includes a check for helper items created in tile customizer
            for ( var tkey in thingvalue ) {
                var tval = thingvalue[tkey];
                
                // handle the new Sonos audio type which has a media type with details
                if ( thingtype==="audio" && tkey==="audioTrackData" ) {
                    var audiodata = JSON.parse(tval);
                    $tc += putElement(kindex, cnt, j,   thingtype, audiodata["title"], "trackDescription", "trackDescription", bgcolor);
                    $tc += putElement(kindex, cnt, j+1, thingtype, audiodata["artist"], "currentArtist", "currentArtist", bgcolor);
                    $tc += putElement(kindex, cnt, j+2, thingtype, audiodata["album"], "currentAlbum", "currentAlbum", bgcolor);
                    $tc += putElement(kindex, cnt, j+3, thingtype, audiodata["albumArtUrl"], "trackImage", "trackImage", bgcolor);
                    $tc += putElement(kindex, cnt, j+4, thingtype, audiodata["mediaSource"], "mediaSource", "mediaSource", bgcolor);
                    j = j+5;	
                }
                
                // print a hidden field for user web calls and links
                // this is what enables customization of any tile to happen
                // ::type::LINK::tval  or ::LINK::tval
                // this special element is not displayed and sits inside the overlay
                // we only process the non helpers and look for helpers in same list
                else if ( typeof tkey==="string" && tkey.substring(0,5)!=="user_" && (typeof tval==="string" || typeof tval==="number") && (typeof tval==="number" || tval.substr(0,2)!=="::") ) { 
                    
                    var helperkey = "user_" + tkey;
                    var helperval = thingvalue[helperkey];
                    if ( helperval && helperval.substr(0,2)==="::" ) {
                    
                        var ipos = helperval.indexOf("::",2);
                        var linktypeval = helperval.substring(0, ipos);
                        var jpos = linktypeval.indexOf("::",2);

                        // case with helperval = ::TEXT::val  &  linktypeval = ::val
                        var linktype;
                        var command;
                        var linkval;
                        if ( jpos===-1 ) { 
                            linktype = thingtype;
                            command = helperval.substring(2, ipos-2);
                            linkval = linktypeval.substring(2);

                        // case with tval = ::type::LINK::val &  linktypeval = ::LINK::val
                        } else {
                            linktype = helperval.substring(2, ipos-2);
                            command = linktypeval.substring(2, jpos-2);
                            linkval = linktypeval.substring(jpos+2);
                        }
                        // use the original type here so we have it for later
                        // but in the actual target we use the linktype
                        sibling= "<div linktype=\""+linktype+"\" value=\""+tval+"\" linkval=\""+linkval+"\" command=\""+command+"\" subid=\""+tkey+"\" class=\"user_hidden\"></div>";
                    } else {
                        linktype = thingtype;
                        sibling = "";
                    }

                    $tc += putElement(kindex, cnt, j, linktype, tval, tkey, subtype, bgcolor, sibling);
                    j++;
                }
            }
				
        } else {
            $tc += putElement(kindex, cnt, 0, thingtype, thingvalue, thingtype, subtype);
        }
    }
    $tc += "</div>";
    
    return $tc;
}

// cleans up the name of music tracks for proper html page display
// no longer trim the name because that breaks album art
function fixTrack(tval) {
    if ( !tval || tval.trim()==="" ) {
        tval = "None"; 
    }
    return tval;
}

function putElement(kindex, i, j, thingtype, tval, tkey, subtype, bgcolor, sibling) {
    var $tc = "";
    var aitkey = "a-" + i + "-" + tkey;
    var pkindex = " p_" + kindex;
    var aidi = "<div aid=\"" + i + "\"";
    var ttype = " type=\"" + thingtype + "\"";
    var colorval = "";
    if ( typeof subtype === "undefined" ) {
        subtype = "";
    } else if ( typeof subtype === "string" && subtype.substr(0,1)!==" " ) {
        subtype = " " + subtype;
    }
    if ( bgcolor && (tkey==="hue" || tkey==="saturation") ) {
        colorval = bgcolor;
    }
    if ( !tval ) { tval = ""; }
        
    // fix thermostats to have proper consistent tags
    // this is supported by changes in the .js file and .css file
    if ( tkey==="heat" || tkey==="cool" || tkey==="hue" || tkey==="saturation" ||
         tkey==="heatingSetpoint" || tkey==="coolingSetpoint" ) {
        
        // fix thermostats to have proper consistent tags
        // this is supported by changes in the .js file and .css file
        $tc += "<div class=\"overlay " + tkey + " " + subtype + " v_" + kindex + "\">";
        if (sibling) { $tc += sibling; }
        $tc += aidi + " subid=\"" + tkey + "-dn\" title=\"" + thingtype + " down\" class=\"" + thingtype + " " + tkey + "-dn" + pkindex + "\"></div>";
        $tc += aidi + " subid=\"" + tkey + "\" title=\"" + thingtype + " " + tkey + "\" class=\"" + thingtype + " " + tkey + pkindex + "\"" + colorval + " id=\"" + aitkey + "\">" + tval + "</div>";
        $tc += aidi + " subid=\"" + tkey + "-up\" title=\"" + thingtype + " up\" class=\"" + thingtype + " " + tkey + "-up" + pkindex + "\"></div>";
        $tc += "</div>";
    
    
    // process analog clocks signalled by use of a skin with a valid name other than digital
    } else if ( thingtype==="clock" && tkey==="skin" && tval && tval!=="digital" ) {
        $tc += "<div class=\"overlay "+tkey+" v_"+kindex+"\">";
        if (sibling) { $tc += sibling; }
        $tc += aidi + ttype + "\"  subid=\""+tkey+"\" title=\"Analog Clock\" class=\"" + thingtype + subtype + pkindex + "\" id=\""+aitkey+"\">" +
              "<canvas id=\"clock_"+i+"\" class=\""+tval+"\"></canvas></div>";
        $tc += "</div>";
    } else {
        // add state of thing as a class if it isn't a number and is a single word
        // also prevent dates and times from being added
        // also do not include any music album or artist names in the class
        // and finally if the value is complex with spaces or other characters, skip
        var extra;
        if ( tkey==="time" || tkey==="date" || tkey==="color" ||
                   (tkey.substr(0,6)==="event_") ||
                   tkey==="trackDescription" || tkey==="currentArtist" || 
                   tkey==="currentAlbum" || tkey==="trackImage" ||
                   tkey==="weatherIcon" || tkey==="forecastIcon" ||
                   !isNaN(+tval) || thingtype===tval || tval==="" || 
                   (tval.substr(0,5)==="track") || 
                   (tval.substr(0,7)==="number_") || 
                   (tval.substr(0,4)==="http") ||
                   (tval.indexOf(" ")!==-1) ) {
            extra = "";
        } else {
            extra = " " + tval;
        }
        
        // fix track names for groups, empty, and super long
        if (tkey==="trackDescription" || tkey==="track") {
            tval = fixTrack(tval);
        } else if (tkey==="trackImage") {
            if ( tval.substr(0,4) === "http" ) {
                tval = "<img width='120' height='120' src='" + tval + "'>";
            }
        } else if ( tkey === "battery") {
            var powmod = parseInt(tval);
            powmod = powmod - (powmod % 10);
            tval = "<div style=\"width: " + tval + "%\" class=\"ovbLevel L" + powmod.toString() + "\"></div>";
        }
        
        // for music status show a play bar in front of it
        // now use the real item name and back enable old one
        // note that we add the sibling to the music controls
        // so that linked tiles will operate properly
        // only one sibling for all the controls. The js file deals with this.
        if (tkey==="musicstatus" || (thingtype==="music" && tkey==="status") ) {
            $tc += "<div class=\"overlay music-controls" + subtype + " v_"+kindex+"\">";
            if (sibling) { $tc += sibling; }
            $tc += aidi + " subid=\"music-previous\" title=\"Previous\" class=\""+thingtype+" music-previous" + pkindex + "\"></div>";
            $tc += aidi + " subid=\"music-pause\" title=\"Pause\" class=\""+thingtype+" music-pause" + pkindex + "\"></div>";
            $tc += aidi + " subid=\"music-play\" title=\"Play\" class=\""+thingtype+" music-play" + pkindex + "\"></div>";
            $tc += aidi + " subid=\"music-stop\" title=\"Stop\" class=\""+thingtype+" music-stop" + pkindex + "\"></div>";
            $tc += aidi + " subid=\"music-next\" title=\"Next\" class=\""+thingtype+" music-next" + pkindex + "\"></div>";
            $tc += "</div>";
        }

        // ignore keys for single attribute items and keys that match types
        var tkeyshow;
        if ( (tkey===thingtype ) || 
             (tkey==="value" && j===0) ) {
            tkeyshow= "";
        // add confirm class for keys that start with c$_ so we can treat like buttons
        } else if ( tkey.substr(0,3) === "c__" ) {
            tkey = tkey.substr(3);
            tkeyshow = " " + tkey + " confirm";
        } else {
            tkeyshow = " " + tkey;
        }
        // include class for main thing type, the subtype, a sub-key, and a state (extra)
        // also include a special hack for other tiles that return number_ to remove that
        // this allows KuKu Harmony to show actual numbers in the tiles
        // finally, adjust for level sliders that can't have values in the content
        $tc += "<div class=\"overlay "+tkey+" v_"+kindex+"\">";
        if (sibling) { $tc += sibling; }
        if ( tkey === "level" || tkey==="colorTemperature" || tkey==="volume" || tkey==="groupVolume" ) {
            $tc += aidi + ttype + " subid=\""+tkey+"\" value=\""+tval+"\" title=\""+tkey+"\" class=\"" + thingtype + tkeyshow + pkindex + "\" " + aitkey + "\"></div>";
        } else if ( thingtype==="other" && tval.substr(0,7)==="number_" ) {
            var numval = tkey.substring(8);
            $tc += aidi + ttype + " subid=\"" + tkey+"\" title=\""+tkey+"\" class=\"" + thingtype + subtype + tkeyshow + pkindex + "\" " + aitkey + "\">" + numval + "</div>";
        } else {
            if ( typeof tval==="string" && tval.substr(0,6)==="RULE::" && subtype!=="rule" ) {
                tkeyshow += " rule";
            }
            $tc += "<div aid=\""+i+"\" type=\""+thingtype+"\"  subid=\""+tkey+"\" title=\""+tkey+"\" class=\"" + thingtype + subtype + tkeyshow + pkindex + extra + "\" id=\"" + aitkey + "\">" + tval + "</div>";
        }
        $tc += "</div>";
    }
    return $tc;
}

function getCustomCount(stype) {
    var customcnt = 0;
    if ( array_key_exists("specialtiles", GLB.config) ) {
        var specialarr = GLB.config["specialtiles"];
        if ( array_key_exists(stype, specialarr) ) {
            customcnt = parseInt(specialarr[stype]);
            if ( isNaN(customcnt) || customcnt < 1 ) { 
                customcnt = 0; 
            }
        }
    }
    return customcnt;
}

function getCustomName(defname, idx) {
    var rooms = GLB.options["rooms"];
    var thingoptions = GLB.options["things"];
    var tileid = GLB.options["index"][idx];
    for (var room in rooms) {
        if ( array_key_exists(room, thingoptions) ) {
           var things = thingoptions[room];
           for (var kindexarr in things) {
                 // if our tile matches and there is a custom name, use it
                if ( tileid===kindexarr[0] && kindexarr[4] ) {
                    return kindexarr[4];
                }
           }
        }
    }
    return defname;
}

function getClock(clockname, clockid, clockskin, fmtdate, fmttime) {
    var daynames = ["Sun", "Mon", "Tue", "Wed", "Thr", "Fri", "Sat", "Sun"];
    var clockname = getCustomName(clockname, "clock" + "|" + clockid);
    var d = new Date();
    var weekday = daynames[d.getDay()];
    var dateofmonth = d.toLocaleDateString();
    var timeofday = d.toLocaleTimeString();
    var timezone = d.getTimezoneOffset().toString();
    var dclock = {"name": clockname, "skin": clockskin, "weekday": weekday,
        "date": dateofmonth, "time": timeofday, "tzone": timezone,
        "fmt_date": fmtdate, "fmt_time": fmttime};
    dclock = getCustomTile(dclock, "clock", clockid);
    return dclock;
}

function addSpecials() {
    // set hub number to nothing for manually created tiles
    var hubnum = "-1";

    // add digital clock tile
    // never refresh since clocks have their own refresh timer built into the javascript code
    // you will need to over-ride this with the tile customizer if you add custom fields
    var clockidd = "clockdigital";
    var dclock = getClock("Digital Clock", clockidd, "", "M d, Y", "h:i:s A");
    allthings["clock|"+clockidd] = {"id" :  clockidd, "name" :  dclock["name"], 
        "hubnum" :  hubnum, "type" :  "clock", "refresh": "never", "value" :  dclock};

    // add analog clock tile - no longer use dclock format settings by default
    var clockida = "clockanalog";
    var aclock = getClock("Analog Clock", clockida, "CoolClock:swissRail:72", "M d, Y", "h:i:s A");
    allthings["clock|"+clockida] = {"id" :  clockida, "name" :  aclock["name"], 
        "hubnum" :  hubnum, "type" :  "clock", "refresh": "never", "value" :  aclock};

    // add special tiles based on type and user provided count
    // this replaces the old code that handled only video and frame tiles
    // this also creates image and blank tiles here that used to be made in groovy
    // putting this here allows them to be handled just like other modifiable tiles
    // these tiles all refresh fast except first 4 frames that are reserved for weather
    // renamed accuweather to forecast2 for simplicity sake and to make sorting work
    var specialtiles = utils.getSpecials();
    for (var stype in specialtiles) {
        var sid = specialtiles[stype];
        var speed = (stype==="frame") ? "slow" : "normal";
        var fcnt = getCustomCount(stype);
        for (var i=0; i<fcnt; i++) {

            var k = i + 1;
            k = k.toString();
            var fid = sid[0] + k;

            // the forecasts now must be in files frame1.html through frame4.html
            // or you can just change the name in the editor to a valid file
            var fw = sid[1];
            var fh = sid[2];
            var idx = stype + "|" + fid;
            var fn = getCustomName(stype + k, idx);
            var fval = fn;  // TODO... returnFile(fn, fw, fh, stype);
            var ftile = {"name": fn};
            ftile[stype] = fval;
            ftile["width"] = fw;
            ftile["height"] = fh;
            allthings[idx] = {"id":  fid, "name":  ftile["name"], "hubnum":  hubnum, 
                "type":stype, "refresh": speed, "value":  ftile};
        }
    }
    
    // create the controller tile
    // keys starting with c__ will get the confirm class added to it
    // this tile cannot be customized by the user due to its unique nature
    // but it can be visually styled just like any other tile
    var controlval = {"name": "Controller", "showoptions": "Options","refresh": "Refresh","c__refactor": "Reset",
                 "c__reauth": "Re-Auth","showid": "Show Info","toggletabs": "Toggle Tabs",
                 "showdoc": "Documentation",
                 "blackout": "Blackout","operate": "Operate","reorder": "Reorder","edit": "Edit"};
    allthings["control|control_1"] = {"id":  "control_1", "name":  controlval["name"], "hubnum":  hubnum, 
                "type":  "control", "refresh": "never", "value":  controlval};
}

function getAllThings(reset) {
    
    if ( reset ) {
        allthings = {};

        // add the special tiles
        addSpecials();
        updateOptions();

        // get all things from all configured servers
        GLB.hubs.forEach(function(hub) {
            var hubnum = hub["hubId"];
            var accesstoken  = hub["hubAccess"];
            var hubEndpt = hub["hubEndpt"];
            var clientId = hub["clientId"];
            var clientSecret = hub["clientSecret"];
            var hubName = hub["hubName"];
            var hubType = hub["hubType"];
            getDevices(hubnum, accesstoken, hubEndpt, clientId, clientSecret, hubName, hubType);
        });

    }
}

// create addon subid's for any tile
// this enables a unique customization effect
// the last parameter is only needed for LINK customizations
function getCustomTile(custom_val, customtype, customid) {
    
    var reserved = ["index","rooms","things","config","control","useroptions"];
    var idx = customtype + "|" + customid;
    var rooms = GLB.options["rooms"];
    var index = GLB.options["index"];
    var thingoptions = GLB.options["things"];
    var tileid = parseInt(GLB.options["index"][idx]);
    
    // get custom tile name if it was defined in tile editor and stored
    // in the room array
    var customname= "";
    for (var room in rooms) {
        if ( array_key_exists(room, thingoptions) ) {
            var things = thingoptions[room];
            for (var kindexarr in things) {
                // only do this if we have custom names defined in rooms
                if ( is_array(kindexarr) && kindexarr.length > 3 ) {
                    var kindex = kindexarr[0];

                    // if our tile matches and there is a custom name, use it
                    if ( kindex===tileid && kindexarr[4]!=="" ) {
                        customname = kindexarr[4];
                        break;
                    }
                }
            }
        }
    }
    
    if ( customname!=="" ) {
        custom_val["name"] = customname;
    }
    
    // see if a section for this id is in options file
    var lines = false;
    if (array_key_exists("user_" + customid, GLB.options) ) {
        lines = GLB.options["user_" + customid];
    } else if ( !in_array (customid, reserved) && array_key_exists(customid, GLB.options) ) {
        lines = GLB.options[customid];
    }

    // ignores = [" ","'","*","<",">","!","{","}","-",".",",",":","+","&","%"];
    if ( lines && is_array(lines) ) {
        
        // allow user to skip wrapping single entry in an array
        // the GUI will never do this but a user might in a manual edit
        if ( !is_array(lines[0]) ) {
            lines = [lines];
        }
        
        // first remove existing ones so we can readd them in the proper order
        lines.forEach(function(msgs) {
            var subidraw = msgs[2].trim();
            var subid = subidraw.replace(/[\"\*\<\>\!\{\}\.\,\:\+\&\%]/g,""); //  str_replace(ignores, "", subidraw);
            var companion = "user_" + subid;
            delete custom_val[subid];
            delete custom_val[companion];
        });
        
        // sort the lines and add them back in the requested order
        // replacements of default items will occur in default place
        // usort(lines, sortlinefunc);
        
        // loop through each item and add to tile
        lines.forEach(function(msgs) {

           
            // check to make sure we have an array of three long
            // this strict rule is followed to enforce discipline use
            if ( is_array(msgs) && msgs.length >= 3 ) {
            
                var calltype = msgs[0].toUpperCase().trim();
                var content = msgs[1].trim();
                var posturl = encodeURIComponent(content);
                var subidraw = msgs[2].trim();
                var subid = subidraw.replace(/[\"\*\<\>\!\{\}\.\,\:\+\&\%]/g,""); //  str_replace(ignores, "", subidraw);
                var companion = "user_" + subid;
    
                // process web calls made in custom tiles
                // this adds a new field for the URL or LINK information
                // in a tag called user_subid where subid is the requested field
                // web call results and linked values are stored in the subid field
                if ( content && content.toLowerCase().substr(0,4) === "http" &&
                     (calltype==="PUT" || calltype==="GET" || calltype==="POST")  )
                {
                    custom_val[companion] = "::" + calltype + "::" + posturl;
                    custom_val[subid] = calltype + ": " + subid;
               
                } else if ( calltype==="LINK" ) {
                    // code for enabling mix and match subid's into custom tiles
                    // this stores the tile number so we can quickly grab it upon actions
                    // this also allows me to find the hub number of the linked tile easily
                    // and finally, the linked tile is displayable at user's discretion
                    // for this to work the link info is stored in a new element that is hidden
                    var idx = array_search(content, index);
                    if ( allthings && idx!== false && array_key_exists(idx, allthings) ) {
                        var thesensor = allthings[idx];
                        var thevalue = thesensor["value"];
                        var thetype = thesensor["type"];
                
                        // if the subid exists in our linked tile add it
                        // this can replace existing fields with linked value
                        // if an error exists show text of intended link
                        // first case is if link is valid and not an existing field
                        if ( array_key_exists(subid, thevalue) ) {
                            custom_val[companion] = "::" + thetype + "::" + calltype + "::" + content;
                            custom_val[subid]= thevalue[subid];
                            
                        // final two cases are if link tile wasn't found
                        // first sub-case is if subid begins with the text of a valid key
                        } else {
                            // handle user provided names that start with a valid link subid
                            // and there is more beyond the start than numbers
                            var realsubid = false;
                            for (var key in custom_val) {
                                if ( key.indexOf(subid) === 0 ) {   // strpos(subid, key) === 0 ) {
                                    realsubid = key;
                                    break;
                                }
                            }
                            if ( realsubid ) {
                                custom_val[companion] = "::" + thetype + "::" + calltype + "::" + content;
                                custom_val[subid]= thevalue[realsubid];
                            } else {
                                custom_val[companion] = "::" + thetype + "::" + calltype + "::" + content;
                                custom_val[subid] = "Invalid link to tile #" + content + " with subid= " + subid;
                            }
                        }
                    } else {
                        custom_val[companion] = "::" + thetype + "::" + calltype + "::" + content;
                        custom_val[subid] = "Links unavailable to link #" + content + " with subid= " + subid + " idx= " + idx;
                        console.log("Links unavailable to link #" + content + " with subid= " + subid + " idx= " + idx);
                    }

                } else if ( calltype==="URL" ) {
                    custom_val[companion] = "::" + calltype + "::" + posturl;
                    custom_val[subid] = content;
               
                } else if ( calltype==="RULE" ) {
                    custom_val[companion] = "::" + calltype + "::" + content;
                    custom_val[subid] = "RULE::subid";

                } else {
                    // code for any user provided text string
                    // we could skip this but including it bypasses the hub call
                    // which is more efficient and safe in case user provides
                    // a subid that the hub might recognize - this way it is
                    // guaranteed to just pass the text on the browser
                    calltype = "TEXT";
                    custom_val[companion] = "::" + calltype + "::" + content;
                    custom_val[subid] = content;
                }
            }
        });
    }
    return custom_val;
}

function pushClient(swid, swtype, subid, body) {
    // send the new results to all clients
    var entry = {};
    if ( typeof subid === "undefined" ) { subid= ""; }
    entry["id"] = swid;
    entry["type"] = swtype;
    entry["clientcount"] = clients.length;
    entry["trigger"] = subid;
    var thevalue;

    if ( typeof body === "undefined" || body==="" || !body ) {
        thevalue = {};
    } else if ( typeof body === "string") {
        thevalue = JSON.parse(body);
    } else if ( typeof body === "object") {
        thevalue = body;
    } else {
        console.log("Warning - unrecognized body in hub push update: ", body);
        return;
    }

    if ( thevalue["password"] ) { delete thevalue["password"]; }
    if ( swtype==="music" ) {
        if ( thevalue["trackDescription"] ) { delete thevalue["trackDescription"]; }
        if ( thevalue["trackImage"] ) { delete thevalue["trackImage"]; }
        if ( thevalue["currentArtist"] ) { delete thevalue["currentArtist"]; }
        if ( thevalue["currentAlbum"] ) { delete thevalue["currentAlbum"]; }
    }
    entry["value"] = thevalue;

    // update the main array with changed push values
    var idx = swtype + "|" + swid;
    for (var thekey in thevalue) {
        allthings[idx]["value"][thekey] = thevalue[thekey];
    }

    for (var i=0; i < clients.length; i++) {
        entry["client"] = i+1;
        clients[i].sendUTF(JSON.stringify(entry));
    }

}

function callHub(hub, swid, swtype, swval, swattr, subid) {
    var access_token = hub["hubAccess"];
    var endpt = hub["hubEndpt"];
    if ( hub["hubType"]==="SmartThings" || hub["hubType"]==="Hubitat" ) {
        var host = endpt + "/doaction";
        var header = {"Authorization": "Bearer " + access_token};
        var nvpreq = {"swid": swid,  
                    "swattr": swattr,
                    "swvalue": swval, 
                    "swtype": swtype};
        if ( subid ) { nvpreq["subid"] = subid; }
        curl_call(host, header, nvpreq, false, "POST", getHubResponse);
    } else if ( hub["hubType"]==="ISY" ) {
        var buff = Buffer.from(access_token);
        var base64 = buff.toString('base64');
        var isyheader = {"Authorization": "Basic " + base64};
        var cmd;
        if ( subid==="level" ) {
            cmd = "/nodes/" + swid + "/cmd/DON/" + swval;
        } else {
            cmd = "/nodes/" + swid + "/cmd/" + swval;
        }
        console.log("sent cmd: ", cmd);
        curl_call(endpt + cmd, isyheader, false, false, "GET", getNodeResponse);

    }
    
    function getHubResponse(err, res, body) {
        // var response = body;
        if ( err ) {
            console.log("Error calling hub: ", err);
        } else {
            console.log("doAction: ", swid, swtype, subid, body);
            pushClient(swid, swtype, subid, body);
        }
    }

    function getNodeResponse(err, res, body) {
        if ( err ) {
            console.log("Error calling ISY node: ", err);
        } else {
            queryHub(hub, swid, swtype);
            // var result = parser.parse(body);
            // console.log("ISY action: ", result);
            // pushClient(swid, swtype, subid, result);
        }
    }

}

function queryHub(hub, swid, swtype) {
    var access_token = hub["hubAccess"];
    var endpt = hub["hubEndpt"];
if ( hub["hubType"]==="SmartThings" || hub["hubType"]==="Hubitat" ) {
        var host = endpt + "/doquery";
        var header = {"Authorization": "Bearer " + access_token};
        var nvpreq = {"swid": swid, "swtype": swtype};
        curl_call(host, header, nvpreq, false, "POST", getQueryResponse);
    } else if ( hub["hubType"]==="ISY" ) {
        var buff = Buffer.from(access_token);
        var base64 = buff.toString('base64');
        var header = {"Authorization": "Basic " + base64};
        var cmd = "/nodes/" + swid;
        curl_call(endpt + cmd, header, false, false, "GET", getNodeQueryResponse);
    }
    
    function getQueryResponse(err, res, body) {
        if ( err ) {
            console.log("Error requesting hub node properties: ", err);
        } else {
            console.log("doQuery: ", body);
            pushClient(swid, swtype, "none", body);
        }
    }

    function getNodeQueryResponse(err, res, body) {
        if ( err ) {
            console.log("Error requesting ISY node query: ", err);
        } else {
            var result = parser.parse(body);
            var properties = result.nodeInfo.properties;
            console.log("ISY query: ", result," properties: ", properties);
            // pushClient(swid, swtype, subid, result);
        }

    }

}

function findHub(hubid) {
    var hub = hubs[0];
    for (var h in hubs) {
        var ahub = hubs[h];
        if ( ahub["hubId"]===hubid ) { hub = ahub; }
    }
    return hub;
}

function doAction(hubid, swid, swtype, swval, swattr, subid, command, content, macro) {

    // get the hub being acted upon
    var response = "";
    var hub = findHub(hubid);
    var idx = swtype + "|" + swid;
    // console.log(hubid, hub);

    // handle clocks
    if ( (typeof command==="undefined" || command==="") && swid==="clockdigital") {
        response = getClock("Digital Clock", "clockdigital", "", "M d, Y", "h:i:s A");
    } else if ( (typeof command==="undefined" || command==="") && swid==="clockanalog" ) {
        response = getClock("Analog Clock", "clockanalog", "CoolClock:swissRail:72", "M d, Y", "h:i:s A");
    
    // handle types that just return the current status
    } else if (  (typeof command==="undefined" || command==="") && 
                 (swtype==="contact" || swtype==="presence" || swtype==="motion" || 
                  (swtype==="thermostat" && subid==="temperature") ||
                  swtype==="weather" || swtype==="temperature" || swtype==="blank") ) {
        response = allthings[idx]["value"];
        
    // this logic is complex so let me explain. First we get the value if available
    // then we get any provided custom name from tile editor
    // then we process all tile customizer settings which can also change the name
    // next we check customizer to see if name and width and height changed
    // finally, we send name, width, height to returnFile routine to get the html tag
    } else if ( command==="" && array_key_exists(swtype, specialtiles) ) {
        var thingvalue = allthings[idx]["value"];
        
        // thingvalue["name"] = getCustomName(thingvalue["name"], idx);
        // thingvalue = getCustomTile(thingvalue, swtype, swid);
        if ( array_key_exists("width", thingvalue) ) {
            fw = thingvalue["width"];
        } else {
            fw = specialtiles[swtype][1];
        }
        if ( array_key_exists("height", thingvalue) ) {
            fh = thingvalue["height"];
        } else {
            fh = specialtiles[swtype][2];
        }
        thingvalue[swtype] = returnFile(thingvalue["name"], fw, fh, swtype );
        response = thingvalue;
    } else {
        callHub(hub, swid, swtype, swval, swattr, subid);
        response = "success";
    }

    // while (!finished) { }
    return response;
}

function doQuery(hubid, swid, swtype) {
    var result;
    if ( swid==="all" && swtype==="all" && allthings ) {
        result = {};
        for (var idx in allthings) {
            var res = allthings[idx];
            var tileid = GLB.options["index"][idx];
            result[tileid] = res;
        }
    } else {
        var idx = swtype + "|" + swid;
        result = allthings[idx]["value"];
    }
    return result;
}

function setOrder(swid, swtype, swval, swattr) {
    var updated = false;
    var result = "error";
    var options = clone(GLB.options);

    // if the options file doesn't exist here something went wrong so skip
    if (options) {
        // now update either the page or the tiles based on type
        switch(swtype) {
            case "rooms":
                // $options["rooms"] = $swval;
                options["rooms"] = {};
                for (var roomname in swval) {
                    var roomid = parseInt(swval[roomname]);
                    options["rooms"][roomname] = roomid;
                }
                updated = true;
                break;

            case "things":
                if (array_key_exists(swattr, options["rooms"])) {
                    options["things"][swattr] = [];
                    swval.forEach(function(valarr) {
                        var val = parseInt(valarr[0]);
                        var vname = valarr[1];
                        var newthing = [val,0,0,1,vname];
                        options["things"][swattr].push(newthing);
                    });
                    updated = true;
                }
                break;
                
            default:
                $result = "error";
                break;
        }

        if (updated) {
            writeOptions(options);
            result = "success";
        }
    }
    
    return result;
}

function setPosition(swid, swtype, swval, swattr) {
    
    var updated = false;
    var options = GLB.options;
    var panel = swval["panel"];
    var tile = parseInt(swval["tile"]);
    
    // first find which index this tile is
    // note that this code will not work if a tile is duplicated on a page
    // such duplication is not allowed by the UI anyway but in the
    // event that a user edits hmoptions.cfg to have duplicates
    // the code will get confused here and in other places
    // $i = array_search($tile, $options["things"][$panel]);
    var moved = false;
    var idx;
    for ( var i in options["things"][panel]) {
        var arr = options["things"][panel][i];
        if ( is_array(arr) ) {
            idx = parseInt(arr[0]);
        } else {
            idx = parseInt(arr);
        }
        if ( tile === idx) {
            moved = i;
            updated = true;
            break;
        }
    }

    if ( updated && moved!==false ) {
        // change the room index to an array of tile, top, left
        // now we also save zindex and a tile custom name
        var top = parseInt(swattr["top"]);
        var left = parseInt(swattr["left"]);
        var zindex = parseInt(swval["zindex"]);
        var customname = "";
        if ( array_key_exists("custom", swval) ) {
            customname = swval["custom"];
        }
        var newtile = [tile, top, left, zindex, customname];
        options["things"][panel][moved] = newtile;
        writeOptions(options);
        var result = "success";
        console.log("new tile position for tile: ", tile," to: (", top, ",", left, ")");
    } else {
        result = "error";
        console.log("position for tile: ", tile," was not found to change");
    }
    return result;
    
}

function addThing(bid, thingtype, panel, cnt) {
    
    var idx = thingtype + "|" + bid;
    var options = GLB.options;
    var tilenum = parseInt(options["index"][idx]);
    var thesensor = allthings[idx];
    var tilename = thesensor["name"];
    
    // get the count number from the t- field
    try {
        cnt = parseInt(cnt);
    } catch(e) {
        console.log("error - cnt value is invalid: ", cnt);
        return "error";
    }

    var lastid = options["things"][panel].length - 1;
    var lastitem = options["things"][panel][lastid];

    var ypos = parseInt(lastitem[1]);
    var xpos = parseInt(lastitem[2]);
    var zindex = 1;
    if ( lastitem.length > 3 ) {
        zindex = parseInt(lastitem[3]);
    }

    // protect against off screen values
    if ( xpos < -400 || xpos > 400 || ypos < -400 || ypos > 400 ) {
        xpos = 0;
        ypos = 0;
    }
    
    // add it to our system in the requested room/panel
    options["things"][panel].push([tilenum, ypos, xpos, zindex, tilename]);
    writeOptions(options);
    
    // make a new tile based on the dragged information
    var thing = makeThing(cnt, tilenum, thesensor, panel, ypos, xpos, zindex, "", "");
    
    return thing;
}

function delThing(bid, thingtype, panel, tile) {
    
    var idx = thingtype + "|" + bid;
    var retcode = "error";
    
    if ( panel && array_key_exists(panel, GLB.options["things"]) &&
                   array_key_exists(idx, GLB.options["index"]) ) {

        var optionthings = GLB.options["things"][panel];

        // as a double check the options file tile should match
        // if it doesn't then something weird triggered drag drop
        // note - if there are duplicates the first one will be deleted
        var tilenum = parseInt(GLB.options["index"][idx]);
        if ( parseInt(tile) === tilenum ) {

            // remove tile from this room
            for (var key in optionthings) {
                var thing = optionthings[key];
                if ( (is_array(thing) && parseInt(thing[0]) === tilenum) ||
                     (!is_array(thing) && parseInt(thing) === tilenum) ) {

                    delete optionthings[key];
                    retcode = "success";
                    break;
                }
            }   

            if ( retcode === "success" ) {
                // options.things[panel] = array_values(options["things"][panel]);
                GLB.options["things"][panel] = [];
                optionthings.forEach(function(orderthing) {
                    GLB.options["things"][panel].push(orderthing);
                })
                console.log("success - deleted tile: ", tile, " with id: ", bid, " from room: ", panel);
                // console.log("new tiles: ", GLB.options["things"][panel]);
                // writeOptions(GLB.options);
            } else {
                console.log("error - could not safely delete tile: ", tile, " with id: ", bid, " from room: ", panel);
            }
        }
    }
    return retcode;
}

function delPage(pagename) {
    
    var options = GLB.options;
    var retcode;

    // check if room exists - ignore number matches
    if ( utils.count(options["rooms"]) <= 1 ) {
        retcode = "error - page= " + pagename + " is the only page remaining. Cannot delete the last page.";
    } else if ( array_key_exists(pagename, options["rooms"]) &&
                array_key_exists(pagename, options["things"]) ) {
        delete options["rooms"][pagename];
        delete options["things"][pagename];
        writeOptions(options);
        retcode = "success";
    } else {
        retcode = "error - cannot find page= " + pagename + " to delete.";
    }
    return retcode;
}

function addPage() {
    var pagenum = 0;
    var options = GLB.options;
    
    // get the largest room number
    for ( var roomname in options["rooms"] ) {
        var roomnum = parseInt(options["rooms"][roomname]);
        pagenum = roomnum > pagenum ? roomnum : pagenum;
    }
    pagenum++;

    // get new room default name in sequential order
    var newname = "Newroom1";
    var num = 1;
    while ( array_key_exists(newname, options["rooms"]) ) {
        $num++;
        $newname = "Newroom" + num.toString();
    }
    options["rooms"][newname] = pagenum;
    
    // put a digital clock in all new rooms so they are not empty
    var clockid = options["index"]["clock|clockdigital"];
    var clock = [clockid, 0, 0, 1, ""];
    options["things"][newname] = [clock];

    writeOptions(options);
    return newname;
}

function getInfoPage(returnURL, pathname) {

    var configoptions = GLB.options["config"];
    var skin = configoptions["skin"];
    var hubs = configoptions["hubs"];
    var specialtiles = utils.getSpecials();
    
    var $tc = "";
    $tc += utils.getHeader("skin-housepanel");
    $tc += "<h3>" + utils.APPNAME + " Information Display</h3>";

    $tc += "<form>";
    $tc += utils.hidden("returnURL", returnURL);
    $tc += utils.hidden("pathname", pathname);
    $tc += utils.hidden("pagename", "info");
    $tc += "</form>";
    $tc += "<div class=\"infopage\">";
    $tc += "<div class='bold'>Site url = " + returnURL + "</div>";
    $tc += "<div class='bold'>Skin folder = " + skin + "</div>";
    $tc += "<div class='bold'>" + hubs.length + " Hubs active</div>";
    $tc += "<hr />";
    
    var num = 0;
    hubs.forEach (function(hub) {
        // putStats(hub);
        var hubType = hub["hubType"];
        var hubName = hub["hubName"];
        var hubHost = hub["hubHost"];
        var hubId = hub["hubId"];
        var clientId = hub["clientId"];
        var clientSecret = hub["clientSecret"];
        var access_token = hub["hubAccess"];
        var endpt = hub["hubEndpt"];
        $tc += "<div class='bold'>Hub #" + num + "</div>";
        $tc += "<div class='bold'>Hub Name = " + hubName + "</div>";
        $tc += "<div>Type = " + hubType + "</div>";
        $tc += "<div>Hub ID = " + hubId + "</div>";
        $tc += "<div>Hub Host URL = " + hubHost + "</div>";
        $tc += "<div>Client ID = " + clientId + "</div>";
        $tc += "<div>Client Secret = " + clientSecret + "</div>";
        $tc += "<div>AccessToken = " + access_token + "</div>";
        $tc += "<div>Endpoint = " + endpt + "</div>";
        if ( (num + 1) < hubs.length ) {
            $tc += "<hr />";
        }
        num++;
    });

    $tc += "</div>";
    
    $tc += "<button class=\"showhistory\">Show Dev Log</button>";
    $tc += "<div id=\"devhistory\" class=\"infopage hidden\">";
    $tc += "<pre>" + utils.DEV + "</pre>";
    $tc += "</div>";
    
    $tc += "<br><br><h3>List of Authorized Things</h3>";
    $tc += "<table class=\"showid\">";
    $tc += "<thead><tr><th class=\"thingname\">Name</th><th class=\"thingarr\">Value Array" + 
        "</th><th class=\"infotype\">Type" + 
        "</th><th class=\"infoid\">Thing id" +
        "</th><th class=\"hubid\">Hub" +
        "</th><th class=\"infonum\">Tile Num</th></tr></thead>";

    for (var bid in allthings) { // as $bid => $thing) {
        var thing = allthings[bid];
        var value = "";
        if ( is_object(thing["value"]) ) {
            for (var key in thing["value"] ) {
                var val = thing["value"][key];
                if ( array_key_exists(key, specialtiles) ) {
                    value += key + "= <strong>embedded " + key + "</strong><br/>";
                } else if ( thing["type"]==="custom" && typeof val==="object" ) { 
                    value += "Custom Array..."; 
                } else if ( typeof val==="object" ) {
                    value += key + "=" + JSON.stringify(val);
                } else if ( typeof val === "string" && val.length > 128 ) {
                    val = val.substr(0,124) + " ...";
                    value += key + "=" + val + "<br/>";
                } else if ( typeof val==="string" ) {
                    value += key + "=" + val;
                } else {
                    value += key + "=" + val.toString();
                }
            }
        } else {
            value = thing["value"];
            if ( value.length > 128 ) {
                value = value.substr(0,124) + " ...";
            }
        }
        // limit size of the field shown
        
        var hubnum = thing["hubnum"];
        if ( hubnum === -1 || hubnum === "-1" ) {
            var hubstr = "None<br><span class=\"typeopt\"> (" + hubnum + ": None)</span>";
        } else {
            var hub = findHub(hubnum);
            var hubType = hub["hubType"];
            var hubName = hub["hubName"];
            var hubstr = hubName + "<br><span class=\"typeopt\"> (" + hubnum + ": " + hubType + ")</span>";
        }
        
        $tc += "<tr><td class=\"thingname\">" + thing["name"] +
            "</td><td class=\"thingarr\">" + value +
            "</td><td class=\"infotype\">" + thing["type"] +
            "</td><td class=\"infoid\">" + thing["id"] +
            "</td><td class=\"hubid\">" + hubstr + 
            "</td><td class=\"infonum\">" + GLB.options["index"][bid] + "</td></tr>";
    }
    $tc += "</table>";
    $tc += "<button class=\"infobutton fixbottom\">Return to HousePanel</button>";

    $tc += utils.getFooter();
    return $tc;
}

function hubFilters(hubpick, ncols) {
    var $options = GLB.options;
    var $useroptions = $options["useroptions"];
    var $configoptions = $options["config"];
    var $hubs = $configoptions["hubs"];
    var $thingtypes = utils.getTypes();

    var retpage = GLB.returnURL;
    var $tc = "";
    $tc+= "<form id=\"filteroptions\" class=\"options\" name=\"filteroptions\" action=\"" + retpage + "\"  method=\"POST\">";
    
    // if more than one hub then let user pick which one to show
    var hubpick = "all";
    if ( $configoptions["hubpick"] ) {
        hubpick = $configoptions["hubpick"];
    }
    if ( utils.count($hubs) > 1 ) {
        $tc+= "<div class=\"filteroption\">Hub Filters: ";
        var $hid = "hopt_all";
        var checked = (hubpick==="all") ? " checked='1'" : "";
        $tc+= "<div class='radiobutton'><input id='" + $hid + "' type='radio' name='huboptpick' value='all'"  + checked + "><label for='" + $hid + "'>All Hubs</label></div>";
        $hid = "hopt_none";
        checked = (hubpick==="none") ? " checked='1'" : "";
        $tc+= "<div class='radiobutton'><input id='" + $hid + "' type='radio' name='huboptpick' value='none'" + checked + "><label for='" + $hid + "'>No Hub</label></div>";
        var $hubcount = 0;
        $hubs.forEach(function($hub) {
            var $hubName = $hub["hubName"];
            var $hubType = $hub["hubType"];
            var $hubId = $hub["hubId"];
            $hid = "hopt_" + $hubcount;
            checked = (hubpick===$hubId) ? " checked='1'" : "";
            $tc+= "<div class='radiobutton'><input id='" + $hid + "' type='radio' name='huboptpick' value='" + $hubId + "'" + checked + "><label for='" + $hid + "'>" + $hubName + " (" + $hubType + ")</label></div>";
            $hubcount++;
        });
        $tc+= "</div>";
    }

    // buttons for all or no filters
    $tc+= "<br /><div class=\"filteroption\">Thing Filters: ";
    $tc+= "<div id=\"allid\" class=\"smallbutton\">All</div>";
    $tc+= "<div id=\"noneid\" class=\"smallbutton\">None</div>";
    $tc+= "</div>";

    $tc+= "<div class='filteroption'>Select Things to Display: <br/>";
    $tc+= "<table class=\"useroptions\"><tr>";
    var $i= 0;
    for (var $iopt in $thingtypes) {
        var $opt = $thingtypes[$iopt];
        $i++;
        if ( in_array($opt, $useroptions ) ) {
            $tc+= "<td><input id=\"cbx_" + $i + "\" type=\"checkbox\" name=\"useroptions[]\" value=\"" + $opt + "\" checked=\"1\">";
        } else {
            $tc+= "<td><input id=\"cbx_" + $i + "\" type=\"checkbox\" name=\"useroptions[]\" value=\"" + $opt + "\">";
        }
        $tc+= "<label for=\"cbx_" + $i + "\" class=\"optname\">" + $opt + "</label></td>";
        if ( $i % ncols == 0 && $i < utils.count($thingtypes) ) {
            $tc+= "</tr><tr>";
        }
    }
    $tc+= "</tr></table>";
    $tc+= "</div><hr>";
    $tc+= "</form>";

    return $tc;
}

function getCatalog(hubpick) {

    var $tc = "";
    var useroptions = GLB.options["useroptions"];
    $tc += "<div id=\"catalog\">";
    $tc += hubFilters(hubpick, 2);
    var i= 0;

    for(var idx in allthings) {
        var thesensor = allthings[idx];
        var bid = thesensor["id"];
        var thingtype = thesensor["type"];
        var thingname = thesensor["name"];
        var hubId = thesensor["hubnum"].toString();
        var cat = "cat-" + i.toString();
        if ( hubId==="-1" ) {
            hubId = "none";
        }

        if ( thingname.length > 23 ) {
            var thingpr = thingname.substr(0,23) + " ...";
        } else {
            thingpr = thingname;
        }
        
        if (in_array(thingtype, useroptions) && (hubpick===hubId || hubpick==="all")) {
            var hide = "";
        } else {
            hide = "hidden ";
        }

        $tc += "<div id=\"" + cat + "\" bid=\"" + bid + "\" type=\"" + thingtype + "\" hubid=\"" + hubId + "\" ";
        $tc += "panel=\"catalog\" class=\"thing " + hide + "catalog-thing\">"; 
        $tc += "<div class=\"thingname\">" + thingpr + "</div>";
        $tc += "<div class=\"thingtype\">" + thingtype + "</div>";
        $tc +="</div>";
        i++;
    }
    $tc += "</div>";
    return $tc;
}

function getOptionsPage(pathname) {
    var retpage = GLB.returnURL;
    var $thingtypes = utils.getTypes();
    var $specialtiles = utils.getSpecials();
    // sort($thingtypes);

    var $options = GLB.options;
    var $roomoptions = $options["rooms"];
    var $thingoptions = $options["things"];
    var $indexoptions = $options["index"];
    var $useroptions = $options["useroptions"];
    var $configoptions = $options["config"];
    var $hubs = $configoptions["hubs"];
    var $skin = getSkin();
    var $port = $configoptions["port"];
    var $webSocketServerPort = $configoptions["webSocketServerPort"];
    var $fast_timer = $configoptions["fast_timer"];
    var $slow_timer = $configoptions["slow_timer"];
    var $kioskoptions = $configoptions["kiosk"];
    var $ruleoptions = $configoptions["rules"];
    var $timezone = $configoptions["timezone"];

    var hubpick = "all";
    if ( $configoptions["hubpick"] ) {
        hubpick = $configoptions["hubpick"];
    }
    
    var $tc = "";
    $tc += utils.getHeader($skin);
    $tc += "<h3>" + utils.APPNAME + " Options</h3>";
    $tc += "<div class=\"formbutton formauto\"><a href=\"" + retpage + "\">Cancel and Return to HousePanel</a></div>";
    $tc += "<div id=\"optionstable\" class=\"optionstable\">";

    $tc += "<form name=\"pageoptions\" action=\"#\"  method=\"POST\">";
    $tc += utils.hidden("returnURL", retpage);
    $tc += utils.hidden("pathname", pathname);
    $tc += utils.hidden("pagename", "options");
    $tc += "</form>";

    $tc += hubFilters(hubpick, 7);

    // ---------------------------- start of filters -----------------------------------

    // $tc+= "<form id=\"filteroptions\" class=\"options\" name=\"filteroptions\" action=\"" + retpage + "\"  method=\"POST\">";
    
    // // if more than one hub then let user pick which one to show
    // if ( utils.count($hubs) > 1 ) {
    //     $tc+= "<div class=\"filteroption\">Hub Filters: ";
    //     var $hid = "hopt_all";
    //     var checked = (hubpick==="all") ? " checked='1'" : "";
    //     $tc+= "<div class='radiobutton'><input id='" + $hid + "' type='radio' name='huboptpick' value='all'"  + checked + "><label for='" + $hid + "'>All Hubs</label></div>";
    //     $hid = "hopt_none";
    //     checked = (hubpick==="none") ? " checked='1'" : "";
    //     $tc+= "<div class='radiobutton'><input id='" + $hid + "' type='radio' name='huboptpick' value='none'" + checked + "><label for='" + $hid + "'>No Hub</label></div>";
    //     var $hubcount = 0;
    //     $hubs.forEach(function($hub) {
    //         var $hubName = $hub["hubName"];
    //         var $hubType = $hub["hubType"];
    //         var $hubId = $hub["hubId"];
    //         $hid = "hopt_" + $hubcount;
    //         checked = (hubpick===$hubId) ? " checked='1'" : "";
    //         $tc+= "<div class='radiobutton'><input id='" + $hid + "' type='radio' name='huboptpick' value='" + $hubId + "'" + checked + "><label for='" + $hid + "'>" + $hubName + " (" + $hubType + ")</label></div>";
    //         $hubcount++;
    //     });
    //     $tc+= "</div>";
    // }

    // // buttons for all or no filters
    // $tc+= "<br /><div class=\"filteroption\">Thing Filters: ";
    // $tc+= "<div id=\"allid\" class=\"smallbutton\">All</div>";
    // $tc+= "<div id=\"noneid\" class=\"smallbutton\">None</div>";
    // $tc+= "</div>";

    // $tc+= "<div class='filteroption'>Select Things to Display: <br/>";
    // $tc+= "<table class=\"useroptions\"><tr>";
    // var $i= 0;
    // for (var $iopt in $thingtypes) {
    //     var $opt = $thingtypes[$iopt];
    //     $i++;
    //     if ( in_array($opt, $useroptions ) ) {
    //         $tc+= "<td><input id=\"cbx_" + $i + "\" type=\"checkbox\" name=\"useroptions[]\" value=\"" + $opt + "\" checked=\"1\">";
    //     } else {
    //         $tc+= "<td><input id=\"cbx_" + $i + "\" type=\"checkbox\" name=\"useroptions[]\" value=\"" + $opt + "\">";
    //     }
    //     $tc+= "<label for=\"cbx_" + $i + "\" class=\"optname\">" + $opt + "</label></td>";
    //     if ( $i % 5 == 0 && $i < utils.count($thingtypes) ) {
    //         $tc+= "</tr><tr>";
    //     }
    // }
    // $tc+= "</tr></table>";
    // $tc+= "</div><hr>";
    // $tc+= "</form>";

    // ---------------------------- end of filters -----------------------------------

    $tc+= "<form id=\"optionspage\" class=\"options\" name=\"options\" action=\"" + retpage + "\"  method=\"POST\">";

    // $tc+= "<div class=\"filteroption\">";
    // $tc+= tsk($timezone, $skin, $uname, $port, $webSocketServerPort, $fast_timer, $slow_timer);
    // $tc+= "</div>";

    $tc+= "<div class=\"filteroption\">Specify number of special tiles: ";
    for (var $stype in $specialtiles) {
        var $customcnt = getCustomCount($stype);
        var $stypeid = "cnt_" + $stype;
        $tc+= "<br /><label for=\"$stypeid\" class=\"kioskoption\"> " + $stype +  " tiles: </label>";
        $tc+= "<input class=\"specialtile\" id=\"" + $stypeid + "\" name=\"" + $stypeid + "\" width=\"10\" type=\"number\"  min='0' max='99' step='1' value=\"" + $customcnt + "\" />";
    }
    $tc+= "</div>";

    $tc+= "<div class=\"filteroption\">Other options: <br/>";
    $tc+= "<label for=\"kioskid\" class=\"kioskoption\">Kiosk Mode: </label>";    
    var $kstr = ($kioskoptions===true || $kioskoptions==="true" || $kioskoptions==="1" || $kioskoptions==="yes") ? "checked" : "";
    $tc+= "<input id=\"kioskid\" width=\"24\" type=\"checkbox\" name=\"kiosk\"  value=\"" + $kioskoptions + "\" " + $kstr + "/>";
    
    $tc+= "<label for=\"ruleid\" class=\"kioskoption\">Enable Rules? </label>";
    var $rstr = ($ruleoptions===true || $ruleoptions==="true" || $ruleoptions==="1" || $ruleoptions==="yes") ? "checked" : "";
    $tc+= "<input id=\"ruleid\" width=\"24\" type=\"checkbox\" name=\"rules\"  value=\"" + $ruleoptions + "\" " + $rstr + "/>";
    $tc+= "</div>";

    var $accucity = $configoptions["accucity"];
    var $accuregion = $configoptions["accuregion"];
    var $accucode = $configoptions["accucode"];      // ann-arbor-mi code is 329380
    $tc+= "<div class=\"filteroption\"><label for=\"accucityid\" class=\"kioskoption\">Accuweather City: <input id=\"accucityid\" width=\"180\" ";
    $tc+= "type=\"text\" name=\"accucity\"  value=\"" + $accucity + "\" />";
    $tc+= "<label for=\"accuregionid\" class=\"kioskoption\">Region: <input id=\"accuregionid\" width=\"6\" type=\"text\" name=\"accuregion\"  value=\"" + $accuregion + "\"/>";
    $tc+= "<label for=\"accucodeid\" class=\"kioskoption\">Code: <input id=\"accucodeid\" width=\"40\" type=\"text\" name=\"accucode\"  value=\"" + $accucode + "\"/>";
    $tc+= "</div>";
    
    $tc+= "<br /><br />";
    $tc+= "<table class=\"headoptions\"><thead>";
    $tc+= "<tr><th class=\"thingname\">Thing Name (type)</th>";
    $tc+= "<th class=\"hubname\">Hub</th>";
   
    // list the room names in the proper order
    // for ($k=0; $k < count($roomoptions); $k++) {
    for (var $roomname in $roomoptions) {
        $tc+= "<th class=\"roomname\">" + $roomname;
        $tc+= "</th>";
    }
    $tc+= "</tr></thead>";
    $tc+= "</table>";
    $tc+= "<div class='scrollvtable'>";
    $tc+= "<table class=\"roomoptions\">";
    $tc+= "<tbody>";

    // sort the things
    // uasort($allthings, "mysortfunc");
    
    // now print our options matrix
    // $rowcnt = 0;
    var $evenodd = true;
    var $hub;
    for (var $thingid in allthings) {
        var $thesensor = allthings[$thingid];
        // if this sensor type and id mix is gone, skip this row
        
        var $thingname = $thesensor["name"];
        var $thetype = $thesensor["type"];
        var $hubnum = $thesensor["hubnum"];
        if ( $hubnum === -1 || $hubnum==="-1" ) {
            $hub = null;
            var $hubType = "None";
            var $hubStr = "None";
            var $hubId = "none";
        } else {
            $hub = findHub($hubnum);
            $hubType = $hub["hubType"];
            $hubStr = $hub["hubName"];
            $hubId = $hub["hubId"];
        }

        // get the tile index number
        var $thingindex = $indexoptions[$thingid].toString();
        
        // write the table row
        if ( array_key_exists($thetype, $specialtiles) ) {
            var $special = " special";
        } else {
            $special = "";
        }
        var $odd = $evenodd = false;
        if (in_array($thetype, $useroptions)) {
            $evenodd = !$evenodd;
            $evenodd ? $odd = " odd" : $odd = "";
            $tc+= "<tr type=\"" + $thetype + "\" tile=\"" + $thingindex + "\" class=\"showrow" + $odd + $special + "\">";
        } else {
            $tc+= "<tr type=\"" + $thetype + "\" tile=\"" + $thingindex + "\" class=\"hiderow" + $special + "\">";
        }
        
        $tc+= "<td class=\"thingname\">";
        $tc+= $thingname + "<span class=\"typeopt\"> (" + $thetype + ")</span>";
        $tc+= "</td>";
        
        $tc+= "<td class=\"hubname\" hubId=\"" + $hubId + "\">";
        $tc+= $hubStr + " (" + $hubType + ")";
        $tc+= "</td>";

        // loop through all the rooms
        // this addresses room bug
        for ( var $roomname in $roomoptions ) {
            
            // get the name of this room for this column
            // $roomname = array_search($k, $roomoptions);
            // $roomlist = array_keys($roomoptions, $k);
            // $roomname = $roomlist[0];
            if ( array_key_exists($roomname, $thingoptions) ) {
                var $things = $thingoptions[$roomname];
                                
                // now check for whether this thing is in this room
                $tc+= "<td>";
                
                var $ischecked = false;
                var $idx;
                for (var i in $things) {
                    var $arr = $things[i];
                    if ( is_array($arr) ) {
                        $idx = $arr[0].toString();
                    } else {
                        $idx = $arr.toString();
                    }
                    if ( $idx === $thingindex ) {
                        $ischecked = true;
                        break;
                    }
                }
                
                if ( $ischecked ) {
                    $tc+= "<input type=\"checkbox\" name=\"" + $roomname + "[]\" value=\"" + $thingindex + "\" checked=\"1\" >";
                } else {
                    $tc+= "<input type=\"checkbox\" name=\"" + $roomname + "[]\" value=\"" + $thingindex + "\" >";
                }
                $tc+= "</td>";
            }
        }
        $tc+= "</tr>";
    }

    $tc+= "</tbody></table>";
    $tc+= "</div>";
    $tc+= "<div id='optionspanel' class=\"processoptions\">";
    $tc +='<div id="optSave" class="formbutton">Save</div>';
    $tc +='<div id="optReset" class="formbutton">Reset</div>';
    $tc +='<div id="optCancel" class="formbutton">Cancel</div><br>';
    $tc+= "</div>";
    $tc+= "</form>";
    $tc+= "</div>";

    $tc += utils.getFooter();

    return $tc;
}

// renders the main page
function mainPage(proto, hostname, pathname) {
    var $tc = "";

    var thingoptions = GLB.options["things"];
    var roomoptions = GLB.options["rooms"];
    var skin = getSkin();
    var kioskmode = GLB.config["kiosk"];
    if ( kioskmode === "true" || kioskmode===1 || kioskmode==="yes" ) {
        kioskmode = true;
    } else {
        kioskmode = false;
    }
    GLB.returnURL = proto + "://" + hostname

    $tc += utils.getHeader(skin);

    if ( DEBUG2 ) {
        console.log(GLB.options);
    }
    // make sure our active skin has a custom file
    if ( !fs.existsSync(skin + "/customtiles.css") ) {
        writeCustomCss(1, skin, "");
    }
    
    // new wrapper around catalog and things but excluding buttons
    $tc += '<div id="dragregion">';
    $tc += '<div id="tabs"><ul id="roomtabs">';

    // show all room with whatever index number assuming unique
    for (var room in roomoptions) {
        var k = roomoptions[room];
        if ( thingoptions[room] ) {
            var adder= "<li roomnum=\"" + k + "\" class=\"tab-" + room + "\"><a href=\"#" + room + "-tab\">" + room + "</a></li>";
            $tc += adder;
        }
    }
    $tc += '</ul>';

    // changed this to show rooms in the order listed
    // this is so we just need to rewrite order to make sortable permanent
    var cnt = 0;
    for (var room in roomoptions) {
        var k = roomoptions[room];
        if ( thingoptions[room] ) {
            var things = thingoptions[room];
            var pgobj = getNewPage(cnt, room, k, things, kioskmode);
            $tc += pgobj.tc;
            cnt = pgobj.cnt;
        }
    }

    // include doc button and username that is logged in
    var uname = getUserName();
    $tc += '<div id="showversion" class="showversion">';
    $tc += '<span id="infoname">' + uname + "</span><span> - V" + utils.HPVERSION + '</span>';
    $tc += '<div id="showdocs"><a href="http://www.housepanel.net" target="_blank">?</a></div>';
    $tc += "</div>";

    // end of the tabs
    $tc += "</div>";

    // end drag region enclosing catalog and main things
    $tc += "</div>";

    // set the websock servername as same as hosted page but different port
    var webSocketUrl = "";
    if ( GLB.config.webSocketServerPort && !isNaN(parseInt(GLB.config.webSocketServerPort)) ) {
        var icolon = hostname.indexOf(":");
        if ( icolon >= 0 ) {
            webSocketUrl = "ws://" + hostname.substr(0, icolon);
        } else {
            webSocketUrl = "ws://" + hostname;
        }
        webSocketUrl = webSocketUrl + ":" + GLB.config.webSocketServerPort;
    }
    
    // include form with useful data for js operation
    $tc += "<form id='kioskform'>";
    $tc += utils.hidden("pagename", "main");

    // save the socket address for use on js side
    // var webSocketUrl = GLB.config.webSocketServerPort ? ("ws://" + serverName + ":" + GLB.config.webSocketServerPort) : "";
    $tc += utils.hidden("webSocketUrl", webSocketUrl);

    // save Node.js address for use on the js side
    $tc += utils.hidden("returnURL", GLB.returnURL);
    $tc += utils.hidden("pathname", pathname);
    $tc += utils.hidden("skinid", skin, "skinid");

    // show user buttons if we are not in kiosk mode
    if ( !kioskmode ) {
        $tc += "<div id=\"controlpanel\">";
        $tc +='<div id="showoptions" class="formbutton">Options</div>';
        $tc +='<div id="refresh" class="formbutton">Refresh</div>';
        $tc +='<div id="refactor" class="formbutton confirm">Reset</div>';
        $tc +='<div id="reauth" class="formbutton confirm">Hub Auth</div>';
        $tc +='<div id="showid" class="formbutton">Show Info</div>';
        $tc +='<div id="toggletabs" class="formbutton">Hide Tabs</div>';
        $tc +='<div id="blackout" class="formbutton">Blackout</div>';

        $tc += "<div class=\"modeoptions\" id=\"modeoptions\"> \
          <input id=\"mode_Operate\" class=\"radioopts\" type=\"radio\" name=\"usemode\" value=\"operate\" checked><label for=\"mode_Operate\" class=\"radioopts\">Operate</label> \
          <input id=\"mode_Reorder\" class=\"radioopts\" type=\"radio\" name=\"usemode\" value=\"reorder\" ><label for=\"mode_Reorder\" class=\"radioopts\">Reorder</label> \
          <input id=\"mode_Edit\" class=\"radioopts\" type=\"radio\" name=\"usemode\" value=\"edit\" ><label for=\"mode_Edit\" class=\"radioopts\">Edit</label> \
          <input id=\"mode_Snap\" class=\"radioopts\" type=\"checkbox\" name=\"snapmode\" value=\"snap\"><label for=\"mode_Snap\" class=\"radioopts\">Grid Snap?</label> \
        </div><div id=\"opmode\"></div>";
        $tc +="</div>";
    }
    $tc += "</form>";

    $tc += utils.getFooter();
        
    return $tc;
}

function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
}

// process user options page
function processOptions($optarray) {

    if (DEBUG3) {
        console.log($optarray);
        // console.log(GLB.options["config"]);
    }
    
    // default location
    var $specialtiles = utils.getSpecials();
    var $city = "ann-arbor-mi";
    var $region = "us";
    var $code = "329380";
    // $expiry = time()+3650*24*3600;
    // $expirz = time()-3650*24*3600;
    
    var $options = clone(GLB.options);;
    $options["things"] = {};

    // var $oldoptions = clone(GLB.options);
    var $configoptions = clone($options["config"]);
    var $roomnames = Object.keys($options["rooms"]);

    if ( !is_object($configoptions["specialtiles"]) ) {
        console.log("Config = ", $configoptions);
        $configoptions["specialtiles"] = {};
    }

    // // use clock instead of blank for default only tile
    var $onlytile = GLB.options["index"]["clock|clockdigital"];

    // // checkbox items simply will not be there if not selected
    $configoptions["kiosk"] = "false";
    $configoptions["rules"] = "false";

    // // get logged in user or set default if not logged in
    var $uname = getUserName();
    var $olduname = $uname;
    var $skin = $configoptions["skin"];
    
    
    // // get default pw and its skin
    // if (array_key_exists("pword", $configoptions)) {
    //     $pwords = $configoptions["pword"];
    //     if ( array_key_exists($uname, $pwords) ) {
    //         if ( is_array($pwords[$uname]) ) {
    //             $hash = $pwords[$uname][0];
    //             $skin = $pwords[$uname][1];
    //         } else {
    //             $hash = $pwords[$uname];
    //             $pwords[$uname] = array($hash, $skin);
    //             $configoptions["pword"] = $pwords;
    //         }
    //     } else {
    //         $pwords = array();
    //         $pwords[$uname] = array($hash, $skin);
    //         $configoptions["pword"] = $pwords;
    //     }
    // } else {
    //     $pwords = array();
    //     $hash = "";
    //     $pwords[$uname] = array($hash, $skin);
    //     $configoptions["pword"] = $pwords;
    // }
    // $defskin = $skin;
    // $oldhash = $hash;
    // $hash = "";
    
    // // fix long-standing bug by putting a clock in any empty room
    // // to force the form to return each room defined in options file
    var onlyarr = [$onlytile,0,0,1,""];
    for( var $room in GLB.options["rooms"]) {
        $options["things"][$room] = [];
    }

    // // get all the rooms checkboxes and reconstruct list of active things
    // // note that the list of checkboxes can come in any random order
    for (var $key in $optarray) {
        var $val = $optarray[$key];

        //skip the returns from the submit button and the flag
        if ($key==="options" || $key==="api" || $key==="useajax" ) {
            continue;
        } else if ($key==="skin") {
            $skin = $val;
        } else if ( $key==="kiosk") {
            $configoptions["kiosk"] = "true";
        } else if ( $key==="rules") {
            $configoptions["rules"] = "true";
        } else if ( $key==="timezone" ) {
            $timezone = $val;
        } else if ( $key==="port" ) {
            $configoptions["port"] = parseInt($val);
        } else if ( $key==="webSocketServerPort" ) {
            $configoptions["webSocketServerPort"] = intval($val);
        } else if ( $key==="fast_timer" ) {
            $configoptions["fast_timer"] = intval($val);
        } else if ( $key==="slow_timer" ) {
            $configoptions["slow_timer"] = intval($val);

        // else if ( $key==="uname" && $val ) {
        //     $uname = checkuser($val);
        // }
        // else if ( $key==="pword" && $val ) {
        //     $pword = trim($val);
        //     $hash = pw_hash($pword);
        //     $oldhash = $hash;
        //     // setcookie("pwcrypt", "", $expirz, "/");
        // }
        } else if ( $key==="accucity" && $val ) {
            $city = $val.trim();
        } else if ( $key==="accuregion" && $val ) {
            $region = $val.trim();
        } else if ( $key==="accucode" && $val ) {
            $code = $val.trim();
        
        // handle user selected special tile count
        } else if ( $key.substr(0,4)==="cnt_" ) {
            var $stype = $key.substr(4);
            if ( array_key_exists($stype, $specialtiles) ) {
                var $spid = $specialtiles[$stype][0];
                var $customcnt = parseInt($val);
                createSpecialIndex($customcnt, $stype, $spid);
                $configoptions["specialtiles"] = GLB.options["config"]["specialtiles"];
                
            }
        
        // handle the option to limit view
        } else if ( $key==="useroptions" && is_array($val) ) {
            $options["useroptions"] = $val;
        
        // made this more robust by checking room name being valid
        } else if ( in_array($key, $roomnames) && is_array($val) ) {
            var $roomname = $key;
            $options["things"][$roomname] = [];
            
            // first save the existing order of tiles if still there
            // this will preserve user drag and drop positions
            // but if a tile is removed then all tiles after it will be
            // shown shifted as a result
            var $lasttop = 0;
            var $lastleft = 0;
            var $lastz = 1;

            // $oldthings = $oldoptions["things"][$roomname];
            for (var $arr in GLB.options["things"][$roomname]) {
                if ( is_array($arr) ) {
                    var $tilenum = parseInt($arr[0]);
                    var $postop = $arr[1];
                    var $posleft = $arr[2];
                    var $zindex = $arr[3];
                    var $customname = $arr[4];
                } else {
                    $tilenum = parseInt($arr);
                    $postop = 0;
                    $posleft = 0;
                    $zindex = 1;
                    $customname = "";
                }
                if ( inroom($tilenum, $val) ) {
                    var newtile = [$tilenum,$postop,$posleft,$zindex,$customname];
                    $options["things"][$roomname].push(newtile);
                    $lasttop = $postop;
                    $lastleft = $posleft;
                    $lastz = $zindex;
                }
            }
            
            // add any new ones that were not there before
            // set position to next to last one unless it is moved a lot
            // the 400 distance is subjective but works in most cases
            var $newthings = $options["things"][$roomname];
            if ( $lasttop < -400 || $lasttop > 400 || $lastleft < -400 || $lastleft > 400 ) {
                $lasttop = 0;
                $lastleft = 0; 
            }

            $val.forEach(function($tilestr) {
                var $tilenum = parseInt($tilestr);
                if ( ! inroom($tilenum, $newthings) ) {
                    var newtile = [$tilenum,$lasttop,$lastleft, $lastz, ""];
                    $options["things"][$roomname].push(newtile);
                }
            });
            
            // put a clock in a room if it is empty
            if ( $options["things"][$roomname].length === 0  ) {
                $options["things"][$roomname].push(onlyarr);
            }
        }
    }
    
    // // everything from this point on is after processing the options table
    // // start by handling the weather
    // if ( $city && $region && $code ) {
    //     getAccuWeather($city, $region, $code);
    //     $configoptions["accucity"] = $city;
    //     $configoptions["accuregion"] = $region;
    //     $configoptions["accucode"] = $code;
    // }
    
    // // now process things that used to be in auth page
    // // includes timezone, fast_timer, slow_timer, skin, port, and webSocketPort
    // // wrap the timzeone in a try block to avoid breaking app
    // try {
    //     date_default_timezone_set($timezone);
    // } catch (Exception $e) {
    //     $timezone = date_default_timezone_get();
    //     date_default_timezone_set($timezone);
    // }
    // $configoptions["timezone"] = $timezone;

    // // set the skin if it is a good one or use default from above
    // if ( $skin && file_exists($skin . "/housepanel.css") ) {
    //     if ( !file_exists($skin . "/customtiles.css") ) {
    //         writeCustomCss($skin, "");
    //     }
    //     $configoptions["skin"] = $skin;
    // } else {
    //     $skin = $defskin;
    // }
    
    // // process username and password settings and save in skin specific loc
    // // includes logic to bundle the skin with this user so that
    // // now each user can use their own skin if they want
    // if ( $uname === $olduname ) {
    //     $hash = $oldhash;
    // }
    // $pwords[$uname] = array($hash, $skin);
    
    // // now set all the parameters with complex logic
    // $configoptions["pword"] = $pwords;
    // $configoptions["timezone"] = $timezone;
    // $configoptions["specialtiles"] = $specialcounts;
    
    // save the configuration parameters in the main options array
    $options["config"] = clone($configoptions);
    
    // // set the user cookie
    // // and log this user in
    // setcookie("uname", $uname, $expiry, "/");
    // setcookie("pwcrypt", $uname, $expiry, "/");
    
    if (DEBUG4) {
        console.log("Debug Print for New Options Created - After Processing");
        console.log("index: ", JSON.stringify($options["index"]));
        console.log("config: ", $options["config"]);
        console.log("rooms: ", $options["rooms"]);
        console.log("things: ", $options["things"]);
    }

    // write options to file
    writeOptions($options);

    // refresh the main array
    // getAllThings(true);
}

function saveFilters(body) {
    console.log(body);
    var rewrite = false;

    if ( body.useroptions ) {
        GLB.options["useroptions"] = body.useroptions;
        rewrite = true;
    }

    var skin = getSkin();
    if ( typeof body.skin !== "undefined" ) {
        skin = body.skin;
    }

    if ( typeof body.huboptpick !== "undefined" ) {
        GLB.options["config"]["hubpick"] = body.huboptpick;
        rewrite = true;
    }

    // set the skin and replace the custom file with that skin's version
    if ( skin && fs.existsSync(skin + "/housepanel.css") ) {

        // save the skin in my user specific setting
        var $uname = getUserName();
        var $pwords = GLB.options["config"]["pword"];
        if ( $uname && array_key_exists($uname, $pwords) ) {
            $pwords[$uname][1] = skin;
            GLB.options["config"]["pword"] = $pwords;
        }
        
        // make sure our default skin has a custom file
        if ( !fs.existsSync(skin + "/customtiles.css") ) {
            writeCustomCss(1, skin, "");
        }
            
        // set default skin to this skin - although it shouldn't be used ever
        GLB.options["config"]["skin"] = skin;
        rewrite = true;
    }

    if ( rewrite ) {
        writeOptions(GLB.options);
    }
}

function changePageName($oldname, $pagename) {
 
    var retcode = "success";
    var options = GLB.options;
    if ( $oldname && $pagename && array_key_exists($oldname, options["rooms"]) ) {
        options["rooms"][$pagename] = options["rooms"][$oldname];
        options["things"][$pagename] = clone(options["things"][$oldname]);
        delete options["rooms"][$oldname];
        delete options["things"][$oldname];
        writeOptions(options);
    } else {
        console.log("old page name not valid: ", $oldname);
        retcode = "error";
    }
    return retcode;
}

function updateNames(type, tileid, oldname, newname) {
    var result;
    if ( type === "page" ) {
        var newname = newname.replace(" ", "_");
        result = changePageName(oldname, newname);
    } else {
        var options = GLB.options;
        var updcss = false;
        var nupd = 0;
        tileid = parseInt(tileid);
        oldname = newname;
        for (var room in options["things"]) {
            var things = options["things"][room];
        
            // look for matching options item
            // and update to new value if it changed
            // also guard against old style that wasn't an array
            // or arrays that were not at least 4 elements long
            // the 4th element of the array is the custom name
            things.forEach(function(tiles, k) {
                if ( is_array(tiles) && tiles.length>3 &&
                     (parseInt(tiles[0]) === tileid) && tiles[4]!==newname  ) {
                    oldname = tiles[4];
                    tiles[4] = newname;
                    options["things"][room][k] = tiles;
                    nupd++;
                    updcss = true;
                }

            });
        }
        if ( updcss ) {
            writeOptions(options);
            result = "success " + nupd.toString() + " names changed for type= " + type + " oldname= " + oldname + " newname= " + newname;
        } else {
            result = "success but nothing updated for type= " + type + " oldname= " + oldname + " newname= " + newname;
        }
    }
    return result;
}

function getIcons(icondir, category) {
    var skin = getSkin();

    // change over to where our icons are located
    var activedir = path.join(__dirname, skin, icondir);

    // TODO - get function to return a directory listing
    // $dirlist = scandir($activedir);
    var dirlist = fs.readdirSync(activedir);
    var allowed = ["png","jpg","jpeg","gif"];
    var $tc = "";

    dirlist.forEach( function(filename) {
        var froot = path.basename(filename);
        var ext = path.extname(filename).slice(1);
        var filedir = path.join(skin, icondir, froot);

        if ( in_array(ext, allowed) ) {
            $tc += '<div class="cat ' + category + '">';
            $tc += '<img src="' + filedir +'" class="icon" title="' + froot + '" />';
            $tc += '</div>';
        }
    });
    return $tc;
}

function pw_hash(pword) {

    var hash;
    if ( typeof pword !== "string"  || !pword ) {
        hash = "";
    } else {
        var thehash = crypto.createHash("sha256");
        thehash.update(pword);
        hash = thehash.digest('hex');
    }
    return hash;
}

function pw_verify(pword, hash) {
    return (pw_hash(pword) === hash);
}

function addCustom(swid, swtype, swval, swattr, subid) {
    var reserved = ["index","rooms","things","config","control","time","useroptions"];
    var options = GLB.options;
    var userid = "user_" + swid;

    // legacy custom types
    if ( array_key_exists(swid, options) && 
            !in_array (swid, reserved) && 
            !array_key_exists(userid, options) ) {
        userid = swid;
    }

    var oldcustoms;
    if ( array_key_exists(userid, options) ) {
        oldcustoms = clone(options[userid]);
    } else {
        oldcustoms = [];
    }

    // handle encryption
    swattr = swattr.toString();
    subid = subid.toString();
    if ( subid==="password" ) {
        swattr = pw_hash(swattr);
    }
    
    var newitem = [swval, swattr, subid];
    var newoptitem = [];
    var doneit = false;

    oldcustoms.forEach( function(val) {
        if ( val[2].toString() === subid ) {
            if ( !doneit ) {
                newoptitem.push(newitem);
                doneit = true;
            }
        } else {
            newoptitem.push(val);
        }
    });

    if ( !doneit ) {
        newoptitem.push(newitem);
    }

    options[userid] = newoptitem;
    writeOptions(options);
    var idx = swtype + "|" + swid;
    
    // make the new custom field using the updated options above
    var thingval = getCustomTile(allthings[idx]["value"], swtype, swid);

    // save it in the main array - no need for sessions in Node
    allthings[idx]["value"] = thingval;

    return thingval;
}

function delCustom(swid, swtype, swval, swattr, subid) {
    var reserved = ["index","rooms","things","config","control","useroptions"];
    var userid = "user_" + swid;

    swattr = swattr.toString();
    subid = subid.toString();

    // legacy custom types
    if ( array_key_exists(swid, GLB.options) && 
            !in_array (swid, reserved) && 
            !array_key_exists(userid, GLB.options) ) {
        userid = swid;
    }

    if ( array_key_exists(userid, GLB.options) ) {

        var oldlines = clone(GLB.options[userid]);
        if ( ! is_array(oldlines[0]) ) {
            oldlines = [oldlines];
        }

        // make new list of customs without the deleted item
        var lines = [];
        oldlines.forEach( function(newitem) {
            if ( newitem[2].toString() !== subid ) {
                lines.push(newitem);
            }
        });

        // either remove or update the main options array
        if ( lines.length === 0 ) {
            delete GLB.options[userid];
        } else {
            GLB.options[userid] = lines;
        }

        writeOptions(GLB.options);
    }
    
    var idx = swtype + "|" + swid;
    var companion = "user_" + subid;
    var thingval = allthings[idx]["value"];
    
    // remove this field and any companion if it exists
    delete thingval[subid];
    if ( array_key_exists(companion, thingval) ) {
        delete thingval[companion];
    }
    allthings[idx]["value"] = thingval;

    // make the new custom field using the updated options above
    thingval = getCustomTile(thingval, swtype, swid);
   
    // save it in the main array - no need for sessions in Node
    allthings[idx]["value"] = thingval;
    return thingval;
}

// ***************************************************
// beginning of main routine
// ***************************************************

// read the config file and get array of hubs
readOptions();
var hubs = GLB.options["config"]["hubs"];
var port = GLB.config.port;
if ( !port ) {
    port = 3080;
}

// start our main server
try {
    // the Node.js app loop - can be invoked by client or back end
    app = express();
    app.use(bodyParser.json());
    app.use(bodyParser.urlencoded({ extended: true }));
    var dir = path.join(__dirname, '');
    app.use(express.static(dir));

    // list on the port
    app.listen(port, function () {
        console.log((new Date()) + " HousePanel Server is running on port: ", port);
    });
    applistening = true;
    
} catch (e) {
    console.log((new Date()) + ' HousePanel Node.js server could not be started on port: ', port);
    app = null;
    applistening = false;
}

// retrieve all nodes/things
// client pages are refreshed when each hub is done reading
getAllThings(true);

// create the HTTP server for handling sockets
server = http.createServer(function(req, res) {
});


if ( server && GLB.config.webSocketServerPort ) {
    // create the webSocket server
    wsServer = new webSocketServer({
        httpServer: server
    });
    server.listen(GLB.config.webSocketServerPort, function() {
        console.log((new Date()) + " webSocket Server is listening on port: ", GLB.config.webSocketServerPort);
    });
    serverlistening = true;
} else {
    serverlistening = false;
    console.log((new Date()) + " webSocket port not valid. webSocketServerPort= ", GLB.config.webSocketServerPort);
}
    
// handler functions for HousePanel
// this is where we render the baseline web page for the dashboard
if ( app && applistening ) {

    // define all the mime types that can be rendered
    var mime = {
        html: 'text/html',
        txt: 'text/plain',
        css: 'text/css',
        gif: 'image/gif',
        jpg: 'image/jpeg',
        png: 'image/png',
        svg: 'image/svg+xml',
        js: 'application/javascript'
    };

    app.get('*', function (req, res) {
        
        var hostname = req.protocol + "://" + req.headers.host;
        console.log((new Date()) + " serving page at: ", hostname);

        if ( req.path==="/" || typeof req.path==="undefined" || req.path==="/undefined" || req.path==="undefined" ) {
            // set the global variable so other functions can return here
            var $tc = mainPage(req.protocol, req.headers.host, req.path);
            res.send($tc);
            res.end();

        } else if ( req.path==="/showid") {
            var $tc = getInfoPage(GLB.returnURL, req.path);
            res.send($tc);
            res.end();

        } else if ( req.path==="/showoptions") {
            var $tc = getOptionsPage(req.path);
            res.send($tc);
            res.end();

        } else {
            var file = path.join(dir, req.path.replace(/\/$/, '/index.html'));
            if (file.indexOf(dir + path.sep) !== 0) {
                res.status(403).end('Forbidden');
            }
            console.log("Loading module: ", req.path, " as: ", file);
            var type = mime[path.extname(file).slice(1)] || 'text/plain';
            var s = fs.createReadStream(file);
            s.on('open', function () {
                res.set('Content-Type', type);
                // res.type(type)
                s.pipe(res);
            });
            s.on('error', function () {
                res.set('Content-Type', 'text/plain');
                res.status(404).end(req + ' Not found');
            });
        }
    });
    
    // app.put('*', function(req, res) {
    //     console.log("requesting put: ", req.path);
    //     res.end();
    // });

// ***************************************************
// these are server treatments for processing jQuery
// ***************************************************
    
    app.post("/", function (req, res) {

        // handle two types of messages posted from hub
        // the first initialize type tells Node.js to update elements
        if ( req.body['msgtype'] == "initialize" ) {
            res.json('hub info updated');
            console.log((new Date()) + "New hub authorized; updating things in hpserver.");
            readOptions();
            getAllThings(true);
        
        // handle api calls from the hubs here
        } else if ( req.body['msgtype'] == "update" ) {
            console.log("Received update msg from hub. ", req.body["hubid"], " body: ", req.body);

            // loop through all things for this hub
            // remove music trackData field that we don't know how to handle
            var cnt = 0;
            // for (var num= 0; num< allthings.length; num++) {
            for (var idx in allthings) {

                var entry = allthings[idx];
                if ( entry.id == req.body['change_device'].toString() &&
                    req.body['change_attribute']!='trackData' &&
                    entry['value'][req.body['change_attribute']] != req.body['change_value'] )
                {
                    cnt = cnt + 1;
                    entry['value'][req.body['change_attribute']] = req.body['change_value'];
                    if ( entry['value']['trackData'] ) { delete entry['value']['trackData']; }
                    console.log('Updating tile #',entry['id'],' from trigger:', req.body['change_attribute'] );
                    pushClient(entry.id, entry.type, req.body['change_attribute'], entry['value'])
                }
            }
            console.log('pushed new status info to ' + cnt + ' tiles');
            res.json('pushed new status info to ' + cnt + ' tiles');

        // handle all api calls upon the server from js client here
        } else if ( typeof req.body['useajax']!=="undefined" || typeof req.body["api"]!=="undefined" ) {
            
            if ( req.body['useajax'] ) {
                var api = req.body['useajax'];
            } else {
                api = req.body['api'];
            }
            var swid = req.body["id"] || "0";
            var swtype = req.body["type"] || "none";
            var swval = req.body["value"] || "none";
            var swattr = req.body["attr"] || "none";
            var subid = req.body["subid"] || "";
            var tileid = req.body["tile"] || "";
            var hubid = req.body["hubid"] || hubs[0]["hubId"];
            var result;
            
            switch(api) {
                
                case "doaction":
                    result = doAction(hubid, swid, swtype, swval, swattr, subid);
                    res.json(result);
                    break;
                    
                case "doquery":
                    result = doQuery(hubid, swid, swtype);
                    res.json(result);
                    break;
                    
                case "getthings" :
                    var reload = ( req.body['swattr']==="reload" );
                    getAllThings(reload);
                    res.json(allthings);
                    break;

                case "wysiwyg2":
                    // if we sorted the user fields in the customizer, save them
                    if ( is_array(swattr) ) {
                        GLB.options["user_" + swid] = swattr;
                        writeOptions(GLB.options);
                    }

                case "wysiwyg":
                    if ( swtype==="page" && api==="wysiwyg" ) {
                        // make the fake tile for the room for editing purposes
                        var faketile = {"panel": "Panel", "tab": "Tab Inactive", "tabon": "Tab Selected"};
                        var thing = { "id": "r_" + swid, "name": swval, 
                                      "hubnum": -1, "type": "page", "value": faketile};
                        var tilejson = makeThing(0, tileid, thing, swval, 0, 0, 99, "", api);
                    } else {
                        var idx = swtype + "|" + swid;
                        var thing = allthings[idx];
                        tilejson = makeThing(0, tileid, thing, "wysiwyg", 0, 0, 99, "", api);
                    }
                    res.json(tilejson);
                    break;
                        
                case "getoptions":
                    var reload = ( req.body['swattr']==="reload" );
                    if ( reload ) {
                        readOptions();
                    }
                    res.json(GLB.options);
                    break;

                case "showid":
                case "showoptions":
                        console.log("Warning: " + api + " API call is no longer supported.");
                    res.json("success");
                    break;

                    
                case "refresh":
                    getAllThings(true);
                    res.json("success");
                    break;
                    
                case "savetileedit":
                    var partnum = parseInt(swid);
                    var skin = getSkin();
                    var result = writeCustomCss(partnum, skin, swval);
                    res.json(result);
                    break;

                case "pageorder":
                    var result = setOrder(swid, swtype, swval, swattr);
                    res.json(result);
                    break;

                case "pageadd":
                    var result = addPage();
                    res.json(result);
                    break;
        
                case "pagedelete":
                    var result = delPage(swval);
                    res.json(result);
                    break;
            
                case "getcatalog":
                    var result = getCatalog(swattr);
                    res.json(result);
                    break;
        
                case "dragdrop":
                    var result = setPosition(swid, swtype, swval, swattr);
                    res.json(result);
                    break;

                // make new tile from drag / drop
                case "dragmake":
                    var result = addThing(swid, swtype, swval, swattr);
                    res.json(result);
                    break;
            
                // remove tile from drag / drop
                case "dragdelete":
                    var result = delThing(swid, swtype, swval, swattr);
                    res.json(result);
                    break;
            

                case "updatenames":
                    var result = updateNames(swid, tileid, swval, swattr);
                    res.json(result);
                    break;

                case "saveoptions":
                    processOptions(req.body);
                    res.json("success");
                    break;

                case "filteroptions":
                    saveFilters(req.body);
                    res.json("success");
                    break;
                
                case "refactor":
                    refactorOptions();
                    pushClient("reload", "reload");
                    res.json("success");
                    break;
                    
                case "geticons":
                    var icons = getIcons(swval, swattr);
                    // TODO - confirm res.json will write html text back
                    res.json(icons);
                    break;

                case "pwhash":
                    var presult;
                    if ( swtype==="hash" ) {
                        presult = pw_hash(swval);
                    } else if ( swtype==="verify" ) {
                        if ( pw_verify(swval, swattr) ) {
                            presult = "success";
                        } else {
                            presult = "error";
                        }
                    } else {
                        presult = "error";
                    }
                    res.json(presult);
                    break;
        
                case "addcustom":
                    var result = {}
                    result.value = addCustom(swid, swtype, swval, swattr, subid);
                    result.options = GLB.options;
                    result.things = allthings;
                    res.json(result);
                    break;

                case "delcustom":
                    var result = {}
                    result.value = delCustom(swid, swtype, swval, swattr, subid);
                    result.options = GLB.options;
                    result.things = allthings;
                    res.json(result);
                    break;
    
                default:
                    res.json(req.body);
                    break;
            }
            
        } else {
            console.log((new Date()) + "hpserver received unknown message.", req.body);
            res.json('hpserver received unknown message.');
        }

    });
}

// This callback function handles new connections and closed connections
if ( wsServer && serverlistening ) {
    wsServer.on('request', function(request) {
        console.log((new Date()) + ' Connecting websocket to: ', request.origin);

        // accept connection - you should check 'request.origin' to make sure that
        // client is connecting from your website
        // (http://en.wikipedia.org/wiki/Same_origin_policy)
        var connection = request.accept(null, request.origin); 
        
        // shut down any existing connections to same remote host
        var host = connection.socket.remoteAddress;
        var i = 0;
        while ( i < clients.length ) {
            var oldhost = clients[i].socket.remoteAddress;
            if ( oldhost===host ) {
                clients.splice(i, 1);
            } else {
                i++;
            }
        }

        // report index of the connection
        // we no longer rely on this to close prior connections
        // instead we just shut down any that match
        var index = clients.push(connection) - 1;
        console.log((new Date()) + ' Connection accepted. Client #' + index + " host=" + host);

        // user disconnected - remove all clients that match this socket
        connection.on('close', function(reason, description) {
            var host = connection.socket.remoteAddress;
            console.log((new Date()) + " Peer: ", host, " disconnected. for: ", reason, " desc: ", description);

            // remove clients that match this host
            // clients.splice(indexsave, 1);
            var i = 0;
            while ( i < clients.length ) {
                var oldhost = clients[i].socket.remoteAddress;
                if ( oldhost===host ) {
                    clients.splice(i, 1);
                } else {
                    i++;
                }
            }
        });

    });
}
