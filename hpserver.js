"use strict";
process.title = 'hpserver';

// debug options
const DEBUG1 = false;               // basic debug info - file loading, hub loading
const DEBUG2 = false;               // authorization flow and ISY programs
const DEBUG3 = false;               // passwords
const DEBUG4 = false;               // index, filters, options
const DEBUG5 = false;               // hub node detail
const DEBUG6 = false;               // tile position moves
const DEBUG7 = false;               // hub responses
const DEBUG8 = false;               // API calls
const DEBUG9 =  false;              // ISY callbacks
const DEBUG10 = false;              // sibling tag
const DEBUG11 = false;              // rules
const DEBUG12 = false;              // links
const DEBUG13 = false;              // URL callbacks
const DEBUG14 = false;              // tile link details
const DEBUG15 = false;              // allthings and options dump
const DEBUG16 = false;              // customtiles writing
const DEBUG17 = false;              // push client

// various control options
const MQTTPOLY = false;             // subscribe to and log polyglot via MQTT
const MQTTHP = false;               // subscribe to and log HP via MQTT
const IGNOREPW = false;             // set this to true to accept any text as a valid password
const DONATE = false;               // set this to true to enable donation section
const ENABLERULES = true;           // set this to false to neuter all rules

// websocket and http servers
var webSocketServer = require('websocket').server;
var webSocketClient = require('websocket').client;
var path = require('path');
var http = require('http');
var fs = require('fs');
var express = require('express');
var bodyParser = require('body-parser');
var parser = require('fast-xml-parser');
var xml2js = require('xml2js').parseString;
var crypto = require('crypto');
const UTIL = require('util');
const mqtt = require('mqtt');
const os = require('os');
// const tls = require('tls');

// load supporting modules
var utils = require("./utils");

// global variables are all part of GLB object plus clients and allthings
var GLB = {};

// list of currently connected clients (users)
var clients = [];
// array of all tiles in all hubs
var allthings = {};

// server variables
var app;
var applistening = false;

function getUserName() {
    var uname;
    if ( typeof GLB.options!=="undefined" && GLB.options["config"] && array_key_exists("uname", GLB.options["config"]) ) {
        uname = GLB.options["config"]["uname"];
        if ( !uname ) { uname = "default"; }
    } else {
        uname = "default";
        if ( typeof GLB.options!=="undefined" && GLB.options["config"] ) {
            GLB.options["config"]["uname"] = uname;
        }
    }
    return uname;
}

// get the active user and skin
function getSkin() {
    var uname = getUserName();
    var skin;
    var pwords;
    if ( typeof GLB.options!=="undefined" && GLB.options["config"] && GLB.options["config"]["pword"] ) {
        pwords = GLB.options["config"]["pword"];
    }

    if ( !pwords || utils.count(pwords)===0 ) {
        skin = "skin-housepanel";
    } else if ( uname && array_key_exists(uname, pwords) ) {
        var pword = pwords[uname];
        if ( is_array(pword) ) {
            skin = pword[1];
        } else if ( GLB.options["config"]["skin"] ) {
            skin = GLB.options["config"]["skin"];
        } else {
            skin = "skin-housepanel";
        }
    } else {
        skin = "skin-housepanel";
    }
    return skin;
}

// read in customtiles ignoring the comments
// updated this to properly treat /*   */ comment blocks
function readCustomCss(skin) {
    var fname = skin + "/customtiles.css";
    var contents = fs.readFileSync(fname, 'utf8');
    return contents;
}

// call to write Custom Css Back to customtiles.css
function writeCustomCss(skin, str) {

    if ( typeof str === "undefined" ) {
        console.log( (ddbg()), "error - attempted to write null to customtiles");
    }

    // make sure we have a string
    if ( typeof str !== "string" ) {
        str = str.toString();
    }

    // proceed only if there is a main css file in this skin folder
    if ( skin && fs.existsSync(skin + "/housepanel.css") ) {
        var d = new Date();
        var today = d.toLocaleString();
        var fixstr = "";
        var opts = "w";

        // preserve the header info and update it with date
        var ipos = str.indexOf("*---*/");
        if ( ipos=== -1 ) {
            fixstr += "/* HousePanel Generated Tile Customization File */\n";
            if ( str.length ) {
                fixstr += "/* Updated: " + today + " *---*/\n";
            } else {
                fixstr += "/* Created: " + today + " *---*/\n";
            }
            fixstr += "/* ********************************************* */\n";
            fixstr += "/* ****** DO NOT EDIT THIS FILE DIRECTLY  ****** */\n";
            fixstr += "/* ****** EDITS MADE MAY BE REPLACED      ****** */\n";
            fixstr += "/* ****** WHENEVER TILE EDITOR IS USED    ****** */\n";
            fixstr += "/* ********************************************* */\n";
        } else {
            fixstr += "/* HousePanel Generated Tile Customization File */\n";
            fixstr += "/* Updated: " + today + " *---*/\n";
            ipos = ipos + 7;
            str = str.substring(ipos);
        }

        // fix addition of backslashes before quotes on some servers
        // this changes all instances of \" to just "
        if ( str.length ) {
            str= str.replace("\\\"","\"");
        }

        // add the content to the header
        fixstr += str;

        // write to specific skin folder if the location is valid
        try {
            fs.writeFileSync(skin + "/customtiles.css", fixstr, {encoding: "utf8", flag: opts});
            if ( DEBUG1 ) {
                console.log( (ddbg()), "custom CSS file saved in skin folder:", skin, " of size: ", fixstr.length);
            }
        } catch (e) {
            console.log(e);
            console.log( (ddbg()), "error - failed to save custom CSS file in skin folder: ", skin);
        }
    }
}

function readOptions(caller) {

    var rewrite = false;
    var fname = "hmoptions.cfg";
    GLB.newuser = false;
    GLB.options = {};

    try {
        if ( !fs.existsSync(fname) ) {
            GLB.newuser = true;
            throw "hmoptions.cfg file not found.  New user assumed.  Welcome to HousePanel.";
        } else {
            GLB.options = JSON.parse(fs.readFileSync(fname, 'utf8'));
            if ( !GLB.options ) {
                GLB.options = {};
                throw "hmoptions.cfg file found but was not able to be processed.  Resetting.";
            }
        }

        if ( !array_key_exists("config", GLB.options) ) {
            throw "configuration settings were not found in " + fname + " configuration file.";
        }
    } catch(e) {
        console.log( (ddbg()), e); 
        setDefaults();
        rewrite = true;
    }

    // get the last user that logged in
    // and if not there use the default user
    var uname;
    if ( array_key_exists("uname", GLB.options["config"]) ) {
        uname = GLB.options["config"]["uname"];
        if ( !uname ) {
            uname = "default";
        }
    } else {
        uname = "default";
        GLB.options["config"]["uname"] = uname;
        rewrite = true;
    }

    // check for empty rooms, things, and index
    if ( !array_key_exists("rooms", GLB.options) ||
         !array_key_exists("things", GLB.options) ||
         !array_key_exists("index", GLB.options) ) {
        setDefaults();
        rewrite = true;
    }

    // handle time settings
    if ( array_key_exists("time", GLB.options) ) {
        var timeval = GLB.options["time"];
        var info = timeval.split(" @ ");
        var version = info[0];
        timeval = info[1];
    } else {
        var d = new Date();
        timeval = d.getTime();
        timeval = timeval.toString();
        version = utils.HPVERSION;
        GLB.options["time"] = version + " @ " + timeval;
        rewrite = true;
    }

    if ( !array_key_exists("useroptions", GLB.options) ) {
        GLB.options["useroptions"]= utils.getTypes();
        rewrite = true;
    }

    if ( !array_key_exists("pword", GLB.options.config) ) {
        GLB.options.config["pword"] = {};
        GLB.options.config["pword"][uname] =  ["","skin-housepanel"];
        rewrite = true;
    }

    if ( DEBUG1 ) {
        if ( !caller ) { caller = "unknown"; }
        console.log( (ddbg()), 'Config file for HP Version: ', version, " username: ", uname, " caller: ", caller);
    }

    // read the hubs
    if ( array_key_exists("hubs", GLB.options["config"]) ) {
        if ( !is_array(GLB.options.config["hubs"]) ) { GLB.options.config["hubs"] = [] };
    } else {
        GLB.options.config["hubs"] = [];
        rewrite = true;
    }

    if (  GLB.options.config["hubs"].length > 0 ) {
        console.log((ddbg()), 'Loading ',  GLB.options.config["hubs"].length,' hubs.');
        if ( DEBUG2 ) {
            console.log( GLB.options.config["hubs"] );
        }
    } else {
        console.log((ddbg()), 'No hubs found. HousePanel will only show special and custom tiles.');
    }

    // update the options file if we added default info
    // we must do this before customizing the room to avoid messing up baseline
    // also include flag to skip the writing of the user section
    if ( rewrite ) {
        writeOptions(GLB.options, true);
    }
    
    // get custom settings for this user
    // or create the custom config for new users
    var customfname = "hm_" + uname + ".cfg";
    if ( !fs.existsSync(customfname) ) {
        // this format is now in real json format and includes user_ tiles
        // add a signature key to flag this format
        var customopt = {};
        customopt["::CUSTOM::"] = [uname, utils.HPVERSION, timeval];
        for (var key in GLB.options) {
            if ( key==="rooms" || key==="things" || key.substr(0,5)==="user_" ) {
                customopt[key] = GLB.options[key];
            }
        }
        var str_customopt = JSON.stringify(customopt, null, 1);
        fs.writeFileSync(customfname, str_customopt);
    } else {

        // read this assuming new method only
        var str = fs.readFileSync(customfname, 'utf8');
        var str1 = str.replace("\r","");
        var str2 = str1.replace("\n","");
        var opts = JSON.parse(str2);

        if ( DEBUG1 ) {
            console.log( (ddbg()), 'User skin file: ', customfname, " was processed.");
        }
        if ( DEBUG2 ) {
            console.log( (ddbg()), " Rooms: ", opts.rooms, " things: ", UTIL.inspect(opts.things, false, null, false) );
        }
    
        var opt_rooms = null;
        var opt_things = null;
        if ( opts["rooms"] ) {
            opt_rooms = opts["rooms"];
        }
        if ( opts["things"] ) {
            opt_things = opts["things"];
        }
        for (var key in opts) {
            if ( key.substr(0,5)==="user_" ) {
                GLB.options[key] = opts[key];
            }
        }
            
        // protect against having a custom name and an empty custom user info
        if ( opt_rooms && opt_things && utils.count(opt_rooms) > 0 && utils.count(opt_things) > 0 ) {
            GLB.options["rooms"] = opt_rooms;
            GLB.options["things"] = {};
            for (var room in opt_rooms) {
                if ( array_key_exists(room, opt_things) ) {
                    GLB.options["things"][room] = opt_things[room];
                }
            }
        }
    }
}

function writeOptions(options, skipuser) {
    
    if ( !options ) {
        options = GLB.options;
    }

    var d = new Date();
    var timeval = d.getTime();
    timeval = timeval.toString();
    options["time"] = utils.HPVERSION + " @ " + timeval;
    GLB.options = clone(options);
    
    // write the main options file
    var stropt =  JSON.stringify(options, null, 1);
    fs.writeFileSync("hmoptions.cfg", stropt, {encoding: "utf8", flag:"w"});

    // write the user specific options file
    // unless skipuser given to skip this
    if ( typeof skipuser==="undefined" || !skipuser ) {
        var uname = getUserName();
        if ( uname ) {
            var userfname = "hm_" + uname + ".cfg";

            // this format is now in real json format and includes user_ tiles
            // add a signature key to flag this format
            var customopt = {};
            customopt["::CUSTOM::"] = [uname, utils.HPVERSION, timeval];
            for (var key in GLB.options) {
                if ( key==="rooms" || key==="things" || key.substr(0,5)==="user_" ) {
                    customopt[key] = GLB.options[key];
                }
            }
            var str_customopt = JSON.stringify(customopt, null, 1);
            fs.writeFileSync(userfname, str_customopt, {encoding: "utf8", flag:"w"});
        }
    }
}

function curl_call(host, headertype, nvpstr, formdata, calltype, callback) {
    var request = require('request');
    var opts = {url: host};
    if ( !calltype ) {
        calltype = "GET";
    }
    opts.method = calltype;
    
    if ( nvpstr && typeof nvpstr === "object" ) {
        opts.form = nvpstr;
    } else if ( nvpstr && typeof nvpstr === "string" ) {
        opts.url = host + "?" + nvpstr;
    }
    
    if (formdata) {
        opts.formData = formdata;
    }
    
    if ( headertype ) {
        opts.headers = headertype;
    }
    request(opts, callback);
}

function getHubInfo(hub, token, endpt, clientId, clientSecret) {

    // no need to check for valid token and endpt since we can't get here unless both are valid
    var namehost = endpt + "/gethubinfo";
    var header = {"Authorization": "Bearer " + token};
    var nvpreq = {"scope": "app", "client_id": encodeURI(clientId), "client_secret": encodeURI(clientSecret)};
    curl_call(namehost, header, nvpreq, false, "POST", nameidCallback);

    function nameidCallback(err, res, body) {
        var jsonbody;
        var hubName;
        var hubId;
        if ( err ) {
            console.log( (ddbg()), "error - attempting to make hub name request.");
            return;
        }

        try {
            jsonbody = JSON.parse(body);
            hubName = jsonbody["sitename"];
            hubId = jsonbody["hubId"];
            if ( DEBUG2 ) {
                console.log( (ddbg()), "hubName request return: ", jsonbody);
            }
        } catch(e) {
            console.log( (ddbg()), "error retrieving hub name.");
            GLB.defhub = "-1";
            pushClient("reload", "/reauth");
            return;
        }

        if ( DEBUG2 ) {
            console.log( (ddbg()), "hub info: token= ", token, " endpt= ", endpt, " hubName= ", hubName, " hubId= ", hubId);
        }

        // now save our info
        // we also have to save the access point and endpt in case this was an oauth flow
        hub["hubAccess"] = token;
        hub["hubEndpt"] = endpt;
        hub["hubName"]  = hubName;
        hub["hubId"] = hubId;
        var hubType = hub["hubType"];
        GLB.defhub = hubId;

        // update this hub
        updateHubs(hub, hubId);
        writeOptions(GLB.options, true);

        // retrieve all devices and go back to reauth page
        getDevices(hubId, hubType, token, endpt, clientId, clientSecret, hubName, true, "/reauth");
    }
    return "success";

}

function getAccessToken(code, hub) {

    // these are the parameters determined here using a series of curl calls and callbacks
    var token = "";

    var hubType = hub["hubType"];
    var hubName = hub["hubName"];
    var hubHost = hub["hubHost"];
    var clientId = hub["clientId"];
    var clientSecret = hub["clientSecret"];
    var hubnum = GLB.defhub;
    var redirect = GLB.returnURL + "/oauth";

    // make the call to get the token
    var tokenhost = hubHost + "/oauth/token";
    var header = {'Content-Type' : "application/x-www-form-urlencoded"};
    var nvpreq = {"grant_type": "authorization_code", "code": encodeURI(code), "client_id": encodeURI(clientId), 
                  "client_secret": encodeURI(clientSecret), "redirect_uri": encodeURI(redirect)};
    if ( DEBUG2 ) {
        console.log( (ddbg()), "calling with nvpreq: ", nvpreq);
    }
    
    curl_call(tokenhost, header, nvpreq, false, "POST", tokenCallback);

    // callback from the token request
    async function tokenCallback(err, res, body) {
        // save the access token
        var jsonbody = JSON.parse(body);
        if ( DEBUG2 ) {
            console.log( (ddbg()), "access token return: ", jsonbody);
        }

        if ( jsonbody["error"] ) {
            console.log( (ddbg()), "Token error authorizing hub: ", hubName, " error: ", err, " ", jsonbody["error"]);
            GLB.defhub = "-1";
            pushClient("reload", "/reauth");
        } else if ( typeof jsonbody==="object" && array_key_exists("access_token", jsonbody) ) {
            token = jsonbody["access_token"];
            if (token) {
                var ephost;
                if ( hubType==="SmartThings" ) {
                    ephost = hubHost + "/api/smartapps/endpoints";
                } else if ( hubType ==="Hubitat" ) {
                    ephost = hubHost + "/apps/api/endpoints";
                } else {
                    console.log( (ddbg()), "Invalid hub type: ", hubType, " in access token request call");
                    GLB.defhub = "-1";
                    pushClient("reload", "/reauth");
                }

                header = {"Authorization": "Bearer " + token};
                curl_call(ephost, header, false, false, "GET", endptCallback);
            }
        } else {
            console.log( (ddbg()), "Unknown error authorizing hub: ", hubName, " error: ", err, " body: ", body);
            GLB.defhub = "-1";
            pushClient("reload", "/reauth");
        }
    }        
    
    async function endptCallback(err, res, body) {
        var jsonbody;
        var endpt;
        try {
            jsonbody = JSON.parse(body);
            if ( DEBUG2 ) {
                console.log( (ddbg()), "endpoint return: ", jsonbody);
            }
        } catch(e) {
            err = e;
        }

        if ( err ) {
            console.log( (ddbg()), "getEndpoint error authorizing " + hub.hubType + " hub. error: ", err);
            GLB.defhub = "-1";
            pushClient("reload", "/reauth");
        } else {
            var endptzero = jsonbody[0];
            endpt = endptzero.uri;
        }

        if ( token && endpt ) {
            getHubInfo(hub, token, endpt, clientId, clientSecret);

        } else {
            GLB.defhub = "-1";
            console.log( (ddbg()), "getEndpoint error authorizing " + hub.hubType + " hub. bad token: ", token, " or endpt: ", endpt);
            pushClient("reload", "/reauth");
        }
    }
}

// this makes Insteon ID's look good but it messes up the hub calls
// which oddly enough expect the id in the mangled form that does not match
// the way the id is written on the Insteon device
function fixISYid(id) {
    // if ( id.indexOf(" ") !== -1 ) {
    //     var idparts = id.split(" ");
    //     if ( idparts.length===4 ) {
    //         idparts.forEach(function(idp, i) {
    //             if ( idp.length===1 ) {
    //                 idparts[i] = "0" + idp;
    //             }
    //         });
    //         id = idparts.join(".");
    //     }
    // }
    return id;
}

function getAllThings(reload) {
    
    allthings = {};

    // add the special tiles
    addSpecials();
    // updateOptions("/");

    // get all things from all configured servers
    var hubs = GLB.options.config["hubs"];
    if ( hubs && utils.count(hubs) > 0 ) {
        hubs.forEach(function(hub) {
            var hubnum = hub["hubId"];
            var accesstoken  = hub["hubAccess"];
            var hubEndpt = hub["hubEndpt"];
            var clientId = hub["clientId"];
            var clientSecret = hub["clientSecret"];
            var hubName = hub["hubName"];
            var hubType = hub["hubType"];
            getDevices(hubnum, hubType, accesstoken, hubEndpt, clientId, clientSecret, hubName, reload, "/");
        });
    }

    // send a reload in 10 seconds to give time for above to finish
    // if ( reload ) {
    //     setTimeout( function() {
    //         updateOptions("/");
    //     }, 10000);
    // }
}

function getDevices(hubnum, hubType, hubAccess, hubEndpt, clientId, clientSecret, hubName, reload, reloadpath) {

    // retrieve all things from ST
    if ( hubType==="SmartThings" || hubType==="Hubitat" ) {
        var stheader = {"Authorization": "Bearer " + hubAccess};
        var params = {client_secret: clientId,
                      scope: "app",
                      client_id: clientSecret};
        curl_call(hubEndpt + "/getallthings", stheader, params, false, "POST", getAllDevices);

    // retrieve all things from ISY
    // impt note - this is called within the scope of getDevices just like the callback above
    } else if ( hubType==="ISY" ) {
        getIsyDevices();
    } else {
        console.log( (ddbg()), "error - attempt to read an unknown hub type= ", hubType);
        pushClient("reload", reloadpath);
    }

    // callback for loading ST and HE hub devices
    function getAllDevices(err, res, body) {
        if ( err ) {
            console.log( (ddbg()), "error retrieving devices: ", err);
        } else {
            try {
                var jsonbody = JSON.parse(body);
            } catch (e) {
                console.log( (ddbg()), "error translating devices: ", e);
                jsonbody = {};
                return;
            }
            if (DEBUG1) {
                console.log( (ddbg()), "Retrieved ", jsonbody.length, " things from hub: ", hubName);
            }    

            // configure returned array with the "id"
            if (jsonbody && typeof jsonbody === "object") {
                jsonbody.forEach(function(content) {
                    var thetype = content["type"];
                    var id = content["id"];
                    var idx = thetype + "|" + id;
                    var origname = content["name"] || "";
                    var pvalue = content["value"];

                    // handle audio tiles
                    if ( pvalue && thetype==="audio" && array_key_exists("audioTrackData", pvalue) ) {
                        try {
                            var audiodata = JSON.parse(pvalue["audioTrackData"]);
                            if ( audiodata ) {
                                pvalue["trackDescription"] = audiodata["title"] || "";
                                pvalue["currentArtist"] = audiodata["artist"] || "";
                                pvalue["currentAlbum"] = audiodata["album"] || "";
                                pvalue["trackImage"] = audiodata["albumArtUrl"] || "";
                                pvalue["mediaSource"] = audiodata["mediaSource"] || "";
                            }
                        } catch(jerr) {
                            audiodata = null;
                            console.log(jerr);
                        }
                        delete pvalue["audioTrackData"];
                    }

                    // this is the proper place to load customizations
                    // and we have to do it for ISY too
                    var pvalue = getCustomTile(pvalue, thetype, id);
                    if ( !origname ) {
                        origname = pvalue["name"];
                    }

                    allthings[idx] = {
                        "id": id,
                        "name": origname, 
                        "hubnum": hubnum,
                        "type": thetype,
                        "hint": hubType, 
                        "refresh": "normal",
                        "value": pvalue
                    };
                });
            }
            if ( reload && reloadpath ) {
                updateOptions(reloadpath);
            }
        }
    }

    // version that supports ISY
    // function for loading ST and HE hub devices
    function getIsyDevices() {
        var buff = Buffer.from(hubAccess);
        var base64 = buff.toString('base64');
        var stheader = {"Authorization": "Basic " + base64};

        // also get all the variables and put them into tiles too
        // start by creating the default vars tile with customizations
        var id = "vars";
        var thetype = "isy";
        var idx = thetype + "|" + id;
        var pvalue = {name: "Variables"};
        pvalue = getCustomTile(pvalue, thetype, id);
        allthings[idx] = {id: id, name: "Variables", hubnum: hubnum, type: thetype, hint: "ISY variable", refresh: "never", value: pvalue };

        // now read in any int and state variables
        curl_call(hubEndpt + "/vars/get/1", stheader, false, false, "GET", getIntVars);
        curl_call(hubEndpt + "/vars/get/2", stheader, false, false, "GET", getStateVars);

        // also get programs
        curl_call(hubEndpt + "/programs?subfolders=true", stheader, false, false, "GET", getAllProgs);

        // now get all the nodes and do callback to auth page
        curl_call(hubEndpt + "/nodes", stheader, false, false, "GET", getAllNodes);
            
        // update things and reload page after handling all tiles
        // setTimeout(function() {
        //     if ( reloadpath ) {
        //         updateOptions(reloadpath);
        //     }
        // }, 5000);
        
        function getIntVars(err, res, body) {
            if ( err ) {
                console.log( (ddbg()), "error retrieving ISY int variables: ", err);
            } else {
                // console.log("getting int variables...", body);
                getISY_Vars(body, "int");
            }
        }
        
        function getStateVars(err, res, body) {
            if ( err ) {
                console.log( (ddbg()), "error retrieving ISY state variables: ", err);
            } else {
                // console.log("getting state variables...", body);
                getISY_Vars(body, "state");
            }
        }

        function getISY_Vars(body, vartype) {
            var id = "vars";
            var thetype = "isy";
            var idx = thetype + "|" + id;

            var result = parser.parse(body);
            if (DEBUG2) {
                console.log( (ddbg()), vartype, "variables: ", UTIL.inspect(result, false, null, false) );
            }

            // make a single tile with all the variables in it
            var varobj = result.vars.var;
            if ( !is_object(varobj) || !array_key_exists(idx, allthings) ) {
                return;
            }

            // convert single variable object into an array of variable objects
            if ( !is_array(varobj) ) {
                varobj = [varobj];
            }
                
            var pvalue = allthings[idx]["value"];
            var k = 1;
            varobj.forEach(function( obj) {
                var prec = obj.prec;
                var val10 = parseFloat(obj.val) / Math.pow(10, prec);
                while ( typeof pvalue[vartype+"_"+k] !== "undefined" ) {
                    k++;
                }
                pvalue[vartype+"_"+k] = val10.toString();
                pvalue["prec_"+vartype+"_"+k] = prec.toString();
                k++;
            });

            allthings[idx]["value"] = pvalue;
            if ( DEBUG2 ) {
                console.log( (ddbg()), "New variable value: ", pvalue);
            }
        }

        // get programs and setup program tiles much like how Piston tiles are done in ST and HE
        function getAllProgs(err, res, body) {
            if ( err ) {
                console.log( (ddbg()), "error retrieving ISY programs: ", err);
            } else {

                // have to use the full parsing function here
                // console.log("getting programs...", body);
                xml2js(body, function(xmlerr, result) {
                    var thetype = "isy";
                    try {
                        if ( result ) {

                            var programlist = result.programs.program;
                            if ( !is_object(programlist) ) {
                                return;
                            }

                            // // convert single variable object into an array of variable objects
                            if ( !is_array(programlist) ) {
                                programlist = [programlist];
                            }

                            // now lets get all the master program nodes
                            // and create a tile for any program that is not a folder
                            // TODO: recurse into folders and get programs there too
                            var pvalue = allthings[idx]["value"];
                            programlist.forEach(function(prog) {
                                var proginfo = prog["$"];
                                var isfolder = proginfo.folder;
                                if ( DEBUG2 ) {
                                    console.log( (ddbg()), "Program details: ", UTIL.inspect(prog, false, null, false) );
                                }

                                // if we have a folder don't add it
                                if ( isfolder==="true" ) {
                                    if ( DEBUG2 ) {
                                        console.log( (ddbg()), "Program ", prog.name, " is a folder. id: ", proginfo.id, " Status: ", proginfo.status);
                                    }

                                // create tile for programs that are not folders
                                } else {
                                    if ( DEBUG2 ) {
                                        console.log( (ddbg()), "Program ", prog.name, " id: ", proginfo.id, " Status: ", proginfo.status, " Last run: ", prog.lastRunTime );
                                    }
                                    var progid = "prog_" + proginfo.id;
                                    idx  = thetype + "|" + progid;

                                    // set the program name. Add Program if it isn't there
                                    // this will help make program names unique from tiles
                                    var progname;
                                    if ( is_array(prog.name) ) {
                                        progname = prog.name[0];
                                    } else {
                                        progname = prog.name;
                                    }
                                    if ( progname.toLowerCase().indexOf("program") === -1 ) {
                                        progname = "Program " + progname;
                                    }

                                    var progcommands = "run|runThen|runElse|stop|enable|disable";
                                    var progarr = progcommands.split("|");
                                    pvalue = {name: progname};
                                    progarr.forEach(function(command) {
                                        pvalue[command] = command;
                                    });
                                    for ( var key in prog ) {
                                        if ( key!=="$" && key!=="name" ) {
                                            var val = prog[key];
                                            if ( is_array(val) ) {
                                                pvalue[key] = val[0];
                                            } else {
                                                pvalue[key] = val;
                                            }
                                        }
                                    }
                                    pvalue.status = proginfo.status;
                                    
                                    // call customizer
                                    pvalue = getCustomTile(pvalue, thetype, progid);

                                    allthings[idx] = {
                                        "id": progid,
                                        "name": progname, 
                                        "hubnum": hubnum,
                                        "type": thetype,
                                        "hint": "ISY program",
                                        "refresh": "normal",
                                        "value": pvalue
                                    };
                                }
                            });
                        }
                    } catch (e) {
                        console.log("error - failed loading ISY programs");
                        console.log(e);
                    }
                });

            }

        }

        function getAllNodes(err, res, body) {
            var thetype = "isy";
            if ( err ) {
                console.log( (ddbg()), "error retrieving ISY nodes: ", err);
            } else {
                var result = parser.parse(body);
                var thenodes = result.nodes["node"];
                if ( DEBUG1 ) {
                    console.log( (ddbg()), "Retrieved ", thenodes.length, " things from hub: ", hubName);
                }

                // read the real attributes and map to HP fields
                for ( var obj in thenodes ) {
                    var node = thenodes[obj];
                    var id = node["address"].toString();
                    id = fixISYid(id);

                    // console.log("node id: ", id, " type: ", typeof id);
                    var idx = thetype + "|" + id;
                    var hint = node["type"].toString();

                    // set hint to nothing if default of zeros is provided
                    // TODO - provide a more useful mapping of hints to type names
                    // until then user can still style hints using CSS
                    if ( hint ) {
                        hint.replace( /\./g, "_" );
                        hint = "ISY " + hint;
                    }

                    var name = node["name"];
                    var pvalue = {"name": name};

                    // this is the proper place to load customizations
                    pvalue = getCustomTile(pvalue, thetype, id);
                    if ( !name ) {
                        name = pvalue["name"];
                    }
                    // console.log("post custom: ", pvalue);

                    // set bare minimum info
                    // this is updated below in the callback after getting node details
                    allthings[idx] = {
                        "id": id,
                        "name": name, 
                        "hubnum": hubnum,
                        "type": thetype, 
                        "hint": hint,
                        "refresh": "never",
                        "value": pvalue
                    };

                    if (DEBUG5) {
                        console.log( (ddbg()), "idx= ", idx," hint= ", hint, " node: ", node);
                    }
                }
            }
        
            // now that we have all the nodes identified, get the details
            curl_call(hubEndpt + "/status", stheader, false, false, "GET", callbackStatusInfo);

            function callbackStatusInfo(err, res, body) {
                xml2js(body, async function(xmlerr, result) {
                    try {
                        if ( result ) {
                            var nodes = result.nodes.node;
                            if ( nodes ) {
                                if ( DEBUG5 ) {
                                    console.log( (ddbg()), "nodes returned from status");
                                }
                                nodes.forEach(function(node) {
                                    var nodeid = fixISYid(node["$"]["id"]);
                                    var idx = "isy|" + nodeid;
                                    var value = clone(allthings[idx]["value"]);
                                    var props = node["property"];

                                    // if there are props set values
                                    if ( props ) {
                                        if ( DEBUG5 ) {
                                            console.log( (ddbg()), "ISY status callback. node: ", nodeid, " properties: ", props);
                                        }
                                        setIsyFields(nodeid, value, props);
                                    }
                                });
                            } else {
                                throw "Something went wrong reading status from ISY";
                            }
                        }
                    } catch(e) { 
                        console.log( (ddbg()), "error - ", e);
                    }
                });

                // update things and reload page after handling all tiles
                // wait five seconds just to give variables and programs some room
                if ( reload && reloadpath ) {
                    setTimeout( function() {
                        updateOptions(reloadpath);
                    }, 5000);
                }
            }
        }
    }
}
// end of getDevices which contains multiple other functions

function mapIsy(isyid, uom) {
    const idmap = {"ST": "switch", "OL": "onlevel", "SETLVL": "level", "BATLVL": "battery", "CV": "voltage", "TPW": "power",
                   "CLISPH": "heatingSetpoint", "CLISPC": "coolingSetpoint", "CLIHUM": "humidity", "LUMIN": "illuminance", 
                   "CLIMD": "thermostatMode", "CLIHCS": "thermostatState", "CLIFS": "thermostatFanMode",
                   "CLIFRS": "thermostatOperatingState", "CLISMD": "thermostatHold"};
    var id = isyid;
    if ( array_key_exists(isyid, idmap) ) {
        id = idmap[isyid];
    }

    return id;
}

function translateIsy(nodeid, objid, uom, value, val, formatted) {

    // convert levels for Insteon range
    if ( uom && uom==="100" ) {
        val = Math.floor(parseInt(val) * 100 / 255);
    }
    val = val.toString();

    if ( typeof formatted === "undefined" ) {
        formatted = "";
    }

    // convert the trigger into a subid to modify
    var subid = mapIsy(objid, uom);

    // set the HP equivalent subid for this type of node field
    // if maps are not present then the native ISY subid will show up
    var newvalue = clone(value);

    // handle special cases
    switch (objid) {

        case "ST":
            if ( (uom==="51" || uom==="100") ) {
                // newvalue["level"]= val;  // formatted.substr(0, formatted.length-1);
                if ( val!=="0" && val!=="100") {
                    newvalue["level"] = val;
                }
                if ( val==="0" ) {
                    val = "DOF";
                } else if ( val==="100" ) {
                    val = "DON";
                } else {
                    newvalue["level"] = val;
                    val = "DON";
                }
                newvalue[subid] = val;

            } else if (uom==="78") {
                val = (formatted==="Off" || val==="0") ? "DOF" : "DON";
                newvalue[subid] = val;

            } else if ( uom==="17" ) {
                if ( typeof formatted==="undefined" || formatted==="" ) {
                    formatted = val + "°F";
                }
                newvalue["temperature"]= formatted;

            } else {
                val = (formatted==="Off" || val==="0" ? "DOF" : "DON");
                newvalue[subid] = val;
            }
            break;

        case "OL":
            if ( formatted && formatted==="On" ) {
                val = "100";
            } else if ( formatted && formatted==="Off" ) {
                val = "0";
            } else if ( formatted && formatted.substr(-1) === "%" ) {
                val = formatted.substr(0, formatted.length-1);
                if ( isNaN(parseInt(val)) ) {
                    val = "0";
                }
            } else {
                if ( isNaN(parseInt(val)) ) {
                    val = "0";
                }
            }
            newvalue[subid] = val;
            newvalue["level"] = val;
            break;

        case "CLIHUM":
        case "BATLVL":
            newvalue[subid] = val;
            break;

        case "CLISPC":
        case "CLISPH":
            if ( uom==="17" && formatted==="" ) {
                formatted = val + "°F";
            } else if ( formatted==="" ) {
                formatted = val;
            }
            newvalue[subid] = formatted;
            break;

        case "RR":
            var index = parseInt(val);
            if ( uom==="25" && !isNaN(index) && index<=31 ) {
                const RRindex = ["9.0 min", "8.0 min", "7.0 min", "6.0 min", "5.0 min", "4.5 min", "4.0 min", "3.5 min",
                                 "3.0 min", "2.5 min", "2.0 min", "1.5 min", "1.0 min", "47.0 sec", "43.0 sec", "38.5 sec",
                                 "34.0 sec", "32.0 sec", "30.0 sec", "28.0 sec", "26.0 sec", "23.5 sec", "21.5 sec", "19.0 sec",
                                 "8.5 sec", "6.5 sec", "4.5 sec", "2.0 sec", "0.5 sec", "0.3 sec", "0.2 sec", "0.1 sec"];
                val = RRindex[index];
            }
            newvalue[subid] = val;
            break;

        case "CLIFRS":
            var index = parseInt(val);
            const CLHindex = ["Off", "On", "On High", "On Medium", "Circulation", "Humidity Circ", "R/L Circ", "U/D Circ", "Quiet"];
            if ( uom==="80" && !isNaN(index) && index < CLHindex.length ) {
                val = CLHindex[index];
            }
            newvalue[subid] = val;
            break;

        case "CLIHCS":
            var index = parseInt(val);
            const CLFindex = ["Idle", "Heating", "Cooling", "Off"];
            if ( uom==="25" && !isNaN(index) && index < CLFindex.length ) {
                val = CLFindex[index];
            }
            newvalue[subid] = val;
            break;
        
        default:
            newvalue[subid] = formatted ? formatted : val;
            break;

    }
    return newvalue;
}

function objMerge(obj, newobj) {
    for ( var key in newobj ) {
        obj[key] = newobj[key];
    }
    return clone(obj);
}

function setIsyFields(nodeid, value, props) {
    var idx = "isy|" + nodeid;
    if ( is_array(props) ) {
        props.forEach(function(aprop) {
            var obj = aprop['$'];
            // map ISY logic to the HousePanel logic based on SmartThings and Hubitat
            var subid = mapIsy(obj.id, obj.uom);
            value["uom_" + subid] = obj.uom;
            var val = obj.value;
            value = translateIsy(nodeid, obj.id, obj.uom, value, val, obj.formatted);
            allthings[idx]["value"] = clone(value);
            pushClient(nodeid, "isy", subid, value, false, false);
        });
    }
}

// updates the global options array with new things found on hub
function updateOptions(reloadpath) {

    if ( ! GLB.options ) {
        return;
    }
    var update = false;
   
    // make all the user options visible by default
    if ( !array_key_exists("useroptions", GLB.options )) {
        GLB.options["useroptions"] = utils.getTypes();
    }

    // find the largest index number for a sensor in our index
    var cnt = utils.getMaxIndex(GLB.options["index"]) + 1;

    // update the index with latest sensor information
    for (var thingid in allthings) {
        // var thesensor = allthings[thingid];
        if ( !array_key_exists(thingid, GLB.options["index"]) ||
             parseInt(GLB.options["index"][thingid])===0 ) {
            GLB.options["index"][thingid] = cnt;
            update = true;
            cnt++;
        }
    }
    
    // save the options file
    if ( update && reloadpath!==false) {
        // make exactly the right number of special tiles
        var specialtiles = utils.getSpecials();
        for (var stype in specialtiles) {
            var sid = specialtiles[stype];
            var customcnt = getCustomCount(stype, sid[3]);
            createSpecialIndex(customcnt, stype, sid[0]);
        }

        writeOptions(GLB.options);
    }

    // signal clients to reload
    if ( reloadpath !== false ) {
        pushClient("reload", reloadpath);
    }
}

function setDefaults() {
     
    // generic room setup
    const defaultrooms = {
        "Kitchen": "clock|kitchen|sink|pantry|dinette" ,
        "Family": "clock|family|mud|fireplace|casual|thermostat",
        "Living": "clock|living|dining|entry|front door|foyer",
        "Office": "clock|office|computer|desk|work",
        "Bedroom": "clock|bedroom|kid|kids|bathroom|closet|master|guest",
        "Outside": "clock|garage|yard|outside|porch|patio|driveway|weather",
        "Music": "clock|sonos|music|tv|television|alexa|echo|stereo|bose|samsung|pioneer"
    };

    if ( !GLB.options ) {
        GLB.options = {};
    }
    GLB.options.config = {};

    // set defaults here
    GLB.options.config["port"] = "3080";
    GLB.options.config["skin"] = "skin-housepanel";
    GLB.options.config["kiosk"] = "false";
    GLB.options.config["webSocketServerPort"] = "1380";
    GLB.options.config["timezone"] = "America/Detroit";
    GLB.options.config["hubs"] = [];

    GLB.options.config["specialtiles"] = {"video": 4, "frame": 4, "image": 4, "blank": 4, "custom": 8};

    GLB.options.config["fast_timer"] = "0";
    GLB.options.config["slow_timer"] = "300000";
    GLB.options.config["rules"] = "false";
    GLB.options.config["accucity"] = "ann-arbor-mi";
    GLB.options.config["accuregion"] = "us";
    GLB.options.config["accucode"] = "329380";
    GLB.options.config["fcastcity"] = "ann-arbor";
    GLB.options.config["hubpick"] = "all";
    GLB.options.config["polisyip"] = "localhost";

    var uname = "default";
    var skin = "skin-housepanel";
    GLB.options.config["uname"] = uname;
    GLB.pwcrypt = IGNOREPW ? true : false;

    GLB.options.config["pword"] = {};
    GLB.options.config["pword"][uname] = ["", skin];

    GLB.options["useroptions"] = utils.getTypes();
    
    // make a default options array based on the old logic
    // protocol for the options array is an array of room names
    // where each item is an array with the first element being the order number
    // second element is an optional alternate name defaulted to room name
    // each subsequent item is then a tuple of ST id and ST type
    // encoded as ST-id|ST-type to enable an easy quick text search
    GLB.options["rooms"] = {};
    GLB.options["things"] = {};

    // if we don't have allthings yet, load the special tiles
    if ( utils.count(allthings)===0 ) {
        addSpecials();
    }

    // put the special things in the index
    if ( !array_key_exists("index", GLB.options ) ) {
        GLB.options["index"] = {};
    }
    updateOptions(false);

    // var defbid = GLB.options.index["clock|clockdigital"];
    // var defthing = [defbid, 0, 0, 1, ""];

    var k = 0;
    // foreach(array_keys($defaultrooms) as $room) {
    for (var room in defaultrooms) {
        GLB.options["rooms"][room] = k;
        GLB.options["things"][room] = [];
        k++;
    }

    // organize things into rooms
    for (var thingid in allthings) {
        var thesensor = allthings[thingid];
        var thename= thesensor["name"].toLowerCase();
        var k = GLB.options["index"][thingid];
        if ( k ) {
            for (var room in defaultrooms) {
                var checkarr = defaultrooms[room].split("|");
                checkarr.forEach(function(keyword) {
                    var islocated = thename.indexOf(keyword);
                    if ( islocated !== -1 ) {
                        var tile = [k,0,0,1,""];
                        GLB.options["things"][room].push(tile);
                    }
                });
            }
        }
    }

}

function getLoginPage() {
    var $tc = "";
    var skin = getSkin();
    $tc += utils.getHeader(skin);
    $tc += "<h2>" + utils.APPNAME + "</h2>";
    $tc += "<br /><br />";
    $tc += "<form id=\"loginform\" name=\"login\" action=\"" + GLB.returnURL + "\"  method=\"POST\">";
    $tc += utils.hidden("returnURL", GLB.returnURL);
    $tc += utils.hidden("pagename", "login");
    $tc += utils.hidden("api", "dologin");
    $tc += utils.hidden("id", "none");
    $tc += utils.hidden("type", "none");
    $tc += "<div>";
    $tc += "<label for=\"uname\" class=\"startupinp\">Username: </label>";
    $tc += "<input id=\"uname\" name=\"uname\" width=\"20\" type=\"text\" value=\"\"/>"; 
    $tc += "<br /><br />";
    $tc += "<label for=\"pword\" class=\"startupinp\">Password: </label>";
    $tc += "<input id=\"pword\" name=\"pword\" width=\"40\" type=\"password\" value=\"\"/>"; 
    $tc += "<br /><br />";
    // $tc += "<input class=\"submitbutton\" value=\"Login\" name=\"submit\" type=\"submit\" />";
    $tc += '<div id="dologin" class="formbutton">Login</div>';
    $tc += "</div>";
    $tc += "</form>";
    $tc += utils.getFooter();
    return $tc;
}

function getAuthPage(hostname, hpcode) {
    var $tc = "";
    var skin = getSkin();
    $tc += utils.getHeader(skin);
    $tc += "<h2>" + utils.APPNAME + " Hub Authorization</h2>";

    // provide welcome page with instructions for what to do
    // this will show only if the user hasn't set up HP
    // or if a reauth is requested or when converting old passwords
    $tc += "<div class=\"greeting\">";

    $tc +="<p>Here is where you link a SmartThings, Hubitat, or ISY hub to " +
            "HousePanel to gain access to your smart home devices. " +
            "You can link any number and combination of hubs. " + 
            "To link a hub you must have the following info: " +
            "API URL, Client ID, and Client Secret. " +
            "For ISY hubs enter your username in the ClientID field and " +
            "password in the Client Secret field, and enter the URL of your ISY hub for API Url." +
            "</p><br />";
    
    $tc += "<p><strong>*** IMPORTANT ***</strong> Information you provide here is secret and will be stored " +
            "on your server in a configuration file called <i>hmoptions.cfg</i> " + 
            "This is why HousePanel should <strong>*** NOT ***</strong> be hosted on a public-facing website. " +
            "A locally hosted website on a Raspberry Pi is the strongly recommended option. " +
            "HousePanel does periodically store anonymized and encrypted use frequency data. " + 
            "By proceeding you are agreeing to this practice.</p>";
    $tc += "</div>";

    if ( DONATE===true ) {
        $tc += '<br /><h4>Donations appreciated for HousePanel support and continued improvement, but not required to proceed.</h4> \
            <br /><div><form action="https://www.paypal.com/cgi-bin/webscr" method="post" target="_blank"> \
            <input type="hidden" name="cmd" value="_s-xclick"> \
            <input type="hidden" name="hosted_button_id" value="XS7MHW7XPYJA4"> \
            <input type="image" src="https://www.paypalobjects.com/en_US/i/btn/btn_donateCC_LG.gif" border="0" name="submit" alt="PayPal - The safer, easier way to pay online!"> \
            <img alt="" border="0" src="https://www.paypalobjects.com/en_US/i/scr/pixel.gif" width="1" height="1"> \
            </form></div>';
    }
    
    // get the current settings from options file
    // legacy file support removed
    // readOptions();
    var options = GLB.options;
    var rewrite = false;
    var config = options["config"];
    
    // removed old legacy file handling since it was prone to errors
    if ( array_key_exists("hubs", config) ) {
        var authhubs = clone(config["hubs"]);
    } else {
        authhubs = [];
        rewrite = true;
    }
    
    // get version and time info
    // force rewrite of options if a new version
    if ( array_key_exists("time", options) ) {
        var time = options["time"];
        var info = time.split(" @ ");
        var version = info[0].trim();
        var timestamp = parseInt(info[1].trim());
        var d = new Date(timestamp);
        var lastedit =  d.toLocaleDateString() + "  " + d.toLocaleTimeString();
        if ( version !== utils.HPVERSION ) {
            rewrite = true;
        }
    } else {
        rewrite = true;
        lastedit = "Unknown";
        version = "Pre Version 1.7";
    }

    // last one given is saved here also in main area as the new default
    // if ( rewrite ) {
    //     config["hubs"] = authhubs;
    //     options["config"] = config;
    //     writeOptions(options);
    // }
        
    // add a new blank hub at the end for adding new ones
    // note: the type must be "New" because js uses this to do stuff
    var newhub = {"hubType": "New", "hubHost": "https://graph.api.smartthings.com", 
                  "clientId": "", "clientSecret": "",
                  "userAccess": "", "userEndpt": "", "hubName": "", "hubId": "new",
                  "hubTimer": 0, "hubAccess": "", "hubEndpt": ""};
    authhubs.push(newhub);

    var webSocketUrl = "";
    if ( config.webSocketServerPort && !isNaN(parseInt(config.webSocketServerPort)) ) {
        var icolon = hostname.indexOf(":");
        if ( icolon >= 0 ) {
            webSocketUrl = "ws://" + hostname.substr(0, icolon);
        } else {
            webSocketUrl = "ws://" + hostname;
        }
        webSocketUrl = webSocketUrl + ":" + config.webSocketServerPort;
    }
    
    $tc += utils.hidden("returnURL", GLB.returnURL);
    $tc += utils.hidden("pagename", "auth");
    $tc += utils.hidden("webSocketUrl", webSocketUrl);
    $tc += "<div class=\"greetingopts\">";
    $tc += "<h3><span class=\"startupinp\">Last update: " + lastedit + "</span></h3>";
    
    // ------------------ general settings ----------------------------------
    var numnewthings = 0;
    if ( DEBUG2 ) {
        console.log( (ddbg()), "Hub auth default hub: ", GLB.defhub);
    }
    if ( GLB.defhub && GLB.defhub!=="-1" ) {
        var defhub = GLB.defhub;
        for ( var idx in allthings) {
            var thing = allthings[idx];
            if ( thing["hubnum"] === defhub ) {
                numnewthings++;
            }
        }
        var ntc= "Hub with hubId= " + defhub + " was authorized and " + numnewthings + " devices were retrieved.";
    } else {
        defhub = authhubs[0]["hubId"];
        ntc = "";
    }

    $tc += "<div id=\"newthingcount\">" + ntc + "</div>";
    $tc += "<div class='hubopt'><label for=\"pickhub\" class=\"startupinp\">Authorize Hub: </label>";
    $tc += "<select name=\"pickhub\" id=\"pickhub\" class=\"startupinp pickhub\">";

    var i= 0;
    authhubs.forEach(function(hub) {
        var hubName = hub["hubName"];
        var hubType = hub["hubType"];
        var hubId = hub["hubId"].toString();
        if ( hubId === defhub) {
            var hubselected = "selected";
        } else {
            hubselected = "";
        }
        $tc += "<option value=\"" + hubId + "\" " + hubselected + ">Hub #" + i + " " + hubName + " (" + hubType + ")</option>";
        i++;
    });
    $tc += "</select></div>";

    $tc +="<div id=\"authhubwrapper\">";
    i = 0;
    authhubs.forEach(function(hub) {
        
        // putStats(hub);
        var hubType = hub["hubType"];
        var hubId = hub["hubId"].toString();
        if ( hubId === defhub) {
            var hubclass = "authhub";
        } else {
            hubclass = "authhub hidden";
        }

        // for each hub make a section with its own form that comes back here as a post
        $tc +="<div id=\"authhub_" + hubId + "\" hubid=\"" + hubId + "\" hubtype=\"" + hubType + "\" class=\"" + hubclass + "\">";
        $tc += "<form id=\"hubform_" + hubId + "\" class=\"houseauth\" action=\"" + GLB.returnURL + "\"  method=\"POST\">";
        $tc += utils.hidden("doauthorize", hpcode);

        // we use this div below to grab the hub type dynamically chosen
        $tc += "<div id=\"hubdiv_" + hubId + "\"><label class=\"startupinp\">Hub Type: </label>";
        $tc += "<select name=\"hubType\" class=\"startupinp\">";
        var st_select = "";
        var he_select = "";
        var isy_select = "";
        if ( hubType==="SmartThings" ) { st_select = "selected"; }
        if ( hubType==="Hubitat" ) { he_select = "selected"; }
        if ( hubType==="ISY" ) { isy_select = "selected"; }
        $tc += "<option value=\"SmartThings\" " + st_select + ">SmartThings</option>";
        $tc += "<option value=\"Hubitat\" " + he_select + ">Hubitat</option>";
        $tc += "<option value=\"ISY\" " + isy_select + ">ISY</option>";
        $tc += "</select></div>";
        
        if ( !hub["hubHost"] ) {
            hub["hubHost"] = "https://graph.api.smartthings.com";
        }
        $tc += "<div><label class=\"startupinp required\">API Url: </label>";
        $tc += "<input class=\"startupinp\" title=\"Enter the hub OAUTH address here\" name=\"hubHost\" width=\"80\" type=\"text\" value=\"" + hub["hubHost"] + "\"/></div>"; 

        $tc += "<div><label class=\"startupinp required\">Client ID: </label>";
        $tc += "<input class=\"startupinp\" name=\"clientId\" width=\"80\" type=\"text\" value=\"" + hub["clientId"] + "\"/></div>"; 

        $tc += "<div><label class=\"startupinp required\">Client Secret: </label>";
        $tc += "<input class=\"startupinp\" name=\"clientSecret\" width=\"80\" type=\"text\" value=\"" + hub["clientSecret"] + "\"/></div>"; 

        $tc += "<div><label class=\"startupinp\">Fixed Access Token: </label>";
        $tc += "<input class=\"startupinp\" name=\"userAccess\" width=\"80\" type=\"text\" value=\"" + hub["userAccess"] + "\"/></div>"; 

        $tc += "<div><label class=\"startupinp\">Fixed Endpoint: </label>";
        $tc += "<input class=\"startupinp\" name=\"userEndpt\" width=\"80\" type=\"text\" value=\"" + hub["userEndpt"] + "\"/></div>"; 

        $tc += "<div><label class=\"startupinp\">Hub Name: </label>";
        $tc += "<input class=\"startupinp\" name=\"hubName\" width=\"80\" type=\"text\" value=\"" + hub["hubName"] + "\"/></div>"; 

        $tc += utils.hidden("hubId", hubId);

        $tc += "<div><label class=\"startupinp required\">Refresh Timer: </label>";
        $tc += "<input class=\"startupinp\" name=\"hubTimer\" width=\"10\" type=\"text\" value=\"" + hub["hubTimer"] + "\"/></div>"; 

        $tc += "<input class=\"hidden\" name=\"hubAccess\" type=\"hidden\" value=\"" + hub["hubAccess"] + "\"/>"; 
        $tc += "<input class=\"hidden\" name=\"hubEndpt\" type=\"hidden\" value=\"" + hub["hubEndpt"] + "\"/>"; 
        
        $tc += "<div>";
        $tc += "<input hub=\"" + i + "\" hubid=\"" + hubId + "\" class=\"authbutton hubauth\" value=\"Authorize Hub #" + i + "\" type=\"button\" />";
        // $tc += "<input hub=\"" + i + "\" hubid=\"" + hubId + "\" class=\"authbutton hubdel\" value=\"Remove Hub #" + i + "\" type=\"button\" />";
        $tc += "</div>";
        
        $tc += "</form>";
        $tc += "</div>";
        
        i++;
    });
    $tc += "</div>";
    $tc += "<div id=\"authmessage\"></div>";
    $tc += "<br><br>";
    // $tc += "<input id=\"cancelauth\" class=\"authbutton\" value=\"Return to HousePanel\" name=\"cancelauth\" type=\"button\" />";
    $tc += "<button class=\"infobutton\">Return to HousePanel</button>";

    $tc += utils.getFooter();
    return $tc;
}

function createSpecialIndex(customcnt, stype, spid) {
    var oldindex = clone(GLB.options["index"]);
    var maxindex = utils.getMaxIndex(GLB.options["index"]);

    if ( !array_key_exists("specialtiles", GLB.options["config"]) ) {
        GLB.options["config"]["specialtiles"] = {};
    }
    GLB.options["config"]["specialtiles"][stype] = customcnt;

    // remove special types of this type
    var n = stype.length + 1;
    for (var idx in oldindex) {
        if ( idx.substr(0,n) === stype + "|" ) {
            delete GLB.options["index"][idx];
        }
    }

    // add back in the right number
    var theindex;
    for ( var i=0; i<customcnt; i++) {
        var k = (i + 1).toString();
        var fid = spid + k;
        var sidnum = stype + "|" + fid;
        if ( array_key_exists(sidnum, oldindex) ) {
            theindex = parseInt(oldindex[sidnum]);
            if ( theindex > maxindex ) {
                maxindex= theindex;
            }
        } else {
            maxindex++;
            theindex = maxindex;
        }
        GLB.options["index"][sidnum] = theindex;
    }
}

// routine that renumbers all the things in your options file from 1
function refactorOptions() {

    // load in custom css strings
    var updatecss = false;
    var cnt = 0;
    var options = GLB.options;
    var oldoptions = clone(GLB.options);
    options["things"] = {};
    options["index"] = {};
    var skin = getSkin();
    var customcss = readCustomCss(skin);

    var cflags = [ ["\.p\_","\."], ["\.p\_"," "], ["\.v\_","\."], ["\.v\_"," "], ["\.t\_","\."], ["\.t\_"," "], ["\.n\_","\."], ["\.n\_"," "] ];

    for (var thingid in oldoptions["index"]) {
        var idxarr = oldoptions["index"][thingid];
        
        // only keep items that are in our current set of hubs
        if ( array_key_exists(thingid, allthings) ) {
        
            // removed the old system check since this is a new day for HP
            cnt++;
            var idx = parseInt(idxarr);

            // replace all instances of the old "idx" with the new "cnt" in customtiles
            if ( customcss && idx!==cnt ) {

                cflags.forEach(function(arr) {
                    var re = new RegExp(arr[0] + idx.toString() + arr[1], "g");
                    var newval = arr[0] + cnt.toString() + arr[1];
                    customcss = customcss.replace(re, newval);
                });

                updatecss = true;
            }

            // save the index number - fixed prior bug that only did this sometimes
            options["index"][thingid] = cnt;
        }
    }

    // now replace all the room configurations
    // this is done separately now which is much faster and less prone to error
    // foreach ($oldoptions["things"] as $room => $thinglist) {
    for (var room in oldoptions["things"]) {
        options["things"][room] = [];
        var thinglist = oldoptions["things"][room];
        for ( var thingroom in thinglist ) {
            var pidpos = thinglist[thingroom];
            var pid;
            var postop = 0;
            var posleft = 0;
            var zindex = 1;
            var customname = "";
            if ( is_array(pidpos) ) {
                var pid = parseInt(pidpos[0]);
                var postop = parseInt(pidpos[1]);
                var posleft = parseInt(pidpos[2]);
                if ( pidpos.length>3 ) {
                    zindex = parseInt(pidpos[3]);
                    customname = pidpos[4];
                }
            } else {
                pid = parseInt(pidpos);
            }

            var thingid = array_search(pid, oldoptions["index"]);
            
            if ( thingid!==false && array_key_exists(thingid, options["index"]) ) {
                var newid = options["index"][thingid];
                // use the commented code below if you want to preserve any user movement
                // otherwise a refactor call resets all tiles to their baseeline position  
                // options["things"][room].push([newid,postop,posleft,zindex,customname]);
                options["things"][room].push([newid,0,0,1,customname]);
            }
        };
    }
    
    // now adjust all custom configurations
    for (var key in oldoptions) {
        
        var lines = oldoptions[key];
        var newlines;
        var calltype;
    
        if ( ( key.substr(0,5)==="user_" ) && is_array(lines) ) {

            // allow user to skip wrapping single entry in an array
            if ( !is_array(lines[0]) ) {
                lines = [lines];
            }

            newlines = [];
            for (var k in lines) {
                var msgs = lines[k];
                calltype = msgs[0].toUpperCase().trim();

                // switch to new index for links
                // otherwise we just copy the info over to options
                if ( calltype==="LINK" ) {
                    var linkid = msgs[1].toString().trim();
                    var thingid = array_search(linkid, oldoptions["index"]);
                    if ( thingid!==false && array_key_exists(thingid, options["index"]) ) {
                        msgs[1] = options["index"][thingid].toString();
                    }
                }
                newlines.push(msgs);
            }
            if ( newlines.length ) {
                options[key] = newlines;
            }
        }
    }
    
    // TODO... not yet working so don't save

    // save our updated options and our custom style sheet file
    // writeOptions(options);

    // if ( updatecss ) {
    //     writeCustomCss(skin, customcss);
    // }
}

// emulates the PHP function for javascript objects or arrays
function array_search(needle, arr) {
    var key = false;
    if ( is_object(arr) ) {
        try {
            for (var t in arr) {
                if ( arr[t]===needle || arr[t].toString() === needle.toString() ) {
                    return t;
                }
            } 
        }
        catch(e) { key = false; }
    }
    return key;
}

function in_array(needle, arr) {
    if ( !is_object(arr) ) {
        return false;
    } else {
        for (var i in arr) {
            var item = arr[i];
            if ( item===needle || item.toString()===needle.toString() ) {
                return true;
            }
        }
        return false;
    }
}

function is_array(obj) {
    if ( typeof obj === "object" ) {
        return Array.isArray(obj);
    } else {
        return false;
    }
}

function is_object(obj) {
    return ( typeof obj === "object" );
}

function array_key_exists(key, arr) {
    if ( !is_object(arr) ) {
        return false;
    }
    return ( typeof arr[key] !== "undefined" );
}

function ddbg() {
    var d = new Date();
    var dstr = d.toLocaleDateString() + "  " + d.toLocaleTimeString() + " ";
    return dstr;
}

// returns true if the index is in the room things list passed
function inroom($idx, $things) {
    var $found = false;
    var $idxint = parseInt($idx);
    for (var i in $things) {
        var $arr = $things[i];
        var $thingindex = is_array($arr) ? $arr[0] : parseInt($arr);
        if ( $idxint === $thingindex ) {
            $found = i;
            break;
        }
    }
    return $found;
}

// this is the main page rendering function
// each HousePanel tab is generated by this function call
// each page is contained within its own form and tab division
// notice the call of $cnt by reference to keep running count
function getNewPage(cnt, roomtitle, kroom, things) {
    var $tc = "";
    var roomname = roomtitle;
    $tc += "<div id=\"" + roomname + "-tab\">";
    $tc += "<form title=\"" + roomtitle + "\" action=\"#\">";
    
    // add room index to the id so can be style by number and names can duplicate
    // no longer use room number for id since it can change around
    // switched this to name - not used anyway other than manual custom user styling
    // if one really wants to style by room number use the class which includes it
    $tc += "<div id=\"panel-" + roomname + "\" title=\"" + roomtitle + "\" class=\"panel panel-" + kroom + " panel-" + roomname + "\">";

    // the things list can be integers or arrays depending on drag/drop
    var idxkeys = Object.keys(GLB.options["index"]);
    var idxvals = Object.values(GLB.options["index"]);
    var zcolor = 200;
    things.forEach(function(kindexarr) {
        
        // get the offsets and the tile id
        var kindex = parseInt(kindexarr[0]);
        var postop = kindexarr[1];
        var posleft = kindexarr[2];
        var zindex = 1;
        var customname = "";

        if ( kindexarr.length > 3 ) {
            zindex = kindexarr[3];
            customname = kindexarr[4];
        }
        var i = idxvals.findIndex(idx => idx === kindex);
        var thingid = idxkeys[i];
        
        // if our thing is still in the master list, show it
        if (thingid && allthings[thingid]) {
            var thesensor = allthings[thingid];

            if ( typeof thesensor==="object" ) {

                // adjust the zindex to show on top of others if there is a color field
                // this starts at 199 and counts down to 100 assuming fewer than 100 color things on a page
                if ( array_key_exists("color", thesensor.value) && zindex < 100 ) {
                    zcolor--;
                    zindex = zcolor;
                    if ( zcolor < 100 ) { zcolor = 200; }
                }

                // keep running count of things to use in javascript logic
                cnt++;
                $tc += makeThing(cnt, kindex, thesensor, roomtitle, postop, posleft, zindex, customname, false);
            }
        }
    });

    // end the form and this panel
    $tc += "</div></form>";

    // end this tab which is a different type of panel
    $tc +="</div>";
    return {tc: $tc, cnt: cnt};
}

// function to search for triggers in the name to include as classes to style
function processName(thingname, thingtype) {

    // get rid of 's and split along white space
    var subtype = "";
    var ignore2 = utils.getTypes();
    ignore2.push("panel");
    var lowname = thingname.toLowerCase();
    var pattern = /[,;:!-\'\*\<\>\{\}\+\&\%]/g;
    var s1 = lowname.replace(pattern,"");
    var subopts = s1.split(" ");
    var k = 0;
    subopts.forEach(function(str) {
        str= str.trim();
        var numcheck = +str;
        if ( str.length>1 && ignore2.indexOf(str)===-1 && str!==thingtype && isNaN(numcheck) &&
             str.indexOf("::")===-1 && str.indexOf("://")===-1 && str.length<20 ) {
            if ( k < 3 ) {
                subtype += " " + str;
                k++;
            }
        }
    });
    return subtype;
}

// returns proper html to display an image, video, frame, or custom
// if some other type is requested it returns a div of requested size and skips search
// searches in main folder and media subfolder for file name
function returnFile(thingvalue, thingtype) {

    // do nothing if this isn't a special tile
    var specialtiles = utils.getSpecials();
    if ( !array_key_exists(thingtype, specialtiles) ) {
        return thingvalue;
    }

    // get the name, width, height to create
    if ( array_key_exists("name", thingvalue) ) {
        var fn = thingvalue["name"];
    } else {
        fn = specialtiles[thingtype][0];
        thingvalue["name"] = fn;
    }
    if ( array_key_exists("width", thingvalue) ) {
        var fw = thingvalue["width"];
    } else {
        fw = specialtiles[thingtype][1];
        thingvalue["width"] = fw;
    }
    var fwnum = parseInt(fw);
    if ( isNaN(fwnum) ) { fwnum = 900; }

    if ( array_key_exists("height", thingvalue) ) {
        var fh = thingvalue["height"];
    } else {
        fh = specialtiles[thingtype][2];
        thingvalue["height"] = fh;
    }
    var fhnum = parseInt(fh);
    if ( isNaN(fhnum) ) { fhnum = 600; }

    var grtypes;
    switch (thingtype) {
        case "image":
            grtypes = [".jpg",".png",".gif"];
            break;
        case "video":
            grtypes = [".mp4",".ogg"];
            break;
        case "frame":
            grtypes = [".html",".htm"];
            break;
        case "custom":
        case "blank":
            grtypes = [".jpg",".png",".gif",".mp4",".ogg",".html",".htm"];
            break;
        // for blanks never load a file
        // but we do set the name above
        // below we set the tile size for blanks and others
        default:
            grtypes = null;
            break;
    }

    // this block sets the file name to load based on extension requested
    var $vn = "";
    var $fext = "";
    var skin = getSkin();

    function getext(fname) {
        var ipos = fname.indexOf(".");
        var ext = "";
        if ( ipos !== "-1" ) {
            ext = fname.substr(ipos);
        }
        return ext;
    }

    if ( grtypes ) {

        // first check names without extensions
        if (fs.existsSync(fn)) {
            $vn = fn;
            $fext = getext(fn);
        } else if (fs.existsSync("media/"+ fn)) {
            $vn = "media/" + fn;
            $fext = getext(fn);
        } else if (fs.existsSync(skin + "/media/"+ fn)) {
            $vn = skin + "/media/" + fn;
            $fext = getext(fn);
        } else {

            // next check names with extensions and in media folders including skin
            grtypes.forEach(function($ext) {
                if ( $vn==="" && fs.existsSync(fn + $ext) ) {
                    $vn = fn + $ext;
                    $fext = $ext;
                } else if ( $vn==="" && fs.existsSync("media/" + fn + $ext) ) {
                    $vn = "media/" + fn + $ext;
                    $fext = $ext;
                } else if ( $vn==="" && fs.existsSync(skin + "/media/" + fn + $ext) ) {
                    $vn = skin + "/media/" + fn + $ext;
                    $fext = $ext;
                }
            });
        }
    }

    // console.log("type:", thingtype, " fn: ", fn, " size: ", fw, "x", fh,  " $fext: ", $fext, " $vn: ", $vn);
    var $v = "";
    var mediafile = "";

    // process things if file was found
    if ( $vn ) {

        // if file has an extension then remove the dot
        if ( $fext.length && $fext.substr(0,1)==="." ) {
            $fext = $fext.substr(1);
        }

        switch ($fext) {
            // image files
            case "jpg":
            case "png":
            case "gif":
                $v= "<img width=\"" + fw + "\" height=\"" + fh + "\" src=\"" + $vn + "\">";
                mediafile = $vn;
                break;

            // video files
            case "mp4":
            case "ogg":
                $v= "<video width=\"" + fw + "\" height=\"" + fh + "\" autoplay>";
                $v+= "<source src=\"" + $vn + "\" type=\"video/" + $fext + "\">";
                $v+= "Video Not Supported</video>";

                mediafile= $vn;
                break;
                
            // render web pages in a web iframe
            case "html":
            case "htm":
                $v = "<iframe width=\"" + fw + "\" height=\"" + fh + "\" src=\"" + $vn + "\" frameborder=\"0\"></iframe>";
                mediafile= $vn;
                break;

            // otherwise just show a blank just like below
            default:
                if ( thingtype==="custom" ) {
                    $v = "";
                } else {
                    $v = "<div style=\"width: " + fw + "px; height: " + fh + "px;\"></div>";
                }
                break;
        }
    
    // if file wasn't found just make an empty block of the requested size
    // but for custom tiles don't do this since we can use blanks to make empty block sizes
    // for custom tiles only create a block of size if there is content to be seen
    } else {
        if ( thingtype==="custom" ) {
            $v = "";
        } else {
            $v = "<div style=\"width: " + fw + "px; height: " + fh + "px;\"></div>";
        }
    }

    thingvalue[thingtype] = $v;

    // TODO - figure out a better way to show large images
    if ( mediafile ) {
        thingvalue["_media_"] = mediafile;
    }
    return thingvalue;
}

// function to create frame2.html with AccuWeather for a city
// the City Name, Country Code, and the Location Code from AccuWeather must be provided
// writeAccuWeather("ann-arbor-mi","us","329380");
function writeAccuWeather(city, region, code) {
    const acid = "awcc1531959686475";
    const unit = "F";

    var rcitycode = region + "/" + city + "/" + code + "/weather-forecast/" + code;
    var $tc = "<!DOCTYPE html>";
    $tc += "<html><body>";
    $tc += "<a href=\"https://www.accuweather.com/en/" + rcitycode + "\" class=\"aw-widget-legal\">";
    $tc += "</a><div id=\"" + acid + "\" class=\"aw-widget-current\"  data-locationkey=\"" + code + "\" data-unit=\"" + unit + "\" data-language=\"en-us\" data-useip=\"false\" data-uid=\"" + acid + "\"></div>";
    $tc += "<script type=\"text/javascript\" src=\"https://oap.accuweather.com/launch.js\"></script>";
    $tc += "</body></html>";
    fs.writeFileSync("Frame2.html", $tc, {encoding: "utf8", flag:"w"});
}

// function to create Frame1.html with WeatherWidget for a city
// the City Name must be provided
// writeForecastWidget("ann-arbor","Ann Arbor","42d28n83d74");
function writeForecastWidget(city, region, code) {

    // if user doesn't provide a code, use my default account which should work
    // and by default no region specified sets it to the city with -'s replaced with spaces
    if ( !city ) {
        return;
    }
    if ( !region ) {
        var words = city.replace("-"," ").split(" ");
        region = "";
        for ( var i in words ) {
            region += words[i].substr(0,1).toUpperCase() + words[i].substr(1).toLowerCase() + " ";
        }
        if ( !region ) {
            region = city;
        }

    }
    if ( !code ) {
        code = "42d28n83d74";
    }

    var $tc = `
    <!DOCTYPE html>
    <html>
        <head>
            <title>Weather Forecast</title>
            <meta charset="UTF-8">
            <meta name="viewport" content="width=device-width, initial-scale=1.0">
            <script>
                !function(d,s,id){var js,fjs=d.getElementsByTagName(s)[0];
                if(!d.getElementById(id)){js=d.createElement(s);
                js.id=id;js.src="https://weatherwidget.io/js/widget.min.js";
                fjs.parentNode.insertBefore(js,fjs);}}(document,"script","weatherwidget-io-js");
            </script>
        </head>
        <body style="margin: 0;">
        <a class="weatherwidget-io" href="https://forecast7.com/en/{{code}}/{{city}}/?unit=us" data-label_1="{{region}}" data-label_2="Weather Forecast" data-icons="Climacons" data-days="7" data-theme="original" ></a>
        </body>
    </html>`;

    $tc = $tc.replace("{{city}}", city);
    $tc = $tc.replace("{{region}}", region);
    $tc = $tc.replace("{{code}}", code);
    fs.writeFileSync("Frame1.html", $tc, {encoding: "utf8", flag:"w"});
}

function getWeatherIcon(num) {
    if ( isNaN(+num) ) {
        var iconstr = num;
    } else {
        num = num.toString();
        if ( num.length < 2 ) {
            num = "0" + num;
        }

        // uncomment this to use ST's copy. Default is to use local copy
        // so everything stays local
        var iconimg = "media/weather/" + num + ".png";
        iconstr = "<img src=\"" + iconimg + "\" alt=\"" + num + "\" width=\"80\" height=\"80\">";
    }
    return iconstr;
}

// removes dup words from a string
function uniqueWords(str) {
    var arr = str.split(" ");
    var newarr = [];
    arr.forEach(function(word) {
        word = word.trim();
        if ( !newarr.includes(word) ) {
            newarr.push(word);
        }
    });
    var newstr = newarr.join(" ");
    return newstr;
}

function makeThing(cnt, kindex, thesensor, panelname, postop, posleft, zindex, customname, wysiwyg) {
    var $tc = "";

    var thingvalue = thesensor["value"];

    // handle special tiles
    var thingtype = thesensor["type"];
    var bid = thesensor["id"];
    thingvalue = setValOrder(thingvalue);
    // var defname = thesensor["name"] || "Unknown";

    // set type to hint if one is given
    // this is to support ISY nodes that all register as ISY types
    // so we can figure out what type of tile this is closest to
    // this also is used to include the hub type in the tile
    var hint = thesensor["hint"];
    
    var hubnum = "-1";
    var refresh = "normal";
    if ( array_key_exists("hubnum", thesensor) ) {
        hubnum = thesensor["hubnum"];
    }

    // use override if there
    if ( array_key_exists("refresh", thesensor) ) {
        refresh = thesensor["refresh"];
    }
    if ( array_key_exists("refresh", thingvalue) ) {
        refresh = thingvalue["refresh"];
    }

    // fix any name that is custom
    var subtype = processName(thingvalue["name"], thingtype);
    postop= parseInt(postop);
    posleft = parseInt(posleft);
    zindex = parseInt(zindex);
    var idtag = "t-" + cnt;
    if ( wysiwyg ) {
        idtag = wysiwyg;
    }

    // set the custom name
    // if ( customname ) { 
    //     thingvalue["name"] = customname;
    // } else if (!thingvalue["name"]) {
    //     thingvalue["name"] = defname;
    // }

    // set the custom name
    // limit to 132 visual columns but show all for special tiles and custom names
    // now we use custom name in both places
    // var thingname = thingvalue["name"];
    var thingname = thesensor["name"];
            
    // check if there is a color key - use to set color
    // no longer print this first since we need to include in custom logic
    var bgcolor= "";
    if ( array_key_exists("color", thingvalue) ) {
        var cval = thingvalue["color"];
        if ( cval.match(/^#[abcdefABCDEF\d]{6}/) !== null ) {
            bgcolor = " style=\"background-color:"+cval+";\"";
        } else {
            cval = "#FFFFFF";
            bgcolor = " style=\"background-color:"+cval+";\"";
        }
    }
    
    // wrap thing in generic thing class and specific type for css handling
    $tc=   "<div id=\""+idtag+"\" aid=\""+cnt+"\" hub=\""+hubnum+"\" tile=\""+kindex+"\" bid=\""+bid+"\" type=\""+thingtype+"\" ";
    
    // get the class setting - this is set up to make the p_ last
    // we also use the unique function to remove dups
    var classstr = "thing " + thingtype+"-thing" + subtype;
    if ( hint ) {
        classstr += " " + hint.replace(/\./g,"_");
    }
    classstr += " p_"+kindex;
    // classstr = uniqueWords(classstr);

    $tc += "panel=\""+panelname+"\" class=\""+classstr+"\" ";
    $tc += "refresh=\""+refresh+"\"";
    if ( (postop!==0 && posleft!==0) || zindex>1 ) {
        $tc += " style=\"position: relative; left: "+posleft+"px; top: "+postop+"px; z-index: "+zindex+";\"";
    }
    $tc += ">";


    // same thingname field for each tile with the original name
    $tc += "<div aid=\""+cnt+"\" type=\""+thingtype+"\" title=\""+thingname+"\" class=\"thingname "+thingtype+" t_"+kindex+"\" id=\"s-"+cnt+"\">";
    $tc += thingname;
    $tc += "</div>";

    // special handling for weather tiles
    // this allows for feels like and temperature to be side by side
    // and it also handles the inclusion of the icons for status
    if (thingtype==="weather") {
        if ( !thingvalue["name"] ) {
            thingvalue["name"] = thingname;
        }
        $tc += putElement(kindex, cnt, 0, thingtype, thingvalue["name"], "name");
        $tc += putElement(kindex, cnt, 1, thingtype, thingvalue["city"], "city");
        $tc += "<div class=\"weather_temps\">";
        $tc += putElement(kindex, cnt, 2, thingtype, thingvalue["temperature"], "temperature");
        $tc += putElement(kindex, cnt, 3, thingtype, thingvalue["feelsLike"], "feelsLike");
        $tc += "</div>";
        
        // use new weather icon mapping
        $tc += "<div class=\"weather_icons\">";
        var wiconstr = getWeatherIcon(thingvalue["weatherIcon"]);
        var ficonstr = getWeatherIcon(thingvalue["forecastIcon"]);
        $tc += putElement(kindex, cnt, 4, thingtype, wiconstr, "weatherIcon");
        $tc += putElement(kindex, cnt, 5, thingtype, ficonstr, "forecastIcon");
        $tc += "</div>";
        // $tc += putElement(kindex, cnt, 6, thingtype, "Sunrise: " + thingvalue["localSunrise"] + " Sunset: " + thingvalue["localSunset"], "sunriseset");
        
        var j = 6;
        for ( var tkey in thingvalue ) {
            if (tkey!=="temperature" &&
                tkey!=="feelsLike" &&
                tkey!=="name" &&
                tkey!=="city" &&
                tkey!=="weather" &&
                tkey!=="weatherIcon" &&
                tkey!=="forecastIcon" &&
                tkey!=="alertKeys" && 
                typeof tkey==="string" && tkey.substring(0,5)!=="user_" ) 
            {
                var helperkey = "user_" + tkey;
                var tval = thingvalue[tkey];
                // $tc += putElement(kindex, cnt, j, thingtype, tval, tkey);
                if (  array_key_exists(helperkey, thingvalue) && thingvalue[helperkey] && thingvalue[helperkey].substr(0,2)==="::" ) {
                    var helperval = thingvalue[helperkey];
                    $tc += putLinkElement(bid, helperval, kindex, cnt, j, thingtype, tval, tkey, subtype, bgcolor);
                } else {
                    $tc += putElement(kindex, cnt, j, thingtype, tval, tkey, subtype, bgcolor);
                }
                j++;
            }
        };
        
    } else {
        // unfortunately, this no longer works because Google changed how they return image searches
        // but fortunately the new Sonos audio devices return an image url that we now use
        //        if ( $thingtype==="music" ) {
        //            $thingvalue = getMusicArt($thingvalue);
        //        }
        
        // create a thing in a HTML page using special tags so javascript can manipulate it
        // multiple classes provided. One is the type of thing. "on" and "off" provided for state
        // for multiple attribute things we provide a separate item for each one
        // the first class tag is the type and a second class tag is for the state - either on/off or open/closed
        // ID is used to send over the groovy thing id number passed in as $bid
        // for multiple row ID's the prefix is a$j-$bid where $j is the jth row

        // removed this old check since things are now always objects
        // if (typeof thingvalue === "object") {
        var j = 0;
        
        // create on screen element for each key
        // this includes a check for helper items created in tile customizer
        for ( var tkey in thingvalue ) {
            var helperkey = "user_" + tkey;
            var tval = thingvalue[tkey];

            // check value for "json" strings
            try {
                var jsontval = JSON.parse(tval);
            } catch(jerr) {
                jsontval = null;
            }
            
            // handle other cases where the value is an object like audio
            if ( jsontval && typeof jsontval==="object" && !array_key_exists(helperkey, thingvalue) ) {
                for (var jtkey in jsontval ) {
                    var jtval = jsontval[jtkey];
                    if ( jtval ) {
                        $tc += putElement(kindex, cnt, j, thingtype, jtval, jtkey, subtype, bgcolor);
                        j++;
                    }
                }
            }
            
            else if ( typeof tkey==="string" && tkey.substring(0,5)!=="user_" && (typeof tval==="string" || typeof tval==="number") ) { 
                
                // new logic for links - they all now follow the format ::LINK::code
                // print a hidden field for user web calls and links
                // this is what enables customization of any tile to happen
                // ::type::LINK::tval  or ::LINK::tval
                // this special element is not displayed and sits inside the overlay
                // we only process the non helpers and look for helpers in same list
                if (  array_key_exists(helperkey, thingvalue) && thingvalue[helperkey] && thingvalue[helperkey].substr(0,2)==="::" ) {
                    var helperval = thingvalue[helperkey];
                    $tc += putLinkElement(bid, helperval, kindex, cnt, j, thingtype, tval, tkey, subtype, bgcolor);
                } else {
                    $tc += putElement(kindex, cnt, j, thingtype, tval, tkey, subtype, bgcolor);
                }

                j++;
            }
        }
    }

    $tc += "</div>";
    
    return $tc;
}

// compare this logic with how siblings are defined
// in the getCustomTile function
function putLinkElement(bid, helperval, kindex, cnt, j, thingtype, tval, tkey, subtype, bgcolor) {

    var linktype = thingtype;
    var linkbid = bid;
    var realsubid = tkey;
    var idx = thingtype + "|" + bid;

    var ipos = helperval.indexOf("::",2);
    var command = helperval.substring(2, ipos);
    var linkval = helperval.substring(ipos+2);

    // get info for links but skip if the link had an error
    if ( command==="LINK" && linkval && linkval!=="error" && linkval.indexOf("|")!==-1 ) {
        var lidx = linkval;
        linkval = GLB.options.index[lidx];
        var idxitems = lidx.split("|");
        linktype = idxitems[0];
        linkbid = idxitems[1];

        // use the link value - if subid isn't there look for subid's that form the beginning of our link subid
        if ( array_key_exists(lidx, allthings) ) {
            var linktileval = allthings[lidx]["value"];
            if ( array_key_exists(realsubid, linktileval) ) {
                tval = linktileval[realsubid];
            } else {
                for (var ltkey in linktileval) {
                    if ( realsubid.startsWith(ltkey) ) {
                        realsubid = ltkey;
                        tval = linktileval[ltkey];
                        break;
                    }
                }
            }

            // save the value in our main array for user queries and api calls
            // note that all screen refreshes will come here again and update it
            // but we skip this for non permanent things being made for visual sake
            if ( cnt!== 0 ) {
                allthings[idx]["value"][tkey] = tval;
            }
        } else {
            linkval = "dum";
        }
    } else if ( command==="URL" || command==="POST" || command==="PUT" || command==="GET" ) {
        linkval = decodeURI(linkval);
    } else {
        // neuter out linkvalsince we no longer use it
        linkval = linkval || "dum";
    }

    // use the original type here so we have it for later
    // but in the actual target we use the linktype
    // var sibling= "<div aid=\""+cnt+"\" linktype=\""+linktype+"\" value=\""+tval+"\" linkval=\""+linkval+"\" command=\""+command+"\" subid=\""+realsubid+"\" linkbid=\"" + linkbid + "\" class=\"user_hidden\"></div>";
    var sibling= "<div aid=\""+cnt+"\" linktype=\""+linktype+"\" linkval=\""+linkval+"\" command=\""+command+"\" subid=\""+realsubid+"\" linkbid=\"" + linkbid + "\" class=\"user_hidden\"></div>";
    if ( DEBUG10 ) {
        console.log( (ddbg()), "bid: ", bid, " helperval: ", helperval, " sibling: ", sibling);
    }
    var $tc = putElement(kindex, cnt, j, linktype, tval, tkey, subtype, bgcolor, sibling, realsubid);
    return $tc;
}

// cleans up the name of music tracks for proper html page display
// no longer trim the name because that breaks album art
function fixTrack(tval) {
    if ( !tval || tval.trim()==="" ) {
        tval = "None"; 
    }
    return tval;
}

function putElement(kindex, i, j, thingtype, tval, tkey, subtype, bgcolor, sibling, realsubid) {
    var $tc = "";
    var aitkey = "a-" + i + "-" + tkey;
    var pkindex = " p_" + kindex;
    var aidi = "<div aid=\"" + i + "\"";
    var ttype = " type=\"" + thingtype + "\"";
    var colorval = "";
    if ( typeof subtype === "undefined" ) {
        subtype = "";
    } else if ( typeof subtype === "string" && subtype.substr(0,1)!==" " ) {
        subtype = " " + subtype;
    }
    if ( bgcolor && (tkey==="hue" || tkey==="saturation") ) {
        colorval = bgcolor;
    }
    if ( !tval ) { tval = ""; }

    // do nothing if this is a rule and rules are disabled
    if ( !ENABLERULES && typeof tval==="string" && tval.substr(0,6)==="RULE::" ) {
        return $tc;
    }
        
    // fix thermostats to have proper consistent tags
    // this is supported by changes in the .js file and .css file
    if ( tkey==="hue" || tkey==="saturation" ||
         tkey==="heatingSetpoint" || tkey==="coolingSetpoint" || 
         (tkey.startsWith("int_") && thingtype==="isy") ||
         (tkey.startsWith("state_") && thingtype==="isy") ) {

        var modvar;
        if ( tkey.startsWith("int_") || tkey.startsWith("state_") ) {
            modvar = tkey + " variable";
        } else {
            modvar = tkey;
        }

        // fix thermostats to have proper consistent tags
        // this is supported by changes in the .js file and .css file
        $tc += "<div class=\"overlay " + tkey + " " + subtype + " v_" + kindex + "\">";
        if (sibling) { $tc += sibling; }
        $tc += aidi + " subid=\"" + tkey + "-dn\" title=\"" + thingtype + " down\" class=\"" + thingtype + " " + modvar + "-dn " + pkindex + "\"></div>";
        $tc += aidi + " subid=\"" + tkey + "\" title=\"" + thingtype + " " + tkey + "\" class=\"" + thingtype + " " + modvar + pkindex + "\"" + colorval + " id=\"" + aitkey + "\">" + tval + "</div>";
        $tc += aidi + " subid=\"" + tkey + "-up\" title=\"" + thingtype + " up\" class=\"" + thingtype + " " + modvar + "-up " + pkindex + "\"></div>";
        $tc += "</div>";
    
    
    // process analog clocks signalled by use of a skin with a valid name other than digital
    } else if ( thingtype==="clock" && tkey==="skin" && tval && tval!=="digital" ) {
        $tc += "<div class=\"overlay "+tkey+" v_"+kindex+"\">";
        if (sibling) { $tc += sibling; }
        $tc += aidi + ttype + "\"  subid=\""+tkey+"\" title=\"Analog Clock\" class=\"" + thingtype + subtype + pkindex + "\" id=\""+aitkey+"\">" +
              "<canvas id=\"clock_"+i+"\" class=\""+tval+"\"></canvas></div>";
        $tc += "</div>";
    } else {
        // add state of thing as a class if it isn't a number and is a single word
        // also prevent dates and times from being added
        // also do not include any music album or artist names in the class
        // and finally if the value is complex with spaces or other characters, skip
        // also skip links and rules and anything longer than 30 characters
        var extra;
        if ( tkey==="time" || tkey==="date" || tkey==="color" || typeof tval!=="string" || tval==="" ||
                   (tval.indexOf(" ")!==-1) ||
                   (tkey.substr(0,6)==="event_") || tkey.startsWith("_") ||
                   tkey==="trackDescription" || tkey==="currentArtist" || tkey==="groupRole" ||
                   tkey==="currentAlbum" || tkey==="trackImage" || tkey==="mediaSource" ||
                   tkey==="weatherIcon" || tkey==="forecastIcon" ||
                   !isNaN(+tval) || thingtype===tval ||
                   (tval.substr(0,7)==="number_") || 
                   (tval.indexOf("://")!==-1) ||
                   (tval.indexOf("::")!==-1) || tval.length > 30 ) {
            extra = "";
        } else {
            extra = " " + tval;
        }
        
        // fix track names for groups, empty, and super long
        if (tkey==="trackDescription") {
            tval = fixTrack(tval);
        // change this over to a css so we can style it if needed
        } else if (tkey==="trackImage") {
            if ( tval.substr(0,4) === "http" ) {
                // tval = "<img width='120' height='120' src='" + tval + "'>";
                tval = "<img class='trackImage' src='" + tval + "'>";
            }
        } else if ( tkey === "battery") {
            var powmod = parseInt(tval);
            powmod = powmod - (powmod % 10);
            tval = "<div style=\"width: " + tval + "%\" class=\"ovbLevel L" + powmod.toString() + "\"></div>";
        } else if ( tval && typeof tval==="string" && tval.startsWith("rtsp:") && tval.length > 40 ) {
            extra = extra + " rtsp";
            // tval = "<div class=\"rtspwrap\">" + tval + "</div>";
        }

        // hide variable precisions
        if ( thingtype==="isy" && tkey.startsWith("prec_") ) {
            extra += " user_hidden";
        }
        
        // for music status show a play bar in front of it
        // now use the real item name and back enable old one
        // note that we add the sibling to the music controls
        // so that linked tiles will operate properly
        // only one sibling for all the controls. The js file deals with this.
        if (tkey==="musicstatus" || (thingtype==="music" && tkey==="status") ) {
            $tc += "<div class=\"overlay music-controls" + subtype + " v_"+kindex+"\">";
            if (sibling) { $tc += sibling; }
            $tc += aidi + " subid=\"music-previous\" title=\"Previous\" class=\""+thingtype+" music-previous" + pkindex + "\"></div>";
            $tc += aidi + " subid=\"music-pause\" title=\"Pause\" class=\""+thingtype+" music-pause" + pkindex + "\"></div>";
            $tc += aidi + " subid=\"music-play\" title=\"Play\" class=\""+thingtype+" music-play" + pkindex + "\"></div>";
            $tc += aidi + " subid=\"music-stop\" title=\"Stop\" class=\""+thingtype+" music-stop" + pkindex + "\"></div>";
            $tc += aidi + " subid=\"music-next\" title=\"Next\" class=\""+thingtype+" music-next" + pkindex + "\"></div>";
            $tc += "</div>";
        }

        // ignore keys for single attribute items and keys that match types
        var tkeyshow;
        if ( (tkey===thingtype ) || 
             (tkey==="value" && j===0) ) {
            tkeyshow= "";
        // add confirm class for keys that start with c$_ so we can treat like buttons
        } else if ( tkey.substr(0,3) === "c__" ) {
            tkey = tkey.substr(3);
            tkeyshow = " " + tkey + " confirm";
        } else {
            tkeyshow = " " + tkey;
        }

        // add real sub for linked tiles
        if ( realsubid && realsubid!==tkey ) {
            tkeyshow = tkeyshow + " " + realsubid;
        }
         // include class for main thing type, the subtype, a sub-key, and a state (extra)
        // also include a special hack for other tiles that return number_ to remove that
        // this allows KuKu Harmony to show actual numbers in the tiles
        // finally, adjust for level sliders that can't have values in the content
        // hide all of the ISY uom items - couid do in CSS but this is easier and faster
        if ( thingtype==="isy" && tkey.startsWith("uom_") ) {
            $tc += "<div class=\"overlay "+tkey+" hidden v_"+kindex+"\">";
        } else {
            $tc += "<div class=\"overlay "+tkey+" v_"+kindex+"\">";
        }
        if (sibling) { $tc += sibling; }
        if ( tkey === "level" || tkey==="colorTemperature" || tkey==="volume" || tkey==="groupVolume" ) {
            $tc += aidi + ttype + " subid=\""+tkey+"\" value=\""+tval+"\" title=\""+tkey+"\" class=\"" + thingtype + tkeyshow + pkindex + "\" id=\"" + aitkey + "\"></div>";
        } else if ( thingtype==="other" && typeof tval==="string" && tval.substr(0,7)==="number_" ) {
            var numval = tkey.substring(8);
            $tc += aidi + ttype + " subid=\"" + tkey+"\" title=\""+tkey+"\" class=\"" + thingtype + subtype + tkeyshow + pkindex + "\" id=\"" + aitkey + "\">" + numval + "</div>";
        } else {
            if ( typeof tval==="string" && tval.substr(0,6)==="RULE::" && subtype!=="rule" ) {
                tkeyshow += " rule";
            }
            $tc += "<div aid=\""+i+"\" type=\""+thingtype+"\"  subid=\""+tkey+"\" title=\""+tkey+"\" class=\"" + thingtype + subtype + tkeyshow + pkindex + extra + "\" id=\"" + aitkey + "\">" + tval + "</div>";
        }
        $tc += "</div>";
    }
    return $tc;
}

function getCustomCount(stype, defcount) {
    var customcnt = defcount;
    if ( array_key_exists("specialtiles", GLB.options.config) ) {
        var specialarr = GLB.options.config["specialtiles"];
        if ( array_key_exists(stype, specialarr) ) {
            customcnt = parseInt(specialarr[stype]);
            if ( isNaN(customcnt) || customcnt < 1 ) { 
                customcnt = defcount; 
            }
        }
    }
    return customcnt;
}

function getCustomName(defbase, idx, cnum) {
    // make the default name start with a capital letter if we give a number
    var defname;
    if ( cnum && typeof cnum==="number" || typeof cnum==="string") {
        defname = defbase.substr(0,1).toUpperCase() + defbase.substr(1);
        defname = defname + cnum;
    } else {
        defname = defbase;
    }
    return defname;
}

function getFormattedDate(fmtdate, d, clockid) {
    var weekdays = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
    var months = ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"];
    if ( typeof d=== "undefined" || !d ) {
        d = new Date();
    }
    var dofw = d.getDay();
    var mofy = d.getMonth();
    var weekday = weekdays[dofw];
    var month = months[mofy];
    var day = d.getDate().toString();
    var zday = day;
    if ( zday.length < 2 ) {
        zday = "0" + zday;
    }
    var year = d.getFullYear().toString();
    var datestr;

    // set date and weekday to react to custom values
    if ( fmtdate && typeof fmtdate==="string" ) {
        datestr = fmtdate;
        if ( fmtdate.indexOf("Y")!==-1 ) {
            datestr = datestr.replace("Y", year);
        }
        if ( fmtdate.indexOf("y")!==-1 ) {
            datestr = datestr.replace("y", year.substr(-2));
        }
        if ( fmtdate.indexOf("D")!==-1 ) {
            datestr = datestr.replace("D", zday);
        }
        if ( fmtdate.indexOf("d")!==-1 ) {
            datestr = datestr.replace("d", day);
        }
        if ( fmtdate.indexOf("M")!==-1 ) {
            datestr = datestr.replace("M", month);
        }
        if ( fmtdate.indexOf("m")!==-1 ) {
            datestr = datestr.replace("m", month.substr(0,3));
        }
        if ( fmtdate.indexOf("W")!==-1 ) {
            datestr = datestr.replace("W", weekday);
        }
        if ( fmtdate.indexOf("w")!==-1 ) {
            datestr = datestr.replace("w", weekday.substr(0,3));
            weekday = weekday.substr(0,3);
        }
    } else {
        fmtdate = "M d, Y";
        datestr = month + " " + day + ", " + year;
    }
    // console.log("\n ****** getFormattedDate ******\n clockid: ", clockid," fmtdate: ", fmtdate," datestr: ", datestr, " weekday: ", weekday);
    var retobj = {fmt_date: fmtdate, date: datestr, week: weekday};
    return retobj;
}

function getFormattedTime(fmttime, d, clockid) {
    if ( typeof d=== "undefined" || !d ) {
        d = new Date();
    }

    var timezone = d.getTimezoneOffset().toString();
    var hour24 = d.getHours();
    var hour = hour24;
    var min = d.getMinutes().toString();
    var sec = d.getSeconds().toString();

    var zmin = min;
    if ( zmin.length < 2 ) { 
        zmin = "0" + min.toString();
    }
    var zsec = sec;
    if ( zsec.length < 2 ) { 
        zsec = "0" + zsec;
    }
    if ( hour24=== 0 ) {
        hour = "12";
    } else if ( hour24 > 12 ) {
        hour = (+hour24 - 12).toString();
    } else {
        hour = hour.toString();
    }
    var zhour = hour;
    if ( zhour.length < 2 ) {
        zhour = "0" + zhour;
    }
    var zhour24 = hour24;
    if ( zhour24.length < 2 ) {
        zhour24 = "0" + zhour24;
    }

    var timezone;
    var timestr;

    if ( fmttime ) {
        timestr = fmttime;
        timestr = timestr.replace("g",hour24);
        timestr = timestr.replace("h",hour);
        timestr = timestr.replace("G",zhour24);
        timestr = timestr.replace("H",zhour);
        timestr = timestr.replace("i",min);
        timestr = timestr.replace("I",zmin);
        timestr = timestr.replace("s",sec);
        timestr = timestr.replace("S",zsec);
        if ( hour24 >= 12 ) {
            timestr = timestr.replace("a","pm");
            timestr = timestr.replace("A","PM");
        } else {
            timestr = timestr.replace("a","am");
            timestr = timestr.replace("A","AM");
        }
    } else {
        fmttime = "h:I:S A";
        timestr = hour + ":" + zmin + ":" + zsec;
        if ( hour24 >= 12 ) {
            timestr+= " PM";
        } else {
            timestr+= " AM";
        }
    }

    // console.log("\n ****** getFormattedTime ******\n clockid: ", clockid," fmttime: ", fmttime," timestr: ", timestr, " timezone: ", timezone);
    var retobj = {fmt_time: fmttime, time: timestr, timezone: timezone};
    return retobj;
}

function getClock(clockid) {
    // set up all defaults here - can change with customizer
    var clockname = "Digital Clock";
    var clockskin = "";
    if ( clockid==="clockanalog" ) {
        clockname = "Analog Clock";
        clockskin = "CoolClock:swissRail:72";
    }
    var d = new Date();
    var dates = getFormattedDate("M D, Y", d, clockid);
    var dateofmonth = dates.date;
    var weekday = dates.week;
    var fmtdate = dates.fmt_date;

    var times = getFormattedTime("h:I:S A", d, clockid);
    var timeofday = times.time;
    var fmttime = times.fmt_time;
    var timezone = times.timezone;

    var timeofday = d.toLocaleTimeString();
    var timezone = d.getTimezoneOffset().toString();
    var dclock = {"name": clockname, "skin": clockskin, "weekday": weekday,
        "date": dateofmonth, "time": timeofday, "tzone": timezone,
        "fmt_date": fmtdate, "fmt_time": fmttime};

    // dclock = getCustomTile(dclock, "clock", clockid);
    // console.log("\n ******** getClock *********\n clock: ", dclock);

    return dclock;
}

function addSpecials() {
    // set hub number to nothing for manually created tiles
    var hubnum = "-1";

    // add digital clock tile
    // never refresh since clocks have their own refresh timer built into the javascript code
    // you will need to over-ride this with the tile customizer if you add custom fields
    var clockidd = "clockdigital";
    var dclock = getClock(clockidd);
    var dname = dclock["name"];
    dclock = getCustomTile(dclock, "clock", clockidd);
    allthings["clock|"+clockidd] = {"id" :  clockidd, "name" :  dname, 
        "hubnum" :  hubnum, "type" :  "clock", "refresh": "slow", "value" :  dclock};

    // add analog clock tile - no longer use dclock format settings by default
    var clockida = "clockanalog";
    var aclock = getClock(clockida);
    var aname = aclock["name"];
    aclock = getCustomTile(aclock, "clock", clockida);
    allthings["clock|"+clockida] = {"id" :  clockida, "name" :  aname, 
        "hubnum" :  hubnum, "type" :  "clock", "refresh": "slow", "value" :  aclock};

    // add special tiles based on type and user provided count
    // this replaces the old code that handled only video and frame tiles
    // this also creates image and blank tiles here that used to be made in groovy
    // putting this here allows them to be handled just like other modifiable tiles
    // these tiles all refresh fast except first 4 frames that are reserved for weather
    // renamed accuweather to forecast2 for simplicity sake and to make sorting work
    var specialtiles = utils.getSpecials();
    for (var stype in specialtiles) {
        var sid = specialtiles[stype];
        var speed = sid[4] || "normal";
        
        var fcnt = getCustomCount(stype, sid[3]);
        if ( fcnt ) {
            for (var i=0; i<fcnt; i++) {

                var k = (i + 1).toString();
                var fid = sid[0] + k;
                var idx = stype + "|" + fid;

                var fn = getCustomName(stype, idx, k);
                var ftile = {"name": fn};
                ftile = getCustomTile(ftile, stype, fid);
                ftile = returnFile(ftile, stype);

                // we now preserve the original name in the master array
                allthings[idx] = {"id":  fid, "name": fn, "hubnum":  hubnum, 
                    "type": stype, "refresh": speed, "value":  ftile};
            }
        }
    }
    
    // create the controller tile
    // keys starting with c__ will get the confirm class added to it
    // this tile cannot be customized by the user due to its unique nature
    // but it can be visually styled just like any other tile
    var controlval = {"name": "Controller", "showoptions": "Options","refreshpage": "Refresh","c__refactor": "Reset",
                 "c__reauth": "Re-Auth","showid": "Show Info","toggletabs": "Toggle Tabs",
                 "showdoc": "Documentation",
                 "blackout": "Blackout","operate": "Operate","reorder": "Reorder","edit": "Edit"};
    controlval = getCustomTile(controlval, "control", "control_1");
    allthings["control|control_1"] = {"id":  "control_1", "name": "Controller", "hubnum":  hubnum, 
                "type":  "control", "refresh": "never", "value":  controlval};
}

// create addon subid's for any tile
// this enables a unique customization effect
// the last parameter is only needed for LINK customizations
function getCustomTile(custom_val, customtype, customid) {
    const reserved = ["index","rooms","things","config","control","useroptions"];

    // do nothing if options are not loaded
    if ( utils.count(GLB.options.rooms)===0 || utils.count(GLB.options.index)===0 || utils.count(GLB.options.things)===0 ) {
        return custom_val;
    }

    try {
        var idx = customtype + "|" + customid;
        var rooms = GLB.options["rooms"];
        var index = GLB.options["index"];
        var thingoptions = GLB.options["things"];
        var tileid = parseInt(GLB.options["index"][idx]);
    } catch(e) {
        return custom_val;
    }
    
    // get custom tile name if it was defined in tile editor and stored
    // in the room array
    var customname= "";
    for (var room in rooms) {
        if ( array_key_exists(room, thingoptions) ) {
            var things = thingoptions[room];
            for (var k in things) {
                var kindexarr = things[k];
                // only do this if we have custom names defined in rooms
                if ( is_array(kindexarr) && kindexarr.length > 3 ) {
                    var kindex = parseInt(kindexarr[0]);

                    // if our tile matches and there is a custom name, use it
                    if ( kindex===tileid && kindexarr[4]!=="" ) {
                        customname = kindexarr[4];
                        break;
                    }
                }
            }
        }
    }

    if ( customname!=="" || !custom_val["name"] ) {
        custom_val["name"] = customname;
    }

    // this is where we do a check for bad chars and remove them in names
    // instead of in the processName function
    var pattern = /[,;:!-\'\*\<\>\{\}\+\&\%]/g;
    custom_val["name"] = custom_val["name"].replace(pattern,"");

    // see if a section for this id is in options file
    // this is where customizer updates are processed
    var lines = false;
    if (array_key_exists("user_" + customid, GLB.options) ) {
        lines = GLB.options["user_" + customid];
    } else if ( !in_array (customid, reserved) && array_key_exists(customid, GLB.options) ) {
        lines = GLB.options[customid];
    }

    // ignores = [" ","'","*","<",">","!","{","}","-",".",",",":","+","&","%"];
    if ( lines && is_array(lines) ) {
        
        // allow user to skip wrapping single entry in an array
        // the GUI will never do this but a user might in a manual edit
        if ( !is_array(lines[0]) ) {
            lines = [lines];
        }
        
        // first remove existing ones so we can read them in the proper order
        lines.forEach(function(msgs) {
            var subidraw = msgs[2].trim();
            var subid = subidraw.replace(/[\"\*\<\>\!\{\}\.\,\:\+\&\%]/g,""); //  str_replace(ignores, "", subidraw);
            var companion = "user_" + subid;
            delete custom_val[subid];
            delete custom_val[companion];
        });
        
        // sort the lines and add them back in the requested order
        // replacements of default items will occur in default place
        // usort(lines, sortlinefunc);
        
        // loop through each item and add to tile
        lines.forEach(function(msgs) {

           
            // check to make sure we have an array of three long
            // this strict rule is followed to enforce discipline use
            if ( is_array(msgs) && msgs.length >= 3 ) {
            
                var calltype = msgs[0].toString().toUpperCase().trim();
                var content = msgs[1].toString().trim();
                // var posturl = encodeURIComponent(content);
                var subidraw = msgs[2].trim();
                var subid = subidraw.replace(/[\"\*\<\>\!\{\}\.\,\:\+\&\%]/g,""); //  str_replace(ignores, "", subidraw);
                var companion = "user_" + subid;
    
                // process web calls made in custom tiles
                // this adds a new field for the URL or LINK information
                // in a tag called user_subid where subid is the requested field
                // web call results and linked values are stored in the subid field
                if ( content && (calltype==="PUT" || calltype==="GET" || calltype==="POST" || calltype==="URL") )
                {
                    // custom_val[companion] = "::" + calltype + "::" + posturl;
                    custom_val[companion] = "::" + calltype + "::" + encodeURI(content);
                    custom_val[subid] = calltype + "::" + subid;
               
                } else if ( calltype==="LINK" ) {
                    // code for enabling mix and match subid's into custom tiles
                    // this stores the tile number so we can quickly grab it upon actions
                    // this also allows me to find the hub number of the linked tile easily
                    // and finally, the linked tile is displayable at user's discretion
                    // for this to work the link info is stored in a new element that is hidden
                    
                    var idx = array_search(content, index);

                    // changed the link logic so we don't need to know the value at link time
                    // if ( allthings && idx!== false && array_key_exists(idx, allthings) ) {
                    if ( idx !== false ) {
                
                        // if the subid exists in our linked tile add it
                        // this can replace existing fields with linked value
                        // if an error exists show text of intended link
                        // first case is if link is valid and not an existing field
                        // if ( array_key_exists(subid, pvalue) ) {
                        custom_val[companion] = "::" + calltype + "::" + idx;
                        custom_val[subid]= "LINK::" + content;
                        // console.log( (ddbg()), "link debug: subid= ", subid, " custom_val: ", custom_val);
                            
                    // final cases are if link tile wasn't found
                    } else {
                        custom_val[companion] = "::" + calltype + "::" + "error";
                        custom_val[subid] = "Link::" + content;
                        console.log( (ddbg()), "error - Links unavailable to link #" + content + " with subid= " + subid);
                    }

                    // } else if ( calltype==="URL" ) {
                    //     // custom_val[companion] = "::" + calltype + "::" + posturl;
                    //     custom_val[companion] = "::" + calltype + "::";
                    //     custom_val[subid] = "URL::" + subid;
               
                } else if ( ENABLERULES && calltype==="RULE" ) {
                    custom_val[companion] = "::" + calltype + "::" + content;
                    custom_val[subid] = "RULE::" + subid;

                } else {
                    // code for any user provided text string
                    // we could skip this but including it bypasses the hub call
                    // which is more efficient and safe in case user provides
                    // a subid that the hub might recognize - this way it is
                    // guaranteed to just pass the text on the browser
                    calltype = "TEXT";
                    custom_val[companion] = "::" + calltype + "::" + content;
                    custom_val[subid] = content;
                }
            }
        });

        // fix clock date if the format sting is provided
        if ( array_key_exists("date", custom_val) && array_key_exists("fmt_date", custom_val) ) {
            var dates = getFormattedDate(custom_val["fmt_date"], null, customid);
            custom_val["date"] = dates.date;
            if ( array_key_exists("weekday", custom_val) ) {
                custom_val["weekday"] = dates.week;
            }
            custom_val["fmt_date"] = dates.fmt_date;
        }
        if ( array_key_exists("time", custom_val) && array_key_exists("fmt_time", custom_val) ) {
            var times = getFormattedTime(custom_val["fmt_time"], null, customid);
            custom_val["time"] = times.time;
            if ( array_key_exists("tzone", custom_val) ) {
                custom_val["tzone"] = times.timezone;
            }
            custom_val["fmt_time"] = times.fmt_time;
        }
    }
    return custom_val;
}

// this little gem makes sure levels are always at the end of a tile
// and it puts all user created fields at the end of tile too
function setValOrder(val) {

    var keys = Object.keys(val).sort( function(vala, valb) {

        // look for a companion
        var compa = array_key_exists("user_"+vala, val);
        var compb = array_key_exists("user_"+valb, val);

        // put all companions at the end

        if ( vala===valb ) {
            return 0;
        } else if ( vala==="level" || vala==="colorTemperature" ) {
            return 1;
        } else if ( valb==="level" || valb==="colorTemperature" ) {
            return -1;
        } else if ( vala.startsWith("user_") && valb.startsWith("user_") ) {
            return 0;
        } else if ( vala.startsWith("user_") ) {
            return 1
        } else if ( valb.startsWith("user_") ) {
            return -1
        } else if ( compa && compb ) {
            return 0;
        } else if ( compa ) {
            return 1;
        } else if ( compb ) {
            return -1;
        } else {
            return 0;
        }
    });

    var newval = {};
    keys.forEach( function(key) {
        newval[key] = val[key];
    });

    return newval;
}

function processHubMessage(hubmsg) {
    // loop through all things for this hub
    // remove music trackData field that we don't know how to handle
    var cnt = 0;

    // push info to all things that match
    // we don't know the thing types so we have to check all things
    // this uses the format defined in the HousePanel.groovy file
    // that was also used in the old housepanel.push app
    var subid = hubmsg['change_attribute'];
    for (var idx in allthings) {

        var entry = allthings[idx];
        if ( entry.id === hubmsg['change_device'].toString() &&
             subid!=='trackData' &&
             entry['value'][subid] !== hubmsg['change_value'] )
        {
            cnt = cnt + 1;
            entry['value'][subid] = hubmsg['change_value'];
            if ( entry['value']['trackData'] ) { delete entry['value']['trackData']; }
            if ( DEBUG2 ) {
                console.log( (ddbg()), 'Updating tile #' + entry['id'],' from trigger:', hubmsg['change_attribute'] );
            }
            pushClient(entry.id, entry.type, subid, entry['value'])

            // process rules and links
            // avoid against duplicate calls
            if ( ENABLERULES && subid && !GLB.rules[entry.id] && (GLB.options.config["rules"] ==="true" || GLB.options.config["rules"] ===true) ) {
                processRules(entry.id, entry.type, subid, entry['value']);
                // processLinks(entry.id, entry.type, subid, entry['value']);
                GLB.rules[entry.id] = true;
            }
        }
    }
    resetRules();
    return 'pushed new status info to ' + cnt + ' tiles';
}

function resetRules() {
    if ( GLB.rules ) {
        delete GLB.rules;
    }
    GLB.rules = {};
}

// this function handles processing of all websocket calls from ISY
// used to keep clients in sync with the status of ISY operation
function processIsyMessage(isymsg) {
    var newval;
    var pvalue;
    if ( DEBUG9 ) {
        console.log( (ddbg()), "ISY event detected for msg: ", isymsg);
    }
    xml2js(isymsg, function(err, result) {
        if ( !err && result.Event ) {
            var control = result.Event.control;
            var action = result.Event.action;
            var node = result.Event.node;
            var eventInfo = result.Event.eventInfo;
            if ( DEBUG9 ) {
                console.log( (ddbg()), "ISY event json result: ", UTIL.inspect(result, false, null, false) );
            }

            if ( is_array(node) && node.length && node[0]!=="" &&
                 is_array(control) && control.length && control[0]!=="" &&
                 action[0] && action[0]["$"] && action[0]["_"] ) {
                var bid = node[0];
                var idx = "isy|" + bid;

                if ( allthings && allthings[idx] && allthings[idx].value && allthings[idx].type==="isy" ) {
                    pvalue = allthings[idx].value;
                    try {
                        newval = action[0]["_"] || pvalue[subid];
                        newval = parseFloat(newval);
                        var uom = action[0]["$"]["uom"] || "";

                        // adjust the value based on precision
                        if ( action[0]["$"]["prec"] ) {
                            var prec = parseInt(action[0]["$"]["prec"]);
                            if ( ! isNaN(prec) && prec > 0 ) {
                                var pow10 = Math.pow(10,prec);
                                newval = newval / pow10;
                            }
                        }

                        newval = newval.toString();
                    } catch (e) {
                        console.log( (ddbg()), "error - processIsyMessage: ", e);
                        return;
                    }

                    pvalue = translateIsy(bid, control[0], uom, pvalue, newval, "");
                    var subid = mapIsy(control[0], uom);
                    // allthings[idx].value = pvalue;
                    pushClient(bid, "isy", subid, pvalue, false, false);

                    // process rules and links
                    if ( ENABLERULES && subid && (GLB.options.config["rules"] ==="true" || GLB.options.config["rules"] ===true) ) {
                        processRules(bid, "isy", subid, pvalue);
                        // processLinks(bid, "isy", subid, pvalue);
                        GLB.rules[bid] = true;
                    }
                    if ( DEBUG9 ) {
                        console.log( (ddbg()), "ISY webSocket updated node: ", bid, " trigger:", control[0], " subid: ", subid, " uom: ", uom, " newval: ", newval, " value: ", pvalue);
                    }
                }

            // set variable changes events
            } else if ( is_object(eventInfo[0]) && array_key_exists("var", eventInfo[0]) ) {
                var varobj = eventInfo[0].var[0];
                if ( DEBUG9 ) {
                    console.log("Event info: ", UTIL.inspect(varobj, false, null, false) );
                }
                var bid = "vars";
                var idx = "isy|" + bid;
                if ( allthings && allthings[idx] && allthings[idx].value && allthings[idx].type==="isy" ) {
                    pvalue = allthings[idx]["value"];
                    try {
                        var id = varobj["$"]["id"];
                        if ( varobj["$"]["type"] === "1" ) {
                            var subid = "int_" + id;
                        } else if ( varobj["$"]["type"] === "2" ) {
                            subid = "state_" + id;
                        } else {
                            throw "invalid variable type: " + varobj["$"]["type"];
                        }

                        var prec = parseInt(varobj.prec[0]);
                        newval = parseFloat(varobj.val[0]);
                        if ( ! isNaN(prec) && prec > 0 ) {
                            newval = newval / Math.pow(10,prec);
                        }
                        pvalue[subid] = newval.toString();
                        allthings[idx]["value"] = pvalue;
                        pushClient(bid, "isy", subid, pvalue, false, false);

                        // process rules and links
                        if ( ENABLERULES && subid && (GLB.options.config["rules"] ==="true" || GLB.options.config["rules"] ===true) ) {
                            processRules(bid, "isy", subid, pvalue);
                            // processLinks(bid, "isy", subid, pvalue);
                            GLB.rules[bid] = true;
                        }
                        if ( DEBUG9 ) {
                            console.log( (ddbg()), "ISY webSocket updated node: ", bid, " trigger:", control[0], " subid: ", subid, " newval: ", newval, " pvalue: ", pvalue);
                        }

                    } catch (e) {
                        console.log( (ddbg()), "error - processIsyMessage: ", e);
                        return;
                    }
                }
            }
        }
    });
}

function processRules(bid, thetype, trigger, pvalue) {

    // go through all things that could be links for this tile
    var userid = "user_" + bid;
    var ifvalue = false;
    var rbid = bid;
    var rtype = thetype;
    var ridx = thetype + "|" + bid;

    // if ( DEBUG11 ) {
    //     console.log( (ddbg()), "RULE debug... userid: ", userid, " thetype: ", thetype, " trigger: ", trigger, " pvalue: ", pvalue);
    // }

    // if this tile has no rule, do nothing
    if ( !array_key_exists(userid, GLB.options) ) {
        return;
    }

    // go through all tiles with a new rule type
    var idx = thetype + "|" + bid;
    try {
        var index = GLB.options["index"];
        var tileid = index[idx].toString();
    } catch (e) {
        console.log( (ddbg()), "webSocket RULE error: id: ", bid, " type: ", thetype, " trigger: ", trigger, " error: ", e);
        return;
    }
    
    // rule structure
    // delay and attr are optional, but must give a delay to give an attr; just set it to 0 or false to skip delay
    // you cannot safely mix the logic of "or" with the logic of "and" but it sometimes works
    // also note that below altpattern is the same as triggerpatern for now
    // if subid>=xx or num=subid=on or num=subid=off... , num=subid=value=delay, num=subid=value=delay=attr, ...
    // if subid>=xx and num=subid=on and num=subid=off... , num=subid=value=delay, num=subid=value=delay=attr, ...
    // for example...
    // user_custome_1 : [ [RULE, "if switch==on and 167=switch==on, 28=switch=on, 12=switch=on=none=2", myrule, 1], 
    //                    [RULE, "if state==away or 42=presence==absent", 19=thermostatMode=heat, 19=heatingSetpoint=72, 14=lock=lock, rule2, 2] ]

    const regsplit = /[,;]/;
    const ifpattern = /(if)\s+(.*)/;
    const triggerpattern = /(\w+)\s*([=|!|<|>])(=?)\s*(\w+)/;
    const rulepattern = /(\d*)\s*=\s*(\w+)\s*([=|!|<|>])(=?)\s*(\w+)/;
    const altpattern =     /(\w+)\s*([=|!|<|>])(=?)\s*(\w+)/;
    
    // print some debug info
    var items = GLB.options[userid];
    if ( DEBUG11 ) {
        console.log( (ddbg()), "RULE: id: ", bid, " type: ", thetype, " trigger: ", trigger, " tileid: ", tileid, " userid: ", userid, " rules: ", UTIL.inspect(items, false, null, false));
    }

    // loop through all the custom elements of this tile looking for rules
    items.forEach( function(item) {

        // process custom entries that are rules
        // the subid it is tied to is ignored as is the order number
        // so we only need to get item[0] and item[1]
        if ( item[0]==="RULE" ) {
            var linkval = item[1].trim();
            var isrule = false;
            var rulenum = 0;

            // split the test line between commas and semi-colons
            var testcommands = linkval.split(regsplit);

            // only proceed if there are at least two parts and the first part starts with "if "
            if ( testcommands.length > 1 && testcommands[0].trim().startsWith("if") ) {

                // get the if and the rule and continue if in the right format
                var iftest = testcommands[0].match(ifpattern);
                var rulestr = (iftest && iftest.length>1 && iftest[2]) ? iftest[2] : "";
                if ( iftest[1]==="if" && rulestr ) {

                    // get the rule set
                    var ruleset = rulestr.split(" ");
                    var doand = true;
                    if ( DEBUG11 ) {
                        console.log( (ddbg()), "RULE debug: rulestr: ", rulestr, " rulseset: ", ruleset);
                    }
    
                    // loop through each one and add to test
                    ruleset.forEach( function(rule) {

                        var ruleparts = null;
                        var ruletileid = null;
                        var rulesubid = "";
                        var rulevalue = "";
                        var ruleop = "";
                        var ruleop2 = "";
                        rule = rule.trim();
                        if ( DEBUG11 ) {
                            console.log( (ddbg()), "RULE debug: rule step#", rulenum, " rule: ", rule);
                        }
    
                        // set rule mode based on word - if it is "and" then use and logic
                        if ( rule==="and" ) {
                            doand = true;

                        // if the separator word is "or" then use or logic
                        } else if ( rule==="or" ) {
                            doand = false;

                        // otherwise we are on an element so interpret the test
                        } else {
                            if ( rulenum===0 ) {
                                ruleparts = rule.match(triggerpattern);
                                if ( ruleparts ) {
                                    ruletileid = tileid;
                                    rulesubid = ruleparts[1] || "";
                                    ruleop = ruleparts[2] || "";
                                    ruleop2 = ruleparts[3];
                                    if ( ruleop2 ) { ruleop = ruleop + ruleop2; }
                                    rulevalue = ruleparts[4] || "";
                                }
                            } else {
                                ruleparts = rule.match(rulepattern);
                                ruleop = "";
                                if ( ruleparts ) {
                                    ruletileid = parseInt(ruleparts[1]);
                                    rulesubid = ruleparts[2] || "";
                                    ruleop = ruleparts[3] || "";
                                    ruleop2 = ruleparts[4];
                                    if ( ruleop2 ) { ruleop = ruleop + ruleop2; }
                                    rulevalue = ruleparts[5] || "";
                                } else {
                                    ruleparts = rule.match(altpattern);
                                    if ( ruleparts ) {
                                        ruletileid = tileid;
                                        rulesubid = ruleparts[1] || "";
                                        ruleop = ruleparts[2] || "";
                                        ruleop2 = ruleparts[3];
                                        if ( ruleop2 ) { ruleop = ruleop + ruleop2; }
                                        rulevalue = ruleparts[4] || "";
                                    }
                                }
                                if ( DEBUG11 ) {
                                    console.log( (ddbg()), "rule: ", rule, " ruleparts: ", ruleparts);
                                }
                            }
                            if ( DEBUG11 ) {
                                console.log( (ddbg()), "RULE debug: ruletileid: ", ruletileid, " rulesubid: ", rulesubid, 
                                                       " ruleop: ", ruleop, " rulevalue: ", rulevalue, " before: ", doand, " rule: ", rule, " isrule: ", isrule);
                            }
    
                            // compute the test if this test part has the required elements
                            if ( ruletileid && ! isNaN(ruletileid) && ruleop && rulevalue ) {

                                // find the tile index and proceed with activating the rule
                                if ( rulenum===0 && array_key_exists(rulesubid, pvalue) ) {
                                    ifvalue = pvalue[rulesubid];
                                } else {
                                    ridx = array_search(ruletileid, GLB.options["index"]);
                                    if ( ridx ) {
                                        var ritems = ridx.split("|");
                                        rtype = ritems[0];
                                        rbid = ritems[1];
                                        try {
                                            ifvalue = allthings[ridx]["value"][rulesubid];
                                        } catch(e) {
                                            // console.log(e, " ridx= ", ridx);
                                            ifvlaue = false;
                                        }
                                    } else {
                                        ifvalue = false;
                                        rtype = "";
                                        rbid = "";
                                    }
                                }

                                // fix up ISY hubs
                                if ( rulesubid==="isy" && rulevalue==="on" ) { rulevalue = "DON"; }
                                if ( rulesubid==="isy" && rulevalue==="off" ) { rulevalue = "DOF"; }

                                if ( DEBUG11 ) {
                                    console.log( (ddbg()), "RULE debug: ridx: ", ridx, " rtype= ", rtype, " rbid= ", rbid, " ifvalue: ", ifvalue, "rulevalue: ", rulevalue, " ruletileid: ", ruletileid, " parts: ", ruleparts );
                                }

                                    // get the rule check if the requested subid is recognized
                                if ( ifvalue!==false ) {

                                    if ( isNaN(parseInt(ifvalue)) && isNaN(parseInt(rulevalue)) ) {
                                        var num1 = ifvalue;
                                        var num2 = rulevalue;
                                    } else {
                                        num1 = parseInt(ifvalue);
                                        num2 = parseInt(rulevalue);
                                    }

                                    var ismatch = ( 
                                        ( (ruleop==="=" || ruleop==="==") && (num1===num2) ) ||
                                        ( (ruleop==="!" || ruleop==="!=") && (num1!==num2) ) ||
                                        ( (ruleop==="<" ) && (num1 <  num2) ) ||
                                        ( (ruleop==="<=") && (num1 <= num2) ) ||
                                        ( (ruleop===">" ) && (num1 >  num2) ) ||
                                        ( (ruleop===">=") && (num1 >= num2) ) 
                                    );

                                    // apply and/or logic to the final rule determination
                                    if ( doand ) {
                                        isrule = rulenum===0 ? ismatch : isrule && ismatch;
                                    } else {
                                        isrule = rulenum===0 ? ismatch : isrule || ismatch;
                                    }
                                } else {
                                    console.log("error - invalid RULE syntax: ", rule, " parts: ", ruleparts);
                                }
                            } else {
                                if ( typeof ruletileid!=="undefined" ) {
                                    console.log("error - invalid RULE syntax: ", rule, " Target tile not found. tile #", ruletileid);
                                }
                                ruleparts = false;
                            }
                        }

                        // report state of test
                        if ( DEBUG11 ) {
                            console.log( (ddbg()), "RULE debug: after: ", doand, " ", rule, " isrule: ", isrule);
                        }
                        rulenum++;
            
                    });
                }
            } else {
                isrule = false;
            }

            // execute the statements after if for the cases that pass the logic test above
            if ( isrule ) {
                execRules(thetype, 1, testcommands, pvalue);
            }

        }

    });

}

// this executes the rules in the list starting with either 0 or 1
// rules without if statements start at 0, if RULES start at 1
function execRules(swtype, istart, testcommands, pvalue) {
    // const actpattern = /(\d+)\s*=\s*(\w+)\s*=\s*(\w+)\s*=?\s*(.*)/;

    // perform all of the commands if we meet the if test
    for (var i= istart; i<testcommands.length; i++) {
        var autostr = testcommands[i];

        // get the parts of the auto exec
        // the regex is an alternate approach but it is slower and not needed for this simple syntax
        // var autoexec = autostr.match(actpattern);
        // the unshift is just so I can keep the same index numbers as when using regex
        var autoexec = autostr.split("=");
        autoexec.unshift(" ");
        var len = autoexec.length;

        if ( len >= 4 ) {
            var rtileid = parseInt(autoexec[1].trim());
            var rsubid = autoexec[2].trim();
            var rvalue = autoexec[3].trim();
            var delay = len > 4 ? autoexec[4] : false;
            if ( delay ) {
                delay = parseInt( delay.trim() );
                if ( isNaN(delay) || delay<=0 ) {
                    delay = false;
                } else {
                    delay = delay * 1000;
                }
            }
            var rswattr = len > 5 ? autoexec[5].trim() : "";

            // find the tile index and proceed with activating the rule
            var ridx = array_search(rtileid, GLB.options["index"]);
            if ( DEBUG11 ) {
                console.log( (ddbg()), "RULE debug: exec step #", i, " rtileid: ", rtileid, " rsubid: ", rsubid, " rvalue: ", rvalue, " rswattr: ", rswattr, " ridx: ", ridx, " delay: ", delay);
            }

            if ( ridx && allthings[ridx] ) {
                var idxitems = ridx.split("|");
                var rswtype = idxitems[0];
                var rswid = idxitems[1];

                // handle requests for parameters of the trigger tile ($) or destination tile (@)
                var trigtype = rvalue.substr(0,1);
                if ( trigtype==="$" || trigtype==="@" ) {
                    var trigsubid = rvalue.substr(1);
                    if ( trigtype==="$" && array_key_exists(trigsubid, pvalue) ) {
                        rvalue = pvalue[trigsubid];
                    } else if ( trigtype==="@" && array_key_exists(trigsubid, allthings[ridx]["value"]) ) {
                        rvalue = allthings[ridx]["value"][trigsubid];
                    }
                    if ( array_key_exists(rsubid, allthings[ridx]["value"]) ) {
                        allthings[ridx]["value"][rsubid] = rvalue;
                        var companion = "user_"+rsubid;
                        if ( array_key_exists(companion, allthings[ridx]["value"]) ) {
                            allthings[ridx]["value"][companion] = "::TEXT::" + rvalue;
                        }
                    }
                }

                // fix up ISY hubs
                if ( rswtype==="isy" && rvalue==="on" ) { rvalue = "DON"; }
                if ( rswtype==="isy" && rvalue==="off" ) { rvalue = "DOF"; }

                if ( rsubid==="level" || rsubid==="colorTemperature" ) {
                    rswattr= "level";
                } else if ( rsubid==="switch" || swtype==="isy" || (swval!=="on" && swval!=="off") ) {
                    rswattr="";
                } else if ( !rswattr && rswtype!=="isy" ) {
                    var swval = rvalue==="on" ? "off" : "on";
                    rswattr= swtype + " p_" + rtileid + " " + swval;
                }
                var hubid = allthings[ridx]["hubnum"];
                var hub = findHub(hubid);
                // if ( DEBUG11 ) {
                //     console.log( (ddbg()), "RULE debug: exec step #", i, " hubid: ", hubid, " vals: ", rswid, rswtype, rvalue, rswattr, rsubid);
                // }
                if ( hub ) {

                    // if target subid isn't there, create one
                    // and adjust what gets sent to the hub call
                    var linkinfo = false;
                    if ( array_key_exists("user_" + rsubid, allthings[ridx]["value"]) || 
                         !array_key_exists(rsubid, allthings[ridx]["value"]) ) {
                        addCustom(rswid, rswtype, "TEXT", rvalue, rsubid);
                        linkinfo = [rswid, rswtype, rsubid, rsubid, "TEXT"];
                        if ( DEBUG11 ) {
                            console.log("custom value: ", rvalue, " allthingval: ", allthings[ridx].value);
                        }
                    }

                    // make the hub call now or delayed
                    if ( delay && delay > 0 ) {
                        setTimeout( function() {
                            callHub(hub, rswid, rswtype, rvalue, rswattr, rsubid, linkinfo, false, true);
                        }, delay);
                    } else {
                        callHub(hub, rswid, rswtype, rvalue, rswattr, rsubid, linkinfo, false, true);
                    }
                }
            }


        }
    }

}

// function processLinks(bid, thetype, trigger, pvalue) {

//     // go through all things that could be links for this tile
//     var userid = "user_" + bid;

//     // if this tile has no link, do nothing
//     if ( !array_key_exists(userid, GLB.options) ) {
//         return;
//     }

//     // determine the type of trigger
//     var ontrigger = false;
//     if ( trigger==="motion" && (pvalue.motion ==="active" || pvalue.switch ==="DON") ) {
//         ontrigger = "on";
//     } else if ( trigger==="motion" && (pvalue.motion ==="inactive" || pvalue.switch ==="DOF") ) {
//         ontrigger = "off";
//     } else if ( trigger==="contact" && (pvalue.contact ==="open"  || pvalue.switch ==="DON") ) {
//         ontrigger = "on";
//     } else if ( trigger==="contact" && (pvalue.contact ==="closed" || pvalue.switch ==="DOF") ) {
//         ontrigger = "off";
//     } else if ( trigger==="switch" && (pvalue.switch ==="on" || pvalue.switch ==="DON") ) {
//         ontrigger = "on";
//     } else if ( trigger==="switch" && (pvalue.switch ==="off" || pvalue.switch ==="DOF") ) {
//         ontrigger = "off";
//     }

//     // debug info
//     var idx = thetype + "|" + bid;
//     if ( DEBUG12 ) {
//         console.log( (ddbg()), "linked trigger: ", trigger, " on trigger: ", ontrigger, " idx: ", idx, " pvalue: ", pvalue);
//     }

//     if ( !ontrigger ) {
//         return;
//     }

//     var items = GLB.options[userid];
//     var linkidx;
//     items.forEach( function(item) {

//         // process only links
//         if ( item[0]==="LINK" ) {
//             var tilenum = parseInt(item[1]);
//             var linksubid = item[2];

//             // auto trigger any linked field that is a switch
//             // this has to start with the name switch
//             if ( isNaN(tilenum) || !linksubid.startsWith("switch") )  {
//                 if ( DEBUG12 ) {
//                     console.log( (ddbg()), "warning - no action taken on linked tile because either a non-integer provided or the linked tile is not a switch. tilenum: ", item[1], " linksubid: ", linksubid);
//                 }
//                 linkidx = false;
//             } else {
//                 if ( DEBUG12 ) {
//                     console.log( (ddbg()), "Processing LINK for tilenum: ", tilenum, " linksubid: ", linksubid);
//                 }
//                 linkidx = array_search(tilenum, GLB.options.index);
//             }

//             if ( linkidx!==false ) {
//                 var linktype = allthings[linkidx]["type"];

//                 // fix up isy devices
//                 if ( linktype==="isy" && ontrigger==="on" ) { ontrigger = "DON"; }
//                 if ( linktype==="isy" && ontrigger==="off" ) { ontrigger = "DOF"; }

//                 var linkbid = allthings[linkidx]["id"];
//                 var hubId = allthings[linkidx]["hubnum"];
//                 var hub = findHub(hubId);

//                 // hub, swid, swtype, swval, swattr, subid, linkinfo, popup
//                 callHub(hub, linkbid, linktype, ontrigger, "", "switch", false, false, false);

//                 // push to clients immediately
//                 // Note: this isn't really needed since the call to hub also pushes status when done
//                 // but we can do it here to create instant feedback
//                 // pushClient(linkbid, linktype, "switch", {switch: ontrigger}, false, false);
//                 pushClient(linkbid, linktype, linksubid, {switch: ontrigger}, false, false);
//             }
//         }

//     });

// }

function pushClient(swid, swtype, subid, body, linkinfo, popup) {
    // send the new results to all clients
    var entry = {};
    if ( typeof subid === "undefined" ) { subid= ""; }
    entry["id"] = swid;
    entry["type"] = swtype;
    entry["clientcount"] = clients.length;
    entry["trigger"] = subid;
    if ( typeof popup!=="undefined" && popup ) {
        entry["popup"] = "popup";
    } else {
        entry["popup"] = "";
    }
    var pvalue;

    if ( typeof body === "undefined" || body==="" || !body ) {
        pvalue = {};
    } else if ( typeof body === "string") {
        pvalue = JSON.parse(body);
    } else if ( typeof body === "object") {
        pvalue = body;
    } else {
        console.log( (ddbg()), "warning - unrecognized body in hub push update: ", body);
        return;
    }

    // if ( pvalue["password"] ) { delete pvalue["password"]; }
        
    // // remove color for now until we get it fixed - but report it so I can inspect
    // if ( pvalue["color"] ) {
    //     // console.log( (ddbg()), "webSocket color: ", pvalue.color);
    //     delete( pvalue["color"] );
    // }

    // save the result to push to all clients
    entry["value"] = pvalue;
    if ( DEBUG14 ) {
        console.log( (ddbg()), "pushClient: ", UTIL.inspect(entry, false, null, false), " linkinfo: ", linkinfo);
    }

    // update the main array with changed push values
    if ( swid!=="reload" && swid!=="popup" && swtype ) {
        var idx = swtype + "|" + swid;
        var lidx = "";
        var lsubid = "";
        var lreal = "";
        if ( linkinfo && is_array(linkinfo) ) {
            lidx = linkinfo[1] + "|" + linkinfo[0];
            lsubid = linkinfo[2];
            lreal = linkinfo[3];
            // entry["LINK"] = linkinfo;
        }

        if ( array_key_exists(idx, allthings) ) {
            for (var thekey in pvalue) {
                allthings[idx]["value"][thekey] = pvalue[thekey];

                // update the link that triggered if this was a link
                // we do something similar on the client side to change
                // all linked things that match this
                if ( lidx && lsubid && lreal && lreal===thekey && allthings[lidx] ) {
                    allthings[lidx]["value"][lsubid] = pvalue[thekey];
                }
            }
        }
    }

    // send mqtt message
    // eventually we can use MQTT on clients to receive this message instead of sendUTF below
    if ( udclient && udclient.connected ) {
        udclient.publish("housepanel/pushClient", JSON.stringify(entry));
    }

    // do a push to each client
    // if this is a screen reload request only the triggering screen should reload
    for (var i=0; i < clients.length; i++) {
        entry["client"] = i;
        if ( DEBUG17 ) {
            console.log("Pushing client #", i, " id: ", entry.id);
        }
        clients[i].sendUTF(JSON.stringify(entry));
    }

}

function callHub(hub, swid, swtype, swval, swattr, subid, linkinfo, popup, inrule) {
    var access_token = hub["hubAccess"];
    var endpt = hub["hubEndpt"];
    var result = "success";
    if ( DEBUG7 ) {
        console.log( (ddbg()), "callHub: access: ", access_token, " endpt: ", endpt, " swval: ", swval, " subid: ", subid, " attr: ", swattr);
    }

    var isyresp = {};
    if ( linkinfo && is_array(linkinfo) && linkinfo.length>3 && linkinfo[4]==="TEXT" ) {
        var idx = swtype + "|" + swid;
        try {
            result = allthings[idx].value;
        } catch(e) {
            result = "error - custom TEXT field not found for: " + idx;
            console.log(result);
            console.log(e);
            return result;
        }

        if (result) {
            pushClient(swid, swtype, subid, result, linkinfo, popup);
            if ( ENABLERULES && !inrule && subid && (GLB.options.config["rules"] ==="true" || GLB.options.config["rules"] ===true) ) {
                processRules(swid, swtype, subid, result);
                // processLinks(swid, swtype, subid, pvalue);
                GLB.rules[swid] = true;
            }
        }

    } else if ( hub["hubType"]==="SmartThings" || hub["hubType"]==="Hubitat" ) {
        var host = endpt + "/doaction";
        var header = {"Authorization": "Bearer " + access_token};
        var nvpreq = {"swid": swid,  
                    "swattr": swattr,
                    "swvalue": swval, 
                    "swtype": swtype};
        if ( subid && subid!=="none" ) { nvpreq["subid"] = subid; }
        curl_call(host, header, nvpreq, false, "POST", getHubResponse);

    // this module below is the equivalent of the ST and HE groovy app
    // for ISY where the logic for handling actions is provided
    // compare this to the doAction function in HousePanel.groovy
    } else if ( hub["hubType"]==="ISY" ) {
        var buff = Buffer.from(access_token);
        var base64 = buff.toString('base64');
        var isyheader = {"Authorization": "Basic " + base64};
        var cmd;
        var idx = "isy|" + swid;
        var hint = allthings[idx].hint;

        // fix up isy devices
        if ( swval==="on" ) { swval = "DON"; }
        else if ( swval==="off" ) { swval = "DOF"; }

        // set default subid so api calls will work
        if ( !subid ) {
            subid = "switch";
        }

        switch(subid) {

            case "level":
                // for now semd both level commands since either could be expected
                // one is for Insteon other is for Polyglot nodes
                // later we will flag this in the item
                var cmd1 = "/nodes/" + swid + "/cmd/SETLVL/" + swval;
                curl_call(endpt + cmd1, isyheader, false, false, "GET", getNodeResponse);

                // convert percentage to 0 - 256 range for Insteon
                var irange = Math.floor(parseInt(swval) * 255 / 100);
                var cmd2 = "/nodes/" + swid + "/cmd/DON/" + irange;
                isyresp[subid] = swval;
                isyresp["switch"] = "DON";
                curl_call(endpt + cmd2, isyheader, false, false, "GET", getNodeResponse);

                // comment this code to preserve the prior dimmer setting; 
                // otherwise the onlevel is set to current level
                // the default behavior for Insteon lights would be to comment this
                // but I kept it here to make them work like all other hubs
                var cmd3 = "/nodes/" + swid + "/cmd/OL/" + irange;
                isyresp["onlevel"] = swval;
                curl_call(endpt + cmd3, isyheader, false, false, "GET", getNodeResponse);
                break;

            case "switch":
            case "DOF":
            case "DON":
                // handle toggle command - note that the GUI will never produce a toggle swval command
                // but the RULE logic can and so can users when using api calls
                if ( swval==="toggle" ) {
                        var currentval = allthings["isy|"+swid]["value"][subid];
                        swval = currentval==="DON" ? "DOF" : "DON";
                }
                cmd = "/nodes/" + swid + "/cmd/" + swval;
                isyresp[subid] = swval;
                curl_call(endpt + cmd, isyheader, false, false, "GET", getNodeResponse);
                break;

            case "heatingSetpoint-up":
            case "coolingSetpoint-up":
            case "heatingSetpoint-dn":
            case "coolingSetpoint-dn":
                // do some fancy footwork here to get either CLISPH or CLISPC so we can use same code
                var hcletter = subid.substr(0,1).toUpperCase();
                var clicommand = "CLISP" + hcletter;

                // determine if up or down
                var isup = subid.substr(-2);

                // get existing value and then proceed with adjust if it is a number
                var newval = extractTemp(swval);
                if ( !isNaN(newval) ) { 
                    newval = (isup === "up") ? newval + 1 : newval - 1;
                    cmd = "/nodes/" + swid + "/cmd/" + clicommand + "/" + newval.toString();
                    isyresp[subid] = newval;
                    // console.log( (ddbg()), "Thermostat debug: newval: ", newval, " cmd: ", cmd );
                    curl_call(endpt + cmd, isyheader, false, false, "GET", getNodeResponse);
                } else {
                    result = "error - ISY thermostat set point cannot be interpreted.  value: " + swval;
                    console.log( (ddbg()), result);
                }
                break;
    
            default:

                // handle arrows for variable changes
                if ( hint==="ISY variable" && subid.startsWith("int_") ) {
                    // get the real subid that the arrows are pointing toward
                    var intvar = parseInt(swval);
                    if ( subid.endsWith("-up") || subid.endsWith("-dn") ) {
                        var varnum = subid.substr(4, subid.length-7);
                        var realsubid = subid.substr(0, subid.length-3);
                        intvar = subid.endsWith("-up") ? intvar + 1 : intvar - 1;
                    } else {
                        varnum = subid.substr(4);
                        realsubid = subid;
                    }
                    cmd = "/vars/set/1/" + varnum + "/" + intvar.toString();
                    isyresp[realsubid] = intvar.toString();
                    curl_call(endpt + cmd, isyheader, false, false, "GET", getNodeResponse);

                } else if ( hint==="ISY variable" && subid.startsWith("state_") ) {
                    // get the real subid that the arrows are pointing toward
                    var intvar = parseFloat(swval);
                    var prec = 0;
                    if ( !isNaN(intvar) ) {
                        if ( subid.endsWith("-up") || subid.endsWith("-dn") ) {
                            var varnum = subid.substr(6, subid.length-9);
                            var realsubid = subid.substr(0, subid.length-3);
                            intvar = subid.endsWith("-up") ? intvar + 1 : intvar - 1;
                        } else {
                            varnum = subid.substr(6);
                            realsubid = subid;

                            // deal with precision values
                            prec = parseInt(allthings[idx].value["prec_state_"+varnum]);
                            if ( ! isNaN(prec) && prec > 0 ) {
                                var pow10 = Math.pow(10,prec);
                                intvar = Math.round(intvar*pow10) / pow10;
                            }
                        }
                        // console.log("precision debug: ", prec, intvar, subid, varnum);
                        cmd = "/vars/set/2/" + varnum + "/" + intvar.toString();
                        isyresp[realsubid] = intvar.toString();
                        curl_call(endpt + cmd, isyheader, false, false, "GET", getNodeResponse);
                    }

                // run commands
                } else if ( hint==="ISY program" ) {
                    var progcommands = "run|runThen|runElse|stop|enable|disable";
                    var progarr = progcommands.split("|");
                    var progid = allthings[idx].id;
                    progid = progid.substr(5);
                    if ( progarr.includes(subid) ) {
                        cmd = "/programs/" + progid + "/" + subid;
                        curl_call(endpt + cmd, isyheader, false, false, "GET", getNodeResponse);
                        result = "success";
                    } else {
                        result = allthings[idx].value;
                    } 
                } else {
                    result = "error - command: " + subid + " not yet supported for ISY hubs";
                    console.log( (ddbg()), result);
                }

        }
    }
    return result;
    
    function extractTemp(val) {
        var newval;
        if ( swval.substr(-1)==="F" || swval.substr(-1)==="C" ) {
            newval = parseInt(swval.substr(0, swval.length-2));
        } else {
            newval = parseInt(swval);
        }
        return newval;
    }

    function getHubResponse(err, res, body) {
        var pvalue;
        if ( err ) {
            console.log( (ddbg()), "error calling ST or HE hub: ", err);
        } else {
            // update all clients - this is actually not needed if your server is accessible to websocket updates
            // It is left here because my dev machine sometimes doesn't get websocket pushes
            // you can comment this if your server gets pushes reliable
            // leaving it here causes no harm other than processing the visual update twice
            if ( body ) {

                // convert from json string
                try {
                    pvalue = JSON.parse(body);
                } catch (ep) {
                    pvalue = null;
                    console.log( (ddbg()), "failed converting hub call return to JSON object. body: ", body);
                }

                // deal with audio tiles
                if ( pvalue && array_key_exists("audioTrackData", pvalue) ) {
                    try {
                        var audiodata = JSON.parse(pvalue["audioTrackData"]);
                        // console.log("getHubResponse audiodata: ", audiodata);
                        if ( audiodata ) {
                            pvalue["trackDescription"] = audiodata["title"] || "";
                            pvalue["currentArtist"] = audiodata["artist"] || "";
                            pvalue["currentAlbum"] = audiodata["album"] || "";
                            pvalue["trackImage"] = audiodata["albumArtUrl"] || "";
                            pvalue["mediaSource"] = audiodata["mediaSource"] || "";
                        }
                    } catch(jerr) {
                        audiodata = null;
                        console.log(jerr);
                    }
                    delete pvalue["audioTrackData"];
                }

                if (pvalue) {
                    pushClient(swid, swtype, subid, pvalue, linkinfo, popup);
                    if ( ENABLERULES && !inrule && subid && (GLB.options.config["rules"] ==="true" || GLB.options.config["rules"] ===true) ) {
                        processRules(swid, swtype, subid, pvalue);
                        // processLinks(swid, swtype, subid, pvalue);
                        GLB.rules[swid] = true;
                    }
                }
            }
        }
    }

    // I don't think I need to used this because the ISY pushes a webSocket that I use
    // to do the same thing in the processIsyMessage function
    async function getNodeResponse(err, res, body) {
        if ( err ) {
            console.log( (ddbg()), "error calling ISY node: ", err);
        } else {
            var result = parser.parse(body);
            var rres = result.RestResponse;
            if ( DEBUG7 ) {
                console.log( (ddbg()), "ISY doAction: ", " isyresp: ", isyresp, " swid: ", swid, " type: ", swtype, " subid: ", subid, " cmd: ", cmd, " body: ", body);
            }
            // update all clients - this is actually not needed if your server is accessible to websocket updates
            // because ISY will push state updates via a websocket
            // and that will process a similar pushClient but for only those things that change
            // It is left here because my dev machine sometimes doesn't get websocket pushes
            // you can comment this if your server gets pushes reliable
            // leaving it here causes no harm other than processing the visual update twice
            // ....
            // I no longer process rules here because it does cause harm by running rules twice
            // but I still push client to get immediate response and because callback sometimes fails
            // var idx = swtype + "|" + swid;
            if ( rres && rres.status.toString()==="200" ) {
                pushClient(swid, swtype, subid, isyresp, linkinfo, popup);

                if ( ENABLERULES && !inrule && subid && (GLB.options.config["rules"] ==="true" || GLB.options.config["rules"] ===true) ) {
                    processRules(swid, swtype, subid, isyresp);
                    // processLinks(swid, swtype, subid, isyresp);
                    GLB.rules[swid] = true;
                }
            }
        }
    }

}

function queryHub(hub, swid, swtype, popup) {
    var access_token = hub["hubAccess"];
    var endpt = hub["hubEndpt"];
    if ( hub["hubType"]==="SmartThings" || hub["hubType"]==="Hubitat" ) {
        var host = endpt + "/doquery";
        var header = {"Authorization": "Bearer " + access_token};
        var nvpreq = {"swid": swid, "swtype": swtype};
        curl_call(host, header, nvpreq, false, "POST", getQueryResponse);
    } else if ( hub["hubType"]==="ISY" ) {
        var buff = Buffer.from(access_token);
        var base64 = buff.toString('base64');
        var header = {"Authorization": "Basic " + base64};
        var cmd = "/nodes/" + swid;
        curl_call(endpt + cmd, header, false, false, "GET", getNodeQueryResponse);
    }
    
    async function getQueryResponse(err, res, pvalue) {
        if ( err ) {
            console.log( (ddbg()), "error requesting hub node query: ", err);
        } else {
            if ( DEBUG5 ) {
                console.log( (ddbg()), "doQuery: ", swid, " type: ", swtype, " value: ", pvalue);
            }
            if ( pvalue ) {

                // deal with audio tiles
                if ( array_key_exists("audioTrackData", pvalue) ) {
                    try {
                        var audiodata = JSON.parse(pvalue["audioTrackData"]);
                        if ( audiodata ) {
                            pvalue["trackDescription"] = audiodata["title"] || "";
                            pvalue["currentArtist"] = audiodata["artist"] || "";
                            pvalue["currentAlbum"] = audiodata["album"] || "";
                            pvalue["trackImage"] = audiodata["albumArtUrl"] || "";
                            pvalue["mediaSource"] = audiodata["mediaSource"] || "";
                        }
                    } catch(jerr) {
                        audiodata = null;
                    }
                    delete pvalue["audioTrackData"];
                }

                pushClient(swid, swtype, "none", pvalue, null, popup);
            }
        }
    }

    function getNodeQueryResponse(err, res, body) {
        if ( err ) {
            console.log( (ddbg()), "error requesting ISY node query: ", err);
        } else {
            // var result = parser.parse(body);
            xml2js(body, async function(xmlerr, result) {
                try {
                    if ( result ) {
                        var nodeid = result.nodeInfo.node[0]["address"];
                        nodeid = fixISYid(nodeid);
                        if ( nodeid ) {
                            var idx = "isy|" + nodeid;
                            var value = clone(allthings[idx]["value"]);
                            var props = result.nodeInfo.properties[0].property;
                            setIsyFields(nodeid, value, props); // result.nodeInfo);
                        } else {
                            throw "Something went wrong reading node from ISY in getNodeQueryResponse";
                        }
                    }
                } catch(e) { 
                    console.log( (ddbg()), "error in getNodeQueryResponse: ", e);
                }
            });
        }

    }
}

function findHub(hubid) {
    var hub =  GLB.options.config["hubs"][0];
    for (var h in  GLB.options.config["hubs"]) {
        var ahub =  GLB.options.config["hubs"][h];
        if ( ahub["hubId"]===hubid ) { hub = ahub; }
    }
    return hub;
}

// update the hubs array with a new hub value of a certain ID
// if not found the hub is added
function updateHubs(newhub, oldid) {
    var num = 0;
    oldid = oldid.toString();
    var found = false;

    // every hub that matches gets updated
    // should only be one but just in case
    GLB.options.config.hubs.forEach(function(hub) {
        if ( hub["hubId"].toString() === oldid ) {
            GLB.options.config.hubs[num] = clone(newhub);
            found = true;
        }
        num++;
    });

    // if not found then add new hub
    if ( !found ) {
        GLB.options.config.hubs.push(newhub);
    }
    return found;
}

function doAction(hubid, swid, swtype, swval, swattr, subid, tileid, command, linkval, protocol) {

    var response = {};
    var idx;

    function testclick(clktype, clkid) {
        var test = false;
        if ( clkid.startsWith("_") || clkid.endsWith("-up") || clkid.endsWith("-dn") ) {
            return test;
        }

        if (  clktype==="contact" || clktype==="presence" || clktype==="motion" || clktype==="weather" || clktype==="clock" ||
              (clktype==="isy" && clkid.startsWith("int_")) ||
              (clktype==="isy" && clkid.startsWith("state_")) ||
              clkid==="temperature" || clkid==="name" || clkid==="contact" || clkid==="battery" ||
              clkid==="date" || clkid==="time" || clkid==="weekday" || clkid==="tzone" ||
              clkid==="heatingSetpoint" || clkid==="coolingSetpoint" ||
              clkid==="presence" || clkid==="motion" || clkid.startsWith("event_") )  {
            test = true;
        }
        return test;
    }

    // reset rules
    resetRules();

    if ( DEBUG7 ) {
        console.log( (ddbg()), "doaction: swid: ", swid, " swtype:", swtype, " swval: ", swval, 
                               " swattr: ", swattr, " subid: ", subid, " tileid: ", tileid, " command: ", command, " linkval: ", linkval);
    }

    if ( (swid==="none" || swtype==="none" || !swtype || !swid || swid==="0") && tileid )  {
        idx = array_search(tileid, GLB.options["index"]);
        if ( idx===false || idx.indexOf("|")===-1 ) {
            return "error - invalid tile: " + tileid;
        }
        var items = idx.split("|");
        swtype = items[0];
        swid = items[1];
    } else {
        idx = swtype + "|" + swid;
    }
    var specialtiles = utils.getSpecials();

    // handle clocks to return current time always
    if ( (typeof command==="undefined" || !command) && swid==="clockdigital") {
        response = getClock("clockdigital");
        response = getCustomTile(response, "clock", "clockdigital");
    } else if ( (typeof command==="undefined" || !command) && swid==="clockanalog" ) {
        response = getClock("clockanalog");
        response = getCustomTile(response, "clock", "clockanalog");
    
    // handle types that just return the current status
    // added check to skip clicks on things that are commands flagged in ST and HE with an underscore
    // } else if   (   (typeof command==="undefined" || !command ) && ( !subid.startsWith("_") ) &&
    //                 (  
    //                    swtype==="contact" || swtype==="presence" || swtype==="motion" || swtype==="weather" || 
    //                    subid==="temperature" || subid==="name" || subid==="contact" || 
    //                    subid==="presence" || subid==="motion" || subid.startsWith("event_")
    //                 )
    //             ) {
    } else if ( (typeof command==="undefined" || !command ) && testclick(swtype, subid) ) {
        response = allthings[idx]["value"];
        
    // send name, width, height to returnFile routine to get the html tag
    } else if ( (typeof command==="undefined" || command==="") && array_key_exists(swtype, specialtiles) ) {
        var thingvalue = allthings[idx]["value"];
        thingvalue = returnFile(thingvalue, swtype);
        // thingvalue = getCustomTile(thingvalue, swtype, swid);
        response = thingvalue;
    } else {

        // get the hub to call
        if ( hubid==="auto" ) {
            hubid = allthings[idx]["hubnum"];
        }
        var hub = findHub(hubid);

        // first check if this subid has a companion link
        // use command to signal this - HUB is usual case which makes hub call
        // this has been generalized to always read the data from the options array
        // unless command is not set in which case this is a normal HUB call
        var goodcommands = ["POST", "PUT", "GET", "URL", "TEXT", "LINK", "RULE"];
        if ( command && goodcommands.includes(command) ) {
            linkval = "";
            var links = GLB.options[ "user_" + swid];
            links.forEach(function(linkset) {
                if ( linkval==="" && linkset[0]===command && linkset[2]===subid ){
                    linkval = linkset[1];
                }  
            });
        } else {
            linkval = "";
            command = "HUB";
        }
    
        switch(command) {

            case "POST":
            case "PUT":
            case "URL":
                // var posturl = decodeURIComponent(linkval);
                var posturl = linkval;
                var isparm = posturl.indexOf("?");
                var parmstr = "";
                var jsonobj = {};
                if ( isparm!=="-1" ) {
                    parmstr = posturl.substr(isparm+1).split("&");
                    posturl = posturl.substr(0, isparm);
                    if ( posturl.substr(-1)==="/" ) {
                        posturl = posturl.substr(0, posturl.length-1);
                    }
                    parmstr.forEach(function(key) {
                        key = key.split("=");
                        jsonobj[key[0]] = key[1];
                    })
                }
                if ( DEBUG7 ) {
                    console.log( (ddbg()), command + " call: ", posturl, " parms: ", jsonobj);
                }
                curl_call(posturl, null, jsonobj, false, command, urlCallback);
                break;

            case "GET":
                // var posturl = decodeURIComponent(linkval);
                var posturl = linkval;
                if ( DEBUG7 ) {
                    console.log( (ddbg()), command + " call: ", posturl);
                }
                curl_call(posturl, null, jsonobj, false, command, urlCallback);
                break;
            
            // converted this over to getting the custom text out of the options
            // this allows me to avoid lugging around the custom text in the sibling helper
            // this mirrors the code in RULES below
            case "TEXT":
                response = allthings[idx]["value"];
                response[subid] = linkval;
                break;

            // link commands are the only ones that use the linkval setting
            // all others get the user input values from the options file
            case "LINK":
                var lidx = array_search(linkval, GLB.options["index"]);

                if ( lidx ) {
                    var $linked_hubnum = allthings[lidx]["hubnum"];
                    var $linked_swtype = allthings[lidx]["type"];
                    var $linked_swid = allthings[lidx]["id"];
                    var $linked_val = allthings[lidx]["value"];

                    // make hub call if requested and if the linked tile has one
                    var $lhub = findHub($linked_hubnum);

                    // if the link subid is in the linked tile then it is the real subid
                    // otherwise it is a duplicate with info after subid so lets find the real one
                    // this is what allows us to have the same subid referenced to different tiles
                    if ( array_key_exists(subid, $linked_val) ) {
                        var $realsubid = subid;
                    } else {
                        $realsubid = false;
                        for (var key in $linked_val) {
                            if ( subid.indexOf(key) === 0 ) {   //  strpos($subid, key) === 0 ) {
                                $realsubid = key;
                                break;
                            }
                        }
                    }
                    
                    if ( DEBUG12 ) {
                        console.log( (ddbg()),"linked_hubnum: ", $linked_hubnum, " linked_type: ", $linked_swtype,
                                               " linked_id: ", $linked_swid, " linked_val: ", $linked_val, 
                                               " realsubid: ", $realsubid );
                    }
                    // make the action call on the linked thing
                    // the hub callback now handles the linked resposnes properly
                    // if link is to something static, show it
                    if ( $realsubid ) {
                        if ( testclick($linked_swtype, $realsubid) ) {
                            response = $linked_val;
                        } else {
                            var linkinfo = [swid, swtype, subid, $realsubid, "LINK"];
                            response = callHub($lhub, $linked_swid, $linked_swtype, swval, swattr, $realsubid, linkinfo, false, false);
                        }
                    }
                }
                break;

            case "RULE":

                // rewrite the rule to use data in options array
                // no need to pass it around in the tile as with old php version
                if ( ENABLERULES ) {
                    // var linksubid = "user_" + swid;
                    // var allrules = GLB.options[linksubid];
                    // linkval = false;
                    // allrules.forEach(function(ruleset) {
                    //     if ( linkval===false && ruleset[0]==="RULE" && ruleset[2]===subid ){
                    //         linkval = ruleset[1];
                    //     }  
                    // });

                    // get the execution statements and call them all here
                    const regsplit = /[,;]/;
                    if ( linkval ) {
                        var testcommands = linkval.split(regsplit);
                        var istart = 0;
                        if ( testcommands[0].trim().startsWith("if") ) {
                            istart = 1;
                        }
                        if ( DEBUG11 ) {
                            console.log( (ddbg()), "RULE execution: commands: ", testcommands );
                        }
                        execRules(swtype, istart, testcommands, allthings[idx]["value"]);
                    }
                    response = "success";
                } else {
                    response = "error - Rules are not enabled in this version of HousePanel";
                }
                break;

            case "HUB":
                response = callHub(hub, swid, swtype, swval, swattr, subid, false, false, false);

                // process rules and links instantly in case the webSocket doesn't work
                // this also makes the rules run much quicker
                // only harm or side effect is the rule will be executed twice
                // if ( response==="success" && ENABLERULES && subid && (GLB.options.config["rules"] ==="true" || GLB.options.config["rules"] ===true) ) {
                //     var pvalue = clone(allthings[idx]["value"]);
                //     if ( !subid.endsWith("-up") && !subid.endsWith("-dn") ) {
                //         pvalue[subid] = swval;
                //     }
                //     if ( ENABLERULES ) {
                //         processRules(swid, swtype, subid, pvalue);
                //         // processLinks(swid, swtype, subid, pvalue);
                //         GLB.rules[swid] = true;
                //     }
                // }
                break;

            default:
                response = "error";
        }


    }

    async function urlCallback(err, res, body) {
        var webresponse = {};
        if ( err ) {
            webresposne[command] = command + ": error";
        } else if ( typeof body === "object" ) {
            // add any fields returned as an object
            for ( var bkey in body ) {
                if ( typeof body[bkey]==="string" ) {
                    webresponse[bkey] = body[bkey]
                } else if ( typeof body[bkey]==="object" ) {
                    webresponse[bkey] = JSON.stringify(body[bkey]);
                }
            }
            pushClient(swid, swtype, subid, webresponse);
        } else if ( typeof body === "string" && body!=="" && body!=="success" ) {
            webresponse[command] = body;
            pushClient(swid, swtype, subid, webresponse);
        }
        if ( DEBUG13 ) {
            console.log( (ddbg()), "URL callback response: ", UTIL.inspect(body, false, null, false) );
        }
    }

    // while (!finished) { }
    return response;
}

function doQuery(hubid, swid, swtype, tileid, protocol) {
    var result;
    if ( swid==="all" || swid==="fast" || swid==="slow" ) {
        if ( swid==="all" ) {
            var rtype = "normal";
        } else {
            rtype = swid;
        }
        result = {};
        var res;
        for (var idx in (allthings || {}) ) {
            res = allthings[idx];
            var refresh = "normal";
            if ( array_key_exists("refresh", res) ) {
                refresh = res["refresh"];
            }
            if ( array_key_exists("refresh", res.value) ) {
                refresh = res.value["refresh"];
            }
            if ( refresh===rtype ) {
                var item = GLB.options["index"][idx];
                result[item] = res;
            }
        }

        for ( var i=0; i < result.length; i++ ) {
            res = result[i];

            // deal with audio tiles
            if ( res.type==="audio" && array_key_exists("audioTrackData", res.value) ) {
                try {
                    var audiodata = JSON.parse(res.value["audioTrackData"]);
                    if ( audiodata ){
                        res.value["trackDescription"] = audiodata["title"];
                        res.value["currentArtist"] = audiodata["artist"];
                        res.value["currentAlbum"] = audiodata["album"];
                        res.value["trackImage"] = audiodata["albumArtUrl"];
                        res.value["mediaSource"] = audiodata["mediaSource"];
                    }
                } catch(jerr) {
                    audiodata = null;
                }
                delete res.value["audioTrackData"];
            }

            res = getCustomTile(res, res.type, res.id);
            result[i] = returnFile(res, res.type);
            
        }
    } else {
        if ( (swid==="none" || swtype==="none" || !swtype || !swid || swid==="0") && tileid )  {
            idx = array_search(tileid, GLB.options["index"]);
            if ( idx===false || idx.indexOf("|")===-1 ) {
                return "error - invalid tile: " + tileid;
            }
            var items = idx.split("|");
            swtype = items[0];
            swid = items[1];
        } else {
            idx = swtype + "|" + swid;
        }

        if ( allthings && array_key_exists(idx, allthings) && array_key_exists("value", allthings[idx]) ) {
            // return current value and send updated value after hub call to clients and popup window
            if ( hubid==="auto" ) {
                hubid = allthings[idx]["hubnum"];
            }
            var hub = findHub(hubid);
            result = allthings[idx]["value"];
            if ( result["password"] ) {
                delete result["password"];
            }

            // only query the hub which pushes update to GUI if we queried using POST
            // which normally is only from GUI but user could use POST so beware
            // that if you use the HP api in POST mode that all clients will be updated
            // whenever you query a tile. To avoid this use the GET method to query a tile
            // note that actions will always update clients to keep them in sync
            if ( protocol==="POST" ) {
                queryHub(hub, swid, swtype, false);
            }
        } else {
            result = "error - invalid api request. hubid= " + hubid + " id= " + swid + " type= " + swtype + " tile= " + tileid;
        }
    }
    return result;
}

function setOrder(swid, swtype, swval, swattr) {
    var updated = false;
    var result = "error";
    var options = clone(GLB.options);

    // if the options file doesn't exist here something went wrong so skip
    if (options) {
        // now update either the page or the tiles based on type
        switch(swtype) {
            case "rooms":
                options["rooms"] = {};
                for (var roomname in swval) {
                    var roomid = parseInt(swval[roomname]);
                    options["rooms"][roomname] = roomid;
                }
                updated = true;
                result = "success"; // options["rooms"];
                break;

            case "things":
                if (array_key_exists(swattr, options["rooms"])) {
                    options["things"][swattr] = [];
                    swval.forEach(function(valarr) {
                        var val = parseInt(valarr[0]);
                        var vname = valarr[1];
                        var newthing = [val,0,0,1,vname];
                        options["things"][swattr].push(newthing);
                    });
                    updated = true;
                    result = "success"; // options["things"][swattr];
                }
                break;
                
            default:
                result = "error";
                break;
        }

        if (updated) {
            writeOptions(options);
        }
    }
    
    return result;
}

function setPosition(swid, swtype, swval, swattr) {
    
    var updated = false;
    var options = GLB.options;
    var panel = swval["panel"];
    var tile = parseInt(swval["tile"]);
    readOptions("setPosition");
    
    // first find which index this tile is
    // note that this code will not work if a tile is duplicated on a page
    // such duplication is not allowed by the UI anyway but in the
    // event that a user edits hmoptions.cfg to have duplicates
    // the code will get confused here and in other places
    // $i = array_search($tile, options["things"][$panel]);
    var moved = false;
    var idx;
    for ( var i in options["things"][panel]) {
        var arr = options["things"][panel][i];
        if ( is_array(arr) ) {
            idx = parseInt(arr[0]);
        } else {
            idx = parseInt(arr);
        }
        if ( tile === idx) {
            moved = i;
            updated = true;
            break;
        }
    }

    if ( updated && moved!==false ) {
        // change the room index to an array of tile, top, left
        // now we also save zindex and a tile custom name
        var top = parseInt(swattr["top"]);
        var left = parseInt(swattr["left"]);
        var zindex = parseInt(swval["zindex"]);
        var customname = "";
        if ( array_key_exists("custom", swval) ) {
            customname = swval["custom"];
        }
        var newtile = [tile, top, left, zindex, customname];
        options["things"][panel][moved] = newtile;
        writeOptions(options);
        var result = "success";
        if ( DEBUG6 ) {
            console.log( (ddbg()), "new tile position for tile: ", tile," to: (", top, ",", left, ",", zindex, ")");
        }
    } else {
        result = "error";
        console.log( (ddbg()), "error - position for tile: ", tile," was not found to change");
    }
    return result;
    
}

function addThing(bid, thingtype, panel, flag) {
    
    // readOptions("addThing");
    var idx = thingtype + "|" + bid;
    var options = GLB.options;
    var tilenum = parseInt(options["index"][idx]);
    var thesensor = allthings[idx];
    // new additions come in with the default name now
    // var tilename = thesensor["name"];
    var cnt;
    
    // get max thing number for new tiles dragged here
    if ( flag==="auto" ) {
        cnt = 0;
        for (var room in options.things) {
            var len = options.things[room].length;
            cnt = cnt + len;
        }
        cnt++;
    } else {
        cnt = parseInt(flag);
        if ( isNaN(cnt) ) {
            cnt = 0;
        }
    }
    var lastid = options["things"][panel].length - 1;
    var lastitem = options["things"][panel][lastid];

    var ypos = parseInt(lastitem[1]);
    var xpos = parseInt(lastitem[2]);
    var zindex = 1;
    if ( lastitem.length > 3 ) {
        zindex = parseInt(lastitem[3]);
    }

    // protect against off screen values
    if ( xpos < -400 || xpos > 400 || ypos < -400 || ypos > 400 ) {
        xpos = 0;
        ypos = 0;
    }
    
    // add it to our system in the requested room/panel
    options["things"][panel].push([tilenum, ypos, xpos, zindex, ""]);
    
    // make a new tile based on the dragged information
    var thing = makeThing(cnt, tilenum, thesensor, panel, ypos, xpos, zindex, "", "");
    writeOptions(options);
    
    return thing;
}

function delThing(bid, thingtype, panel, tile) {
    
    var idx = thingtype + "|" + bid;
    var retcode = "error";
    // readOptions("delThing");
    
    if ( panel && array_key_exists(panel, GLB.options["things"]) &&
                   array_key_exists(idx, GLB.options["index"]) ) {

        var optionthings = clone(GLB.options["things"][panel]);

        // as a double check the options file tile should match
        // if it doesn't then something weird triggered drag drop
        // note - if there are duplicates the first one will be deleted
        var tilenum = parseInt(GLB.options["index"][idx]);
        if ( parseInt(tile) === tilenum ) {

            // remove tile from this room
            for (var key in optionthings) {
                var thing = optionthings[key];
                if ( (is_array(thing) && parseInt(thing[0]) === tilenum) ||
                     (!is_array(thing) && parseInt(thing) === tilenum) ) {

                    delete optionthings[key];
                    retcode = "success";
                    break;
                }
            }   

            if ( retcode === "success" ) {
                // options.things[panel] = array_values(options["things"][panel]);
                GLB.options["things"][panel] = [];
                optionthings.forEach(function(orderthing) {
                    GLB.options["things"][panel].push(orderthing);
                })
                writeOptions(GLB.options);
            } else {
                console.log( (ddbg()), "error - could not safely delete tile: ", tile, " with id: ", bid, " from room: ", panel);
            }
        }
    }
    return retcode;
}

function delPage(pagename) {
    
    var options = GLB.options;
    var retcode;
    // readOptions("delPage");

    // check if room exists - ignore number matches
    if ( utils.count(options["rooms"]) <= 1 ) {
        retcode = "error - page= " + pagename + " is the only page remaining. Cannot delete the last page.";
    } else if ( array_key_exists(pagename, options["rooms"]) &&
                array_key_exists(pagename, options["things"]) ) {
        delete options["rooms"][pagename];
        delete options["things"][pagename];
        writeOptions(options);
        retcode = "success";
    } else {
        retcode = "error - cannot find page= " + pagename + " to delete.";
    }
    return retcode;
}

function addPage() {
    var pagenum = 0;
    var options = GLB.options;
    // readOptions("addPage");
    
    // get the largest room number
    for ( var roomname in options["rooms"] ) {
        var roomnum = parseInt(options["rooms"][roomname]);
        pagenum = roomnum > pagenum ? roomnum : pagenum;
    }
    pagenum++;

    // get new room default name in sequential order
    var newname = "Newroom1";
    var num = 1;
    while ( array_key_exists(newname, options["rooms"]) ) {
        $num++;
        $newname = "Newroom" + num.toString();
    }
    options["rooms"][newname] = pagenum;
    
    // put a digital clock in all new rooms so they are not empty
    var clockid = options["index"]["clock|clockdigital"];
    var clock = [clockid, 0, 0, 1, ""];
    options["things"][newname] = [clock];
    writeOptions(options);
    return newname;
}

function getInfoPage(returnURL, pathname) {

    // readOptions("getInfoPage");
    var configoptions = GLB.options["config"];
    var skin = configoptions["skin"];
    var hubs = configoptions["hubs"];
    var specialtiles = utils.getSpecials();
    
    var $tc = "";
    var skin = getSkin();
    $tc += utils.getHeader(skin);
    $tc += "<h3>" + utils.APPNAME + " Information Display</h3>";

    $tc += "<form>";
    $tc += utils.hidden("returnURL", returnURL);
    $tc += utils.hidden("pathname", pathname);
    $tc += utils.hidden("pagename", "info");
    $tc += "</form>";
    $tc += "<div class=\"infopage\">";
    $tc += "<div class='bold'>Site url = " + returnURL + "</div>";
    $tc += "<div class='bold'>Skin folder = " + skin + "</div>";
    $tc += "<div class='bold'>" + hubs.length + " Hubs active</div>";
    $tc += "<hr />";
    
    var num = 0;
    hubs.forEach (function(hub) {
        // putStats(hub);
        var hubType = hub["hubType"];
        var hubName = hub["hubName"];
        var hubHost = hub["hubHost"];
        var hubId = hub["hubId"];
        var clientId = hub["clientId"];
        var clientSecret = hub["clientSecret"];
        var access_token = hub["hubAccess"];
        var endpt = hub["hubEndpt"];
        $tc += "<div class='bold'>Hub #" + num + "</div>";
        $tc += "<div class='bold'>Hub Name = " + hubName + "</div>";
        $tc += "<div>Type = " + hubType + "</div>";
        $tc += "<div>Hub ID = " + hubId + "</div>";
        $tc += "<div>Hub Host URL = " + hubHost + "</div>";
        $tc += "<div>Client ID = " + clientId + "</div>";
        $tc += "<div>Client Secret = " + clientSecret + "</div>";
        $tc += "<div>AccessToken = " + access_token + "</div>";
        $tc += "<div>Endpoint = " + endpt + "</div>";
        if ( (num + 1) < hubs.length ) {
            $tc += "<hr />";
        }
        num++;
    });

    $tc += "</div>";

    if ( clients.length > 0 ) {
        var str = "<p>Currently connected to " + clients.length + " clients.</p>";
        str = str + "<br><hr><br>";
        for (var i=0; i < clients.length; i++) {
            str = str + "Client #" + i + " host= " + clients[i].socket.remoteAddress + " <br>";
        }
        str = str + "<br><hr><br>";
        $tc +=  str;
    }
    

    $tc += "<button class=\"showhistory\">Show Dev Log</button>";
    $tc += "<div id=\"devhistory\" class=\"infopage hidden\">";
    $tc += "<pre>" + utils.DEV + "</pre>";
    $tc += "</div>";
    
    $tc += "<br><br><h3>List of Authorized Things</h3>";
    $tc += "<table class=\"showid\">";
    $tc += "<thead><tr><th class=\"thingname\">Name" + 
        "</th><th class=\"infotype\">Nickname" + 
        "</th><th class=\"thingarr\">Value Array" + 
        "</th><th class=\"infoid\">Thing id" +
        "</th><th class=\"infotype\">Type" + 
        "</th><th class=\"hubid\">Hub" +
        "</th><th class=\"infonum\">Tile Num</th></tr></thead>";

    var sensors = sortedSensors("hubnum", "name", "type");
    for (var i in sensors) {
        var thing = sensors[i];
        var idx = thing.type + "|" + thing.id;
        var value = "";
        if ( is_object(thing["value"]) ) {
            for (var key in thing["value"] ) {
                var val = thing["value"][key];
                value += " ";
                if ( key==="name" ) {
                    continue;  // value = value;
                } else if ( array_key_exists(key, specialtiles) ) {
                    value += key + "= <strong>embedded " + key + "</strong><br/>";
                } else if ( thing["type"]==="custom" && typeof val==="object" ) { 
                    value += "Custom Array..."; 
                } else if ( typeof val==="object" ) {
                    value += key + "=" + JSON.stringify(val);
                } else if ( typeof val === "string" && val.length > 128 ) {
                    val = val.substr(0,124) + " ...";
                    value += key + "=" + val + "<br/>";
                } else if ( typeof val==="string" ) {
                    value += key + "=" + val;
                } else {
                    value += key + "=" + val.toString();
                }
            }
        } else {
            value = thing["value"];
            if ( value.length > 128 ) {
                value = value.substr(0,124) + " ...";
            }
        }
        // limit size of the field shown
        
        var hubnum = thing["hubnum"];
        if ( hubnum === -1 || hubnum === "-1" ) {
            var hubstr = "None<br><span class=\"typeopt\"> (" + hubnum + ": None)</span>";
        } else {
            var hub = findHub(hubnum);
            var hubType = hub["hubType"];
            var hubName = hub["hubName"];
            var hubstr = hubName + "<br><span class=\"typeopt\"> (" + hubnum + ": " + hubType + ")</span>";
        }
        
        $tc += "<tr><td class=\"thingname\">" + thing["name"] +
            "</td><td class=\"thingname\">" + thing.value.name +
            "</td><td class=\"thingarr\">" + value +
            "</td><td class=\"infoid\">" + thing["id"] +
            "</td><td class=\"infotype\">" + thing["type"] +
            "</td><td class=\"hubid\">" + hubstr + 
            "</td><td class=\"infonum\">" + GLB.options["index"][idx] + "</td></tr>";
    }
    $tc += "</table>";
    $tc += "<button class=\"infobutton fixbottom\">Return to HousePanel</button>";

    $tc += utils.getFooter();
    return $tc;
}

function hubFilters(hubpick, ncols) {
    var options = GLB.options;
    var $useroptions = options["useroptions"];
    var configoptions = options["config"];
    var $hubs = configoptions["hubs"];
    var $thingtypes = utils.getTypes();

    var retpage = GLB.returnURL;
    var $tc = "";
    $tc+= "<form id=\"filteroptions\" class=\"options\" name=\"filteroptions\" action=\"" + retpage + "\"  method=\"POST\">";
    
    // if more than one hub then let user pick which one to show
    var hubpick = "all";
    if ( configoptions["hubpick"] ) {
        hubpick = configoptions["hubpick"];
    }
    if ( utils.count($hubs) > 1 ) {
        $tc+= "<div class=\"filteroption\">Hub Filters: ";
        var $hid = "hopt_all";
        var checked = (hubpick==="all") ? " checked='1'" : "";
        $tc+= "<div class='radiobutton'><input id='" + $hid + "' type='radio' name='huboptpick' value='all'"  + checked + "><label for='" + $hid + "'>All Hubs</label></div>";
        $hid = "hopt_none";
        checked = (hubpick==="-1") ? " checked='1'" : "";
        $tc+= "<div class='radiobutton'><input id='" + $hid + "' type='radio' name='huboptpick' value='-1'" + checked + "><label for='" + $hid + "'>No Hub</label></div>";
        var $hubcount = 0;
        $hubs.forEach(function($hub) {
            var $hubName = $hub["hubName"];
            var $hubType = $hub["hubType"];
            var $hubId = $hub["hubId"];
            $hid = "hopt_" + $hubId;
            checked = (hubpick===$hubId) ? " checked='1'" : "";
            $tc+= "<div class='radiobutton'><input id='" + $hid + "' type='radio' name='huboptpick' value='" + $hubId + "'" + checked + "><label for='" + $hid + "'>" + $hubName + " (" + $hubType + ")</label></div>";
            $hubcount++;
        });
        $tc+= "</div>";
    }

    // buttons for all or no filters
    $tc+= "<div id=\"thingfilters\" class='filteroption'>Select Things to Display:</div>";
    $tc+= "<div id=\"filterup\" class=\"filteroption\">";
    $tc+= "<div id=\"allid\" class=\"smallbutton\">All</div>";
    $tc+= "<div id=\"noneid\" class=\"smallbutton\">None</div>";

    $tc+= "<table class=\"useroptions\"><tr>";
    var $i= 0;
    for (var $iopt in $thingtypes) {
        var $opt = $thingtypes[$iopt];
        $i++;
        if ( in_array($opt, $useroptions ) ) {
            $tc+= "<td><input id=\"cbx_" + $i + "\" type=\"checkbox\" name=\"useroptions[]\" value=\"" + $opt + "\" checked=\"1\">";
        } else {
            $tc+= "<td><input id=\"cbx_" + $i + "\" type=\"checkbox\" name=\"useroptions[]\" value=\"" + $opt + "\">";
        }
        $tc+= "<label for=\"cbx_" + $i + "\" class=\"optname\">" + $opt + "</label></td>";
        if ( $i % ncols == 0 && $i < utils.count($thingtypes) ) {
            $tc+= "</tr><tr>";
        }
    }
    $tc+= "</tr></table>";
    $tc+= "</div>";
    $tc+= "</form>";

    return $tc;
}

// this little gem will sort by up to three things
function sortedSensors(one, two, three) {

    if ( !one ) { one = "name"; }

    // put sensors in an array so we can sort them
    var sensors = Object.values(allthings).sort( function(obja, objb) {
        function test(a, b) {
            if ( typeof a === "object" || typeof b === "object" ) { return 0; }
            else if ( a===b ) { return 0 }
            else if ( a > b ) { return 1; }
            else { return -1; }
        }
        var check = test(obja[one], objb[one]);
        if ( check===0 && two ) {
            check = test(obja[two], objb[two]);
            if ( check===0 && three ) {
                check = test(obja[three], objb[three]);
            }
        }
        return check;
    });
    return sensors;
}

function getCatalog(hubpick) {

    if ( !hubpick ) {
        hubpick = "all";
    }
    var $tc = "";
    var useroptions = GLB.options["useroptions"];
    $tc += "<div id=\"catalog\">";
    $tc += hubFilters(hubpick, 3);

    $tc += "<div class='scrollvtable fshort'><table class=\"catalog\">";

    // put sensors in an array so we can sort them
    var sensors = sortedSensors("hubnum", "name");
    // console.log("sorted sensors: ", sensors);

    var i= 0;
    // for(var idx in allthings) {
    //     var thesensor = allthings[idx];
    for ( var idx in sensors ) {
        var thesensor = sensors[idx];
        var bid = thesensor["id"];
        var thingtype = thesensor["type"];
        var thingname = thesensor["name"];
        var hubId = thesensor["hubnum"].toString();
        var cat = "cat-" + i.toString();
        // if ( hubId === "-1" ) {
        //     hubId = "none";
        // }

        if ( thingname.length > 23 ) {
            var thingpr = thingname.substr(0,23) + " ...";
        } else {
            thingpr = thingname;
        }
        
        if (in_array(thingtype, useroptions) && (hubpick===hubId || hubpick==="all")) {
            var hide = "";
        } else {
            hide = "hidden ";
        }

        $tc += "<div id=\"" + cat + "\" bid=\"" + bid + "\" type=\"" + thingtype + "\" hubid=\"" + hubId + "\" ";
        $tc += "panel=\"catalog\" class=\"thing " + hide + "catalog-thing\">"; 
        $tc += "<div class=\"thingname\">" +  thingpr + "</div>";
        $tc += "<div class=\"thingtype\">" + thingtype + "</div>";
        $tc +="</div>";
        i++;
    }
    $tc += "</table></div>";
    $tc += "</div>";
    return $tc;
}

// this used to create input blocks for auth page
// it was modified for use now on the options page
function tsk($timezone, $skin, $uname, $port, $webSocketServerPort, $fast_timer, $slow_timer, polisyip) {

    var $tc= "";
    $tc += "<form id=\"userpw\" class=\"options\" name=\"userpw\" action=\"" + GLB.returnURL + "\"  method=\"POST\">";

    $tc += "<div class=\"filteroption\">";
    $tc += "<div class='inp'><label class=\"startupinp\">Skin Folder: </label>";
    $tc += "<input id=\"skinid\" class=\"startupinp\" name=\"skin\" width=\"80\" type=\"text\" value=\"" + $skin + "\"/></div>"; 
    
    $tc += "<div><label class=\"startupinp\">Timezone: </label>";
    $tc += "<input id=\"newtimezone\" class=\"startupinp\" name=\"timezone\" width=\"80\" type=\"text\" value=\"" + $timezone + "\"/></div>"; 

    $tc += "<div><label class=\"startupinp\">Main App Port: </label>";
    $tc += "<input id=\"newport\" class=\"startupinp\" name=\"port\" width=\"20\" type=\"text\" value=\"" + $port + "\"/></div>"; 

    $tc += "<div><label class=\"startupinp\">WebSocket Port: </label>";
    $tc += "<input id=\"newsocketport\" class=\"startupinp\" name=\"webSocketServerPort\" width=\"20\" type=\"text\" value=\"" + $webSocketServerPort + "\"/></div>"; 

    $tc += "<div><label class=\"startupinp\">Fast Timer: </label>";
    $tc += "<input id=\"newfast_timer\" class=\"startupinp\" name=\"fast_timer\" width=\"20\" type=\"text\" value=\"" + $fast_timer + "\"/></div>"; 

    $tc += "<div><label class=\"startupinp\">Slow Timer: </label>";
    $tc += "<input id=\"newslow_timer\" class=\"startupinp\" name=\"slow_timer\" width=\"20\" type=\"text\" value=\"" + $slow_timer + "\"/></div>"; 

    $tc += "<div><label class=\"startupinp\">Polisy box IP: </label>";
    $tc += "<input id=\"newpolisyip\" class=\"startupinp\" name=\"polisyip\" width=\"30\" type=\"text\" value=\"" + polisyip + "\"/></div>"; 

    $tc += "<div><label for=\"uname\" class=\"startupinp\">Username: </label>";
    $tc += "<input id=\"uname\" class=\"startupinp\" name=\"uname\" width=\"20\" type=\"text\" value=\"" + $uname + "\"/></div>"; 

    $tc += "<div><label for=\"pword\" class=\"startupinp\">Set New Password: </label>";
    $tc += "<input id=\"pword\" class=\"startupinp\" name=\"pword\" width=\"80\" type=\"password\" value=\"\"/></div>"; 
    
    $tc += "<div><label></label><span class='indent typeopt'>(blank to keep prior)</span></div>";
    $tc += "<div></div><br />";
    $tc += "</div>";
    $tc += "</form>";

    return $tc;
    
}

function getOptionsPage(pathname) {
    var retpage = GLB.returnURL;
    var $thingtypes = utils.getTypes();
    var specialtiles = utils.getSpecials();

    var options = GLB.options;
    var $roomoptions = options["rooms"];
    var $thingoptions = options["things"];
    var indexoptions = options["index"];
    var $useroptions = options["useroptions"];
    var configoptions = options["config"];
    var skin = getSkin();
    var $port = configoptions["port"];
    var $webSocketServerPort = configoptions["webSocketServerPort"];
    var $fast_timer = configoptions["fast_timer"];
    var $slow_timer = configoptions["slow_timer"];
    var $kioskoptions = configoptions["kiosk"];
    var $ruleoptions = configoptions["rules"];
    var $timezone = configoptions["timezone"];
    var $uname = getUserName();
    var polisyip = configoptions["polisyip"] || "localhost";

    var hubpick = "all";
    if ( configoptions["hubpick"] ) {
        hubpick = configoptions["hubpick"];
    }
    
    var $tc = "";
    $tc += utils.getHeader(skin);
    $tc += "<h3>" + utils.APPNAME + " Options</h3>";
    $tc += "<div class=\"formbutton formauto\"><a href=\"" + retpage + "\">Cancel and Return to HousePanel</a></div>";
    
    // $tc += "<div id=\"optionstable\" class=\"optionstable\">";

    $tc += utils.hidden("returnURL", retpage);
    $tc += utils.hidden("pathname", pathname);
    $tc += utils.hidden("pagename", "options");

    $tc += hubFilters(hubpick, 7);
    $tc += tsk($timezone, skin, $uname, $port, $webSocketServerPort, $fast_timer, $slow_timer, polisyip);

    $tc += "<form id=\"optionspage\" class=\"options\" name=\"options\" action=\"" + retpage + "\"  method=\"POST\">";

    $tc += "<div class=\"filteroption\">";
    $tc += "Specify number of special tiles: ";
    for (var $stype in specialtiles) {
        var sid = specialtiles[$stype];
        var $customcnt = getCustomCount($stype, sid[3]);
        var $stypeid = "cnt_" + $stype;
        $tc+= "<br /><label for=\"$stypeid\" class=\"kioskoption\"> " + $stype +  " tiles: </label>";
        $tc+= "<input class=\"specialtile\" id=\"" + $stypeid + "\" name=\"" + $stypeid + "\" width=\"10\" type=\"number\"  min='0' max='99' step='1' value=\"" + $customcnt + "\" />";
    }
    $tc+= "</div>";

    $tc += "<div class=\"filteroption\">";
    $tc += "Other options: <br/>";
    $tc += "<label for=\"kioskid\" class=\"kioskoption\">Kiosk Mode: </label>";    
    var $kstr = ($kioskoptions===true || $kioskoptions==="true" || $kioskoptions==="1" || $kioskoptions==="yes") ? "checked" : "";
    $tc+= "<input id=\"kioskid\" width=\"24\" type=\"checkbox\" name=\"kiosk\"  value=\"" + $kioskoptions + "\" " + $kstr + "/>";
    if ( ENABLERULES ) {
        $tc += "<label for=\"ruleid\" class=\"kioskoption\">Enable Rules? </label>";
        var $rstr = ($ruleoptions===true || $ruleoptions==="true" || $ruleoptions==="1" || $ruleoptions==="yes") ? "checked" : "";
        $tc += "<input id=\"ruleid\" width=\"24\" type=\"checkbox\" name=\"rules\"  value=\"" + $ruleoptions + "\" " + $rstr + "/>";
    }
    $tc += "</div>";

    var fcastcity = configoptions["fcastcity"] || "ann-arbor";
    var fcastregion = configoptions["fcastregion"] || "";
    var fcastcode = configoptions["fcastcode"] || "";   //  ann-arbor code is 42d28n83d74
    var $accucity = configoptions["accucity"];
    var $accuregion = configoptions["accuregion"];
    var $accucode = configoptions["accucode"];      // ann-arbor-mi code is 329380
    $tc += "<div class=\"filteroption\">";
    $tc += "<table>";
    $tc += "<tr>";
    $tc += "<td><label for=\"fcastcityid\" class=\"kioskoption\">Forecast City: </label></td>";
    $tc += "<td><input id=\"fcastcityid\" width=\"180\" type=\"text\" name=\"fcastcity\"  value=\"" + fcastcity + "\" /></td>";
    $tc += "<td><label for=\"fcastregionid\" class=\"kioskoption\">Forcast Region: </label></td>";
    $tc += "<td><input id=\"fcastregionid\" width=\"40\" type=\"text\" name=\"fcastregion\"  value=\"" + fcastregion + "\"/></td>";
    $tc += "<td><label for=\"fcastcodeid\" class=\"kioskoption\">Forecast Code: </label></td>";
    $tc += "<td><input id=\"fcastcodeid\" width=\"20\" type=\"text\" name=\"fcastcode\"  value=\"" + fcastcode + "\"/>";
    $tc += "<span class='typeopt'>(for Frame1 tiles)</span></td>";
    $tc += "</tr><tr>";
    $tc += "<td><label for=\"accucityid\" class=\"kioskoption\">Accuweather City: </label></td>";
    $tc += "<td><input id=\"accucityid\" width=\"180\" type=\"text\" name=\"accucity\"  value=\"" + $accucity + "\" /></td>";
    $tc += "<td><label for=\"accuregionid\" class=\"kioskoption\">Accuweather Region: </label></td>";
    $tc += "<td><input id=\"accuregionid\" width=\"6\" type=\"text\" name=\"accuregion\"  value=\"" + $accuregion + "\"/></td>";
    $tc += "<td><label for=\"accucodeid\" class=\"kioskoption\">AccuWeather Code: </label></td>";
    $tc += "<td><input id=\"accucodeid\" width=\"40\" type=\"text\" name=\"accucode\"  value=\"" + $accucode + "\"/>";
    $tc += "<span class='typeopt'>(for Frame2 tiles)</span></td>";
    $tc += "</tr></table></div>";
    
    // now display the table of all the rooms and thing options
    $tc += "<table class=\"headoptions\"><thead>";
    $tc += "<tr><th class=\"thingname\">Thing Name (type)</th>";
    $tc += "<th class=\"hubname\">Hub</th>";
   
    // list the room names in the proper order
    // for ($k=0; $k < count($roomoptions); $k++) {
    for (var $roomname in $roomoptions) {
        $tc+= "<th class=\"roomname\">" + $roomname;
        $tc+= "</th>";
    }
    $tc += "</tr></thead>";
    $tc += "</table>";
    $tc += "<div class='scrollvtable'>";
    $tc += "<table class=\"roomoptions\">";
    $tc += "<tbody>";

    // sort the things
    // uasort(allthings, "mysortfunc");
    
    // now print our options matrix
    // $rowcnt = 0;
    var $evenodd = true;
    var $hub;

    // use a sorted list
    var sensors = sortedSensors("hubnum", "name", "type");

    // for (var $thingid in allthings) {
    //     var $thesensor = allthings[$thingid];
    for ( var i in sensors) {
        var $thesensor = sensors[i];
        var idx = $thesensor.type + "|" + $thesensor.id;
        // if this sensor type and id mix is gone, skip this row
        
        var $thingname = $thesensor["name"];
        var nickname = $thesensor.value["name"] || "";
        var $thetype = $thesensor["type"];
        var $hubnum = $thesensor["hubnum"];
        if ( $hubnum === -1 || $hubnum==="-1" ) {
            $hub = null;
            var $hubType = "None";
            var $hubStr = "None";
            var $hubId = "-1";
        } else {
            $hub = findHub($hubnum);
            $hubType = $hub["hubType"];
            $hubStr = $hub["hubName"];
            $hubId = $hub["hubId"];
        }

        // get the tile index number
        try {
            var $thingindex = indexoptions[idx].toString();
        } catch (e) {
            console.log(e, " idx: ", idx, " is invalid");
            return;
        }
        
        // write the table row
        if ( array_key_exists($thetype, specialtiles) ) {
            var $special = " special";
        } else {
            $special = "";
        }
        var $odd = $evenodd = false;
        if (in_array($thetype, $useroptions)) {
            $evenodd = !$evenodd;
            $evenodd ? $odd = " odd" : $odd = "";
            $tc+= "<tr type=\"" + $thetype + "\" tile=\"" + $thingindex + "\" class=\"showrow" + $odd + $special + "\">";
        } else {
            $tc+= "<tr type=\"" + $thetype + "\" tile=\"" + $thingindex + "\" class=\"hiderow" + $special + "\">";
        }
        
        $tc+= "<td class=\"thingname\">";
        $tc+= $thingname + "<span class=\"typeopt\"> (" + $thetype + ")";
        if ( nickname && nickname!==$thingname ) { 
            $tc+= "<br>custom: " + nickname; 
        } else {
            $tc+= "<br>custom: none"; 
        }
        $tc+= "</span>";
        $tc+= "</td>";
        
        $tc+= "<td class=\"hubname\" hubId=\"" + $hubId + "\">";
        $tc+= $hubStr + " (" + $hubType + ")";
        $tc+= "</td>";

        // loop through all the rooms
        // this addresses room bug
        for ( var $roomname in $roomoptions ) {
            
            // get the name of this room for this column
            // $roomname = array_search($k, $roomoptions);
            // $roomlist = array_keys($roomoptions, $k);
            // $roomname = $roomlist[0];
            if ( array_key_exists($roomname, $thingoptions) ) {
                var $things = $thingoptions[$roomname];
                                
                // now check for whether this thing is in this room
                $tc+= "<td>";
                
                var $ischecked = false;
                var $idx;
                for (var i in $things) {
                    var $arr = $things[i];
                    if ( is_array($arr) ) {
                        $idx = $arr[0].toString();
                    } else {
                        $idx = $arr.toString();
                    }
                    if ( $idx === $thingindex ) {
                        $ischecked = true;
                        break;
                    }
                }
                
                if ( $ischecked ) {
                    $tc+= "<input type=\"checkbox\" name=\"" + $roomname + "[]\" value=\"" + $thingindex + "\" checked=\"1\" >";
                } else {
                    $tc+= "<input type=\"checkbox\" name=\"" + $roomname + "[]\" value=\"" + $thingindex + "\" >";
                }
                $tc+= "</td>";
            }
        }
        $tc+= "</tr>";
    }

    $tc+= "</tbody></table>";
    $tc+= "</div>";
    $tc+= "<div id='optionspanel' class=\"processoptions\">";
    $tc +='<div id="optSave" class="formbutton">Save</div>';
    $tc +='<div id="optReset" class="formbutton">Reset</div>';
    $tc +='<div id="optCancel" class="formbutton">Cancel</div><br>';
    $tc+= "</div>";
    $tc+= "</form>";
    
    // $tc+= "</div>";

    $tc += utils.getFooter();

    return $tc;
}

// renders the main page
function mainPage(proto, hostname, pathname) {
    var $tc = "";
    var thingoptions = GLB.options["things"];
    var roomoptions = GLB.options["rooms"];
    var config = GLB.options.config;
    var skin = getSkin();
    var kioskmode = GLB.options.config["kiosk"];
    if ( kioskmode === "true" || kioskmode===1 || kioskmode==="yes" ) {
        kioskmode = true;
    } else {
        kioskmode = false;
    }
    GLB.returnURL = proto + "://" + hostname
    console.log(  "\n****************************************************************",
                  "\nServing page at: ", GLB.returnURL,
                  "\n****************************************************************");

    $tc += utils.getHeader(skin);

    if ( GLB.newuser ) {
        $tc += "<div class=\"greeting\"><strong>Welcome New User!</strong><br/ >You should first try to link your smart home hubs, using the Hub Auth button below. ";
        $tc += "You can also explore all that HousePanel has to offer by experimenting with the two clock tiles placed in each room. ";
        $tc += "When you are done, they can be removed in Edit mode or from the Options page. Click on the ? mark in the upper right corner. ";
        $tc += "to access the full online manual. Have fun!</div>";
        GLB.newuser = false;
    }

    if ( DEBUG4 ) {
        console.log( (ddbg()), GLB.options);
    }
    // make sure our active skin has a custom file
    if ( !fs.existsSync(skin + "/customtiles.css") ) {
        writeCustomCss(skin, "");
    }
    
    // new wrapper around catalog and things but excluding buttons
    $tc += '<div id="dragregion">';
    $tc += '<div id="tabs"><ul id="roomtabs">';

    // show all room with whatever index number assuming unique
    for (var room in roomoptions) {
        var k = roomoptions[room];
        if ( thingoptions[room] ) {
            var adder= "<li roomnum=\"" + k + "\" class=\"tab-" + room + "\"><a href=\"#" + room + "-tab\">" + room + "</a></li>";
            $tc += adder;
        }
    }
    $tc += '</ul>';

    // changed this to show rooms in the order listed
    // this is so we just need to rewrite order to make sortable permanent
    var cnt = 0;
    for (var room in roomoptions) {
        var k = roomoptions[room];
        if ( thingoptions[room] ) {
            var things = thingoptions[room];
            var pgobj = getNewPage(cnt, room, k, things);
            $tc += pgobj.tc;
            cnt = pgobj.cnt;
        }
    }

    // include doc button and username that is logged in
    var uname = getUserName();
    $tc += '<div id="showversion" class="showversion">';
    $tc += '<span id="infoname">' + uname + "</span><span> - V" + utils.HPVERSION + '</span>';
    $tc += '<div id="showdocs"><a href="http://www.housepanel.net" target="_blank">?</a></div>';
    $tc += "</div>";

    // end of the tabs
    $tc += "</div>";

    // set the websock servername as same as hosted page but different port
    var webSocketUrl = "";
    if ( config.webSocketServerPort && !isNaN(parseInt(config.webSocketServerPort)) ) {
        var icolon = hostname.indexOf(":");
        if ( icolon >= 0 ) {
            webSocketUrl = "ws://" + hostname.substr(0, icolon);
        } else {
            webSocketUrl = "ws://" + hostname;
        }
        webSocketUrl = webSocketUrl + ":" + config.webSocketServerPort;
    }
    
    // include form with useful data for js operation
    $tc += "<form id='kioskform'>";
    $tc += utils.hidden("pagename", "main");
    var erstr =  ENABLERULES ? "true" : "false"
    $tc += utils.hidden("enablerules", erstr);

    // save the socket address for use on js side
    // var webSocketUrl = config.webSocketServerPort ? ("ws://" + serverName + ":" + config.webSocketServerPort) : "";
    $tc += utils.hidden("webSocketUrl", webSocketUrl);

    // save Node.js address for use on the js side
    $tc += utils.hidden("returnURL", GLB.returnURL);
    $tc += utils.hidden("pathname", pathname);
    $tc += utils.hidden("skinid", skin, "skinid");

    // show user buttons if we are not in kiosk mode
    if ( !kioskmode ) {
        $tc += "<div id=\"controlpanel\">";
        $tc +='<div id="showoptions" class="formbutton">Options</div>';
        $tc +='<div id="refreshpage" class="formbutton">Refresh</div>';
        // $tc +='<div id="refactor" class="formbutton confirm">Refactor</div>';
        $tc +='<div id="reauth" class="formbutton confirm">Hub Auth</div>';
        $tc +='<div id="showid" class="formbutton">Show Info</div>';
        $tc +='<div id="toggletabs" class="formbutton">Hide Tabs</div>';
        $tc +='<div id="blackout" class="formbutton">Blackout</div>';

        $tc += "<div class=\"modeoptions\" id=\"modeoptions\"> \
          <input id=\"mode_Operate\" class=\"radioopts\" type=\"radio\" name=\"usemode\" value=\"operate\" checked><label for=\"mode_Operate\" class=\"radioopts\">Operate</label> \
          <input id=\"mode_Reorder\" class=\"radioopts\" type=\"radio\" name=\"usemode\" value=\"reorder\" ><label for=\"mode_Reorder\" class=\"radioopts\">Reorder</label> \
          <input id=\"mode_Edit\" class=\"radioopts\" type=\"radio\" name=\"usemode\" value=\"edit\" ><label for=\"mode_Edit\" class=\"radioopts\">Edit</label> \
          <input id=\"mode_Snap\" class=\"radioopts\" type=\"checkbox\" name=\"snapmode\" value=\"snap\"><label for=\"mode_Snap\" class=\"radioopts\">Grid Snap?</label> \
        </div><div id=\"opmode\"></div>";
        $tc +="</div>";
    }
    $tc += "</form>";

    // end drag region enclosing catalog and main things
    $tc += "</div>";

    $tc += utils.getFooter();
        
    return $tc;
}

function clone(obj) {
    return JSON.parse(JSON.stringify(obj));
}


function saveFilters(body) {
    if ( DEBUG4 ) {
        console.log( (ddbg()), "filters save request: ", body);
    }
    var rewrite = false;
    var result = {};

    if ( body.useroptions ) {
        GLB.options["useroptions"] = body.useroptions;
        result.useroptions = body.useroptions;
        rewrite = true;
    }

    if ( typeof body.huboptpick !== "undefined" ) {
        GLB.options["config"]["hubpick"] = body.huboptpick;
        result.huboptpick = body.huboptpick;
        rewrite = true;
    }

    if ( rewrite ) {
        writeOptions(GLB.options, true);
    }
    return result;
}

function saveUserPw(body) {
    if ( DEBUG3 ) {
        console.log( (ddbg()), "password save request: ", body);
    }

    // get current options;
    // readOptions();

    // get the username and passwords
    var olduname = getUserName();
    var uname = olduname;
    var oldhash = "";
    var hash = "";
    var defskin;
    var polisyip = GLB.options.config["polisyip"] || "localhost";
    if ( GLB.options.config["skin"] ) {
        defskin = GLB.options.config["skin"];
    } else {
        defskin = "skin-housepanel";
        GLB.options.config["skin"] = defskin;
    }
    
    // get default pw and its skin
    // or set up default if isn't configured
    if (array_key_exists("pword", GLB.options.config)) {
        if ( array_key_exists(uname, GLB.options.config["pword"]) ) {
            var pwords = GLB.options.config["pword"];
            oldhash = pwords[uname][0];
            defskin = pwords[uname][1];
            GLB.options.config["skin"] = defskin;
        }
    } else {
        GLB.options.config["pword"] = {};
        GLB.options.config["pword"][uname] = [oldhash, defskin];
    }

    var skin = defskin;
    var result = {};

    for (var key in body) {
        var val = body[key];

        //skip the returns from the submit button and the flag
        if (key==="skin") {
            skin = val;
        } else if ( key==="timezone" ) {
            GLB.options.config["timezone"] = val;
        } else if ( key==="port" ) {
            var port = parseInt(val);
            if ( !isNaN(port) ) {
                GLB.options.config["port"] = port;
                var loc = GLB.returnURL.indexOf(":", 7);
                result.port = port;
                result.returnURL = GLB.returnURL.substr(0, loc) + ":" + port.toString();
            }
        } else if ( key==="webSocketServerPort" ) {
            var wsport = parseInt(val);
            if ( !isNaN(wsport) ) {
                GLB.options.config["webSocketServerPort"] = wsport;
            }
        } else if ( key==="fast_timer" ) {
            var fast_timer = parseInt(val);
            if ( isNaN(fast_timer) ) {
                fast_timer = 0;
            }
            GLB.options.config["fast_timer"] = fast_timer;
        } else if ( key==="slow_timer" ) {
            var slow_timer = parseInt(val);
            if ( isNaN(slow_timer) ) {
                slow_timer = 0;
            }
            GLB.options.config["slow_timer"] = slow_timer;
        } else if ( key==="polisyip" ) {
            var newip = val.trim();
            if ( newip ) {
                polisyip = newip;
            }
            result.uname = uname;
        } else if ( key==="uname" ) {
            uname = val.trim();
            if ( uname==="" ) {
                uname = olduname;
            }
            result.uname = uname;
        } else if ( key==="pword" ) {
            val = val.trim();
            if ( val!=="" ) {
                hash = pw_hash(val);
            } else {
                hash = "";
            }
        }
    }

    // now that we have all the new facts, set up password field
    // process username and password settings and save in skin specific loc
    // includes logic to bundle the skin with this user so that
    // now each user can use their own skin if they want

    // if password field is blank and user name is the same, keep old password
    if ( olduname===uname && hash==="" ) {
        hash = oldhash;
    }
    GLB.options.config["uname"] = uname;

    // 
    // set the skin and replace the custom file with that skin's version
    // but first check to make sure it is a valid name
    if ( !fs.existsSync(skin + "/housepanel.css") ) {
        skin = defskin;
        if ( !fs.existsSync(skin + "/housepanel.css") ) {
            skin = "skin-housepanel";
        }
    }

    // make sure our default skin has a custom file
    if ( !fs.existsSync(skin + "/customtiles.css") ) {
        writeCustomCss(skin, "");
    }
    // set default skin to this skin - although it shouldn't be used ever
    GLB.options["config"]["skin"] = skin;


    // save the skin in my user specific setting
    GLB.options.config["pword"][uname] = [hash, skin];
    GLB.options.config["skin"] = skin;
    GLB.options.config["polisyip"] = polisyip;

    GLB.pwcrypt = hash;

    // set some return values
    result.hash = hash;
    result.skin = skin;
    if ( DEBUG3 ) {
        console.log( (ddbg()), "saveuserpw processed: ", result, " uname: ", uname, " oldpw: ", oldhash, " newpw: ", hash, " polisyip: ", polisyip);
    }

    // write options to file
    writeOptions( GLB.options, true);

    return result;
}

// process user options page
function processOptions($optarray) {

    if (DEBUG4) {
        console.log( (ddbg()), "Process Options - Before Processing");
        console.log( (ddbg()), UTIL.inspect(GLB.options, false, null, false));
    }
    var specialtiles = utils.getSpecials();
    var options = clone(GLB.options);

    // start with a blank slate
    options["things"] = {};
    for( var $room in GLB.options["rooms"]) {
        options["things"][$room] = [];  // clone(GLB.options["things"][$roomname]);
    }

    // var $oldoptions = clone(GLB.options);
    var configoptions = options["config"];
    var $roomnames = Object.keys(options["rooms"]);
    if ( !is_object(configoptions["specialtiles"]) ) {
        configoptions["specialtiles"] = {};
    }

    // // use clock instead of blank for default only tile
    var $onlytile = GLB.options["index"]["clock|clockdigital"];
    var onlyarr = [$onlytile,0,0,1,""];

    // // checkbox items simply will not be there if not selected
    configoptions["kiosk"] = "false";
    configoptions["rules"] = "false";

    // force all three to be given for change to happen
    var $city = "";
    var $region = "";
    var $code = "";
    var fcastcity = "";
    var fcastregion = "";
    var fcastcode = "";

    // // get all the rooms checkboxes and reconstruct list of active things
    // // note that the list of checkboxes can come in any random order
    for (var key in $optarray) {
        var $val = $optarray[key];

        //skip the returns from the submit button and the flag
        if (key==="options" || key==="api" || key==="useajax" ) {
            continue;
        } else if ( key==="kiosk") {
            configoptions["kiosk"] = "true";
        } else if ( key==="rules") {
            configoptions["rules"] = ENABLERULES ? "true" : "false";
        } else if ( key==="accucity" ) {
            $city = $val.trim();
        } else if ( key==="accuregion" ) {
            $region = $val.trim();
        } else if ( key==="accucode" ) {
            $code = $val.trim();
        } else if ( key==="fcastcity" ) {
            fcastcity = $val.trim();
        } else if ( key==="fcastregion" ) {
            fcastregion = $val.trim();
        } else if ( key==="fcastcode" ) {
            fcastcode = $val.trim();
        
        // handle user selected special tile count
        } else if ( key.substr(0,4)==="cnt_" ) {
            var $stype = key.substr(4);
            if ( array_key_exists($stype, specialtiles) ) {
                var $spid = specialtiles[$stype][0];
                var $customcnt = parseInt($val);
                createSpecialIndex($customcnt, $stype, $spid);
                configoptions["specialtiles"] = clone(GLB.options["config"]["specialtiles"]);
                
            }
        
        // made this more robust by checking room name being valid
        } else if ( in_array(key, $roomnames) && is_array($val) ) {
            var $roomname = key;
            
            // first save the existing order of tiles if still there
            // this will preserve user drag and drop positions
            // but if a tile is removed then all tiles after it will be
            // shown shifted as a result
            var $lasttop = 0;
            var $lastleft = 0;
            var $lastz = 1;

            // first put all existing tiles in the room
            // this retains the existing order
            GLB.options["things"][$roomname].forEach(function(newtile) {
                var tnum = parseInt(newtile[0]);
                var rnum = array_search(tnum, $val);
                if ( rnum!==false ) {
                    options["things"][$roomname].push(newtile);
                }
            });

            // get the index offset of last existing tile
            if ( options["things"][$roomname].length > 0 ) {
                var lastitem = options["things"][$roomname].length -1;
                var arr = options["things"][$roomname][lastitem];
                $lasttop = arr[1];
                $lastleft = arr[2];
                $lastz = arr[3];

                // set position to next to last one unless it is moved a lot
                // the 400 distance is subjective but works in most cases
                if ( $lasttop < -400 || $lasttop > 400 || $lastleft < -400 || $lastleft > 400 ) {
                    $lasttop = 0;
                    $lastleft = 0; 
                }
            }

            // add any new ones that were not there before
            $val.forEach(function($tilestr) {
                var tilenum = parseInt($tilestr);
                if ( inroom(tilenum, GLB.options["things"][$roomname]) === false ) {
                    var newtile = [tilenum,$lasttop,$lastleft, $lastz, ""];
                    options["things"][$roomname].push(newtile);
                }
            });

            var rmnum = options["rooms"][$roomname];
            // put a clock in a room if it is empty
            if ( options["things"][$roomname].length === 0  ) {
                options["things"][$roomname].push(onlyarr);
            }
        }
    }
    
    // everything from this point on is after processing the options table
    // start by handling the weather
    if ( $city && $region && $code ) {
        configoptions["accucity"] = $city;
        configoptions["accuregion"] = $region;
        configoptions["accucode"] = $code;
        writeAccuWeather($city, $region, $code);

    }
    if ( fcastcity && fcastcode ) {
        configoptions["fcastcity"] = fcastcity;
        configoptions["fcastregion"] = fcastregion;
        configoptions["fcastcode"] = fcastcode;
        writeForecastWidget(fcastcity, fcastregion, fcastcode);
    }
    
    // save the configuration parameters in the main options array
    options["config"] = configoptions;
    
    if (DEBUG4) {
        console.log( (ddbg()), "Process Options - After Processing");
        console.log( (ddbg()), UTIL.inspect(GLB.options, false, null, false));
    }

    // write options to file
    writeOptions(options);
}

function changePageName(oldname, newname) {
 
    var retcode = "success - testing";
    var options = GLB.options;

    if ( oldname && newname && oldname!==newname && array_key_exists(oldname, options["rooms"]) ) {

        // set new room to the number of the old room
        options["rooms"][newname] = options["rooms"][oldname];

        // create a new set of things tied to the new room name
        options["things"][newname] = [];
        var things = options["things"][oldname];
        things.forEach(function(tile, k) {
            if ( is_array(tile) ) {
                var newtile = clone(tile);
                options["things"][newname].push(newtile);
            }
        });

        // delete the old room and thing list
        delete options["rooms"][oldname];
        delete options["things"][oldname];
        retcode = "success - Renamed room: " + oldname + " to: " + newname;
        if ( DEBUG1 ) {
            // console.log( (ddbg()), "changePageNmae: ", UTIL.inspect(options.things[newname]));
            console.log( (ddbg()), retcode);
        }
        writeOptions(options, false);
    } else {
        retcode = "error - old page: " + oldname + " new page: " + newname;
        console.log( (ddbg()), retcode);
    }
    return retcode;
}

function updateNames(type, tileid, newname) {
    var result;
    var oldname = "";
    if ( type === "page" ) {
        newname = newname.replace(/ /g, "_");
        oldname = tileid;
        result = changePageName(oldname, newname);
    } else {
        var options = GLB.options;
        var updcss = false;
        var nupd = 0;
        tileid = parseInt(tileid);

        // if the name is blank, reset it to original
        newname = newname.trim();
        var resetname = false;
        var idx = array_search(tileid, options["index"]);
        if ( newname==="" ) {
            newname = allthings[idx]["name"];
            resetname = true;
        } else {
            allthings[idx].value.name = newname;
        }

        for (var room in options["things"]) {
            var things = options["things"][room];
        
            // look for matching options item
            // and update to new value if it changed
            // also guard against old style that wasn't an array
            // or arrays that were not at least 4 elements long
            // the 4th element of the array is the custom name
            things.forEach(function(tiles, k) {
                if ( is_array(tiles) && parseInt(tiles[0]) === tileid && 
                     (resetname || (tiles.length>3 && tiles[4]!==newname))  ) {

                    oldname = tiles[4];
                    tiles[4] = newname;

                    // update the things names in room lists
                    options["things"][room][k] = tiles;

                    nupd++;
                    updcss = true;
                }

            });
        }
        if ( updcss ) {
            writeOptions(options);
            result = "success " + nupd.toString() + " names changed for type= " + type + " oldname= " + oldname + " newname= " + newname;
        } else {
            result = "warning - nothing updated for type= " + type + " oldname= " + oldname + " newname= " + newname;
        }
    }
    return result;
}

function getIcons(icondir, category) {
    var skin = getSkin();

    if ( !icondir ) {
        icondir = "icons";
    }
    if ( !category ) {
        category = "";
    }

    // change over to where our icons are located
    var activedir = path.join(__dirname, skin, icondir);

    // TODO - get function to return a directory listing
    // $dirlist = scandir($activedir);
    var dirlist = fs.readdirSync(activedir);
    var allowed = ["png","jpg","jpeg","gif"];
    var $tc = "";

    dirlist.forEach( function(filename) {
        var froot = path.basename(filename);
        var ext = path.extname(filename).slice(1);
        var filedir = path.join(skin, icondir, froot);

        if ( in_array(ext, allowed) ) {
            $tc += '<div class="cat ' + category + '">';
            $tc += '<img src="' + filedir +'" class="icon" title="' + froot + '" />';
            $tc += '</div>';
        }
    });
    return $tc;
}

function pw_hash(pword) {

    var hash;
    if ( typeof pword !== "string"  || !pword || !pword.trim() ) {
        hash = "";
    } else {
        pword = pword.trim();
        var thehash = crypto.createHash("sha256");
        thehash.update(pword);
        hash = thehash.digest('hex');
    }
    return hash;
}

function pw_verify(pword, hash) {
    return (pw_hash(pword) === hash);
}

// the swval here is actually custom type
function addCustom(swid, swtype, customtype, customval, subid) {
    var reserved = ["index","rooms","things","config","control","time","useroptions"];
    var options = GLB.options;
    var userid = "user_" + swid;

    // legacy custom types
    if ( array_key_exists(swid, options) && 
            !in_array (swid, reserved) && 
            !array_key_exists(userid, options) ) {
        userid = swid;
    }

    var oldcustoms;
    if ( array_key_exists(userid, options) ) {
        oldcustoms = clone(options[userid]);
    } else {
        oldcustoms = [];
    }

    // handle encryption
    customval = customval.toString();
    subid = subid.toString();
    if ( subid==="password" ) {
        customval = pw_hash(customval);
    }
    
    var newitem = [customtype, customval, subid];
    var newoptitem = [];
    var doneit = false;

    oldcustoms.forEach( function(val) {
        if ( val[2].toString() === subid ) {
            if ( !doneit ) {
                newoptitem.push(newitem);
                doneit = true;
            }
        } else {
            newoptitem.push(val);
        }
    });

    if ( !doneit ) {
        newoptitem.push(newitem);
    }

    options[userid] = newoptitem;
    writeOptions(options);
    var idx = swtype + "|" + swid;
    
    // make the new custom field using the updated options above
    var thingval = allthings[idx]["value"];
    thingval = getCustomTile(thingval, swtype, swid);
    thingval = returnFile(thingval, swtype);

    // save it in the main array - no need for sessions in Node
    allthings[idx]["value"] = thingval;

    return thingval;
}

function delCustom(swid, swtype, swval, swattr, subid) {
    var reserved = ["index","rooms","things","config","control","useroptions"];
    var userid = "user_" + swid;

    swattr = swattr.toString();
    subid = subid.toString();

    // legacy custom types
    if ( array_key_exists(swid, GLB.options) && 
            !in_array (swid, reserved) && 
            !array_key_exists(userid, GLB.options) ) {
        userid = swid;
    }

    if ( array_key_exists(userid, GLB.options) ) {

        var oldlines = clone(GLB.options[userid]);
        if ( ! is_array(oldlines[0]) ) {
            oldlines = [oldlines];
        }

        // make new list of customs without the deleted item
        var lines = [];
        oldlines.forEach( function(newitem) {
            if ( newitem[2].toString() !== subid ) {
                lines.push(newitem);
            }
        });

        // either remove or update the main options array
        if ( lines.length === 0 ) {
            delete GLB.options[userid];
        } else {
            GLB.options[userid] = lines;
        }

        writeOptions(GLB.options);
    }
    
    var idx = swtype + "|" + swid;
    var companion = "user_" + subid;
    var thingval = allthings[idx]["value"];
    
    // remove this field and any companion if it exists
    delete thingval[subid];
    if ( array_key_exists(companion, thingval) ) {
        delete thingval[companion];
    }

    // save here before calling because these routines use this array
    allthings[idx]["value"] = thingval;

    // make the new custom field using the updated options above
    // thingval = returnFile(thingval, swtype);
    thingval = getCustomTile(thingval, swtype, swid);
    thingval = returnFile(thingval, swtype);
   
    // save it in the main array - no need for sessions in Node
    allthings[idx]["value"] = thingval;
    return thingval;
}

function apiCall(body, protocol) {
    if ( DEBUG8 ) {
        console.log( (ddbg()), protocol + " api call, body: ", UTIL.inspect(body, false, null, true) );
    }
    var hubs = GLB.options.config["hubs"];

    if ( body['useajax'] ) {
        var api = body['useajax'];
    } else {
        api = body['api'] || "";
    }
    var swid = body["id"] || "none";
    var swtype = body["type"] || "none";
    var swval = body["value"] || "";
    var swattr = body["attr"] || "";
    var subid = body["subid"] || "";
    var tileid = body["tile"] || body["tileid"] || "";
    var command = body["command"] || "";
    var linkval = body["linkval"] || "";

    // send mqtt message
    if ( udclient && udclient.connected ) {
        udclient.publish("housepanel/apiCall", JSON.stringify(body, null, 1));
    }
 
    if ( hubs && hubs.length ) {
        var defhub = hubs[0]["hubId"];
    } else {
        defhub = "-1";
    }
    var hubid = body["hubid"] || "auto";
    if ( body["hubnum"] ) {
        var hubnum = parseInt(body["hubnum"]);
        if ( !isNaN(hubnum) && hubnum >=0 && hubnum < hubs.length ) {
            hubid = hubs[hubnum]["hubId"];
        } else {
            hubid = "auto";
        }
    }

    // handle multiple api calls but only for tiles since nobody would ever give a list of long id's
    if ( tileid && tileid.indexOf(",") !== -1 ) {
        var multicall = true;
        var tilearray = tileid.split(",");
    } else {
        multicall = false;
    }

    var result;
    switch (api) {
        
        case "doaction":
        case "action":
            if ( multicall ) {
                result = [];
                tilearray.forEach(function(atile) {
                    if ( DEBUG8 ) {
                        console.log( (ddbg()), "doaction multicall: hubid: ", hubid, " swid: ", swid, " swval: ", swval, " swattr: ", swattr, " subid: ", subid, " atile: ", atile);
                    }
                    var aresult = doAction("auto", "", "", swval, swattr, subid, atile, "", "", protocol);
                    result.push(aresult);
                });
            } else {
                if ( DEBUG8 ) {
                    console.log( (ddbg()), "doaction: hubid: ", hubid, " swid: ", swid, " swval: ", swval, " swattr: ", swattr, " subid: ", subid, " tileid: ", tileid);
                }
                result = doAction(hubid, swid, swtype, swval, swattr, subid, tileid, command, linkval, protocol);
            }
            break;
            
        case "doquery":
        case "query":
            if ( multicall ) {
                result = [];
                tilearray.forEach(function(atile) {
                    var aresult = doQuery("auto", "", "", atile, protocol);
                    result.push(aresult);
                });
            } else {
                result = doQuery(hubid, swid, swtype, tileid, protocol);
            }
            break;

        case "status":
        case "dostatus":
            var activehubs = GLB.options.config ? utils.count(GLB.options.config.hubs) : 0;
            var thingcount = utils.count(allthings);
            var username = GLB.options.config.uname || "";
            result = {"state": "active", "hubs": activehubs, "clients": clients.length, "things": thingcount, "username": username};
            break;

        case "wysiwyg2":
            // if we sorted the user fields in the customizer, save them
            if ( protocol==="POST" ) {
                if ( is_array(swattr) ) {
                    GLB.options["user_" + swid] = swattr;
                    writeOptions(GLB.options);
                }
                var idx = swtype + "|" + swid;
                var thing = allthings[idx];
                result = makeThing(0, tileid, thing, "wysiwyg", 0, 0, 99, "", api);
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
            break;

        case "wysiwyg":
            if ( swtype==="page" ) {
                // make the fake tile for the room for editing purposes
                var faketile = {"panel": "panel", "name": swval, "tab": "Tab Inactive", "tabon": "Tab Selected"};
                var thing = { "id": "r_" + swid, "name": swval, 
                              "hubnum": "-1", "type": "page", "value": faketile};
                result = makeThing(0, tileid, thing, "wysiwyg", 0, 0, 99, "", api);
            } else {
                var idx = swtype + "|" + swid;
                var thing = allthings[idx];
                
                // load customizations
                // thing.value = getCustomTile(thing.value, swtype, swid);
                // allthings[idx] = thing;            
                result = makeThing(0, tileid, thing, "wysiwyg", 0, 0, 99, "", api);
            }
            break;

        case "pageorder":
            result = setOrder(swid, swtype, swval, swattr);
            break;

        case "dragdrop":
            if ( protocol==="POST" ) {
                result = setPosition(swid, swtype, swval, swattr);
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
            break;

        case "dragmake":
            if ( protocol==="POST" ) {
                result = addThing(swid, swtype, swval, "auto");
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
            break;
    
        case "dragdelete":
            if ( protocol==="POST" ) {
                result = delThing(swid, swtype, swval, swattr);
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
            break;

        case "pagedelete":
            if ( protocol==="POST" ) {
                result = delPage(swval);
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
            break;
    
        case "pageadd":
            if ( protocol==="POST" ) {
                result = addPage();
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
            break;

        case "catalog":
        case "getcatalog":
            result = getCatalog(swattr);
            break;
            
        case "refactor":
            if ( protocol==="POST" ) {
                // TODO: this does not yet work so it was removed from menu
                // note really needed any more - it just renumbers tiles
                // the same effect can be had by deleting your hmoptions.cfg file
                // but this will remove all customizations. This routine attempted to save them but it isn't working right now
                // refactorOptions();
                // getAllThings(true);
                result = "success";
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
            break;
    
        case "refreshpage":
            if ( protocol==="POST" ) {
                getAllThings(true);
                result = "success";
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
            break;
        
        // the GUI will never ask to reload options but a user might when making an api call
        case "options":
        case "getoptions":
            if ( swattr==="reload" ) {
                readOptions("getoptions");
            }
            result = GLB.options;
            break;
        
        // the GUI currently does not make use of this api call
        case "putoptions":
            if ( protocol==="POST" ) {
                if ( swval && is_object(swval) ) {
                    writeOptions(swval);
                }
                result = GLB.options;
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
            break;

        case "sortupdate":
            if ( protocol==="POST" ) {
                var idx = swtype + "|" + swid;
                var uid = swattr;
                if ( uid && array_key_exists(uid, GLB.options) && swval && is_array(swval) ) {
                    GLB.options[uid] = swval;
                    allthings[idx]["value"] = getCustomTile(allthings[idx]["value"], swtype, swid);
                    writeOptions(GLB.options);
                    result = allthings[idx]["value"];
                } else {
                    result = "error - invalid request to update user Options";
                }
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
            break;

        // this returns the existing things and optionally updates them
        // the update will not be returned but could be retrieved on a second separate call
        case "getallthings":
        case "getthings":
        case "things":
            result = clone(allthings);
            if ( swattr==="reload" ) {
                getAllThings(true);
            }
            break;
                
        case "hubs":
        case "gethubs":
           result = hubs;
           break;

        case "filteroptions":
            if ( protocol==="POST" ) {
                result = saveFilters(body);
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
        break;

        case "saveuserpw":
            if ( protocol==="POST" ) {
                result = saveUserPw(body);
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
            break;

        case "savetileedit":
            if ( protocol==="POST" ) {
                var n1 = parseInt(body["n1"]);
                var nlen = parseInt(body["nlen"]);
                var n2 = parseInt(body["n2"]);
                if ( isNaN(n1) || isNaN(n2) || isNaN(nlen) ) {
                    result = "error - invalid call to savetileedit. n1= " + n1 + " n2= " + n2 + " nlen= " + nlen;
                } else {
                    if ( DEBUG16 ) {
                        console.log( (ddbg()), "savetile: n1= " + n1 + " n2= " + n2 + " nlen= " + nlen );
                    }
                    if ( n1=== 0 ) {
                        GLB.newcss = "";
                    }
                    GLB.newcss += decodeURI(swval);

                    // write if this is last segment
                    result = "success - " + n2.toString();
                    if ( n2=== nlen ) {
                        if ( DEBUG16 ) {
                            console.log("\n----------------------------------------------------------\n", GLB.newcss);
                            console.log("\n----------------------------------------------------------\n");
                        }
                        writeCustomCss(getSkin(), GLB.newcss);
                    }
                }
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
            break;

        case "saveoptions":
            if ( protocol==="POST" ) {
                processOptions(body);
                result = "success";
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
            break;

        case "updatenames":
            // value (swval) is new name, tileid is oldname for pages
            if ( protocol==="POST" ) {
                result = updateNames(swtype, tileid, swval);
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
            break;
        
        case "dologin":
            if ( protocol==="POST" ) {
                var uname = body["uname"].trim();
                var pword = body["pword"].trim();
                if ( pword!=="" ) {
                    var thehash = crypto.createHash("sha256");
                    thehash.update(pword);
                    pword = thehash.digest('hex');
                }
                GLB.options["config"]["uname"] = uname;
                writeOptions(GLB.options, true);

                // check to see if the provided username is valid
                // and that the passwords match
                result = "error";
                var pwords = GLB.options["config"]["pword"];

                if ( DEBUG2 ) {
                    console.log( (ddbg()), "dologin: uname= ", uname, " pword: [", pword, "] body: ", body, " pwords: ", pwords);
                }

                // check for matching passwords
                if ( array_key_exists(uname, pwords ) ) {
                    var pw = pwords[uname];
                    if ( pw[0] === pword || IGNOREPW ) {
                        GLB.pwcrypt = pw[0];
                    } else {
                        GLB.pwcrypt = false;
                    }
                    result = "success";
                }
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
            break;

        case "pwhash":
            result;
            if ( swtype==="hash" ) {
                result = pw_hash(swval);
            } else if ( swtype==="verify" ) {
                if ( pw_verify(swval, swattr) ) {
                    result = "success";
                } else {
                    result = "error";
                }
            } else {
                result = "error";
            }
            break;

        case "addcustom":
            if ( protocol==="POST" ) {
                result = {}
                result.value = addCustom(swid, swtype, swval, swattr, subid);
                readOptions("addcustom");
                result.options = GLB.options;
                result.things = allthings;
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
            break;

        case "delcustom":
            if ( protocol==="POST" ) {
                result = {}
                result.value = delCustom(swid, swtype, swval, swattr, subid);
                readOptions("delcustom");
                result.options = GLB.options;
                result.things = allthings;
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
            break;

        case "updcustom":
            if ( protocol==="POST" ) {
                result = {}
                // tile customizer has updated the list of options
                // this api call is used to update things so we stay in sync
                readOptions("updcustom");
                result.options = GLB.options;
                var idx = swtype + "|" + swid;
                var pvalue = allthings[idx].value;
                pvalue = getCustomTile(pvalue, swtype, swid);
                pvalue = returnFile(pvalue, swtype);
                allthings[idx]["value"] = pvalue;
                result.things = allthings;
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
            break;
                
        case "icons":
        case "geticons":
            result = getIcons(swval, swattr);
            break;

        case "hubauth":

            if ( protocol==="POST" ) {

                // now load the new data
                var hub = {};
                hub["hubType"] = body.hubType;
                hub["hubHost"] = body.hubHost;
                hub["clientId"] = body.clientId;
                hub["clientSecret"] = body.clientSecret;
                hub["userAccess"] = body.userAccess;
                hub["userEndpt"] = body.userEndpt;
                hub["hubName"] = body.hubName;
                hub["hubId"] = body.hubId;
                hub["hubAccess"] = body.hubAccess;
                hub["hubEndpt"] = body.hubEndpt;
                hub["hubTimer"] = body.hubTimer;

                // fix up host if http wasn't given
                if ( !hub["hubHost"].toLowerCase().startsWith("http") ) {
                    hub["hubHost"] = "http://" + hub["hubHost"];
                }

                // if user provides hub access info, use it
                // for ISY hubs we know the endpoint as /rest so use it
                if ( body.hubType==="ISY" ) {
                    body.userEndpt = hub["hubHost"] + "/rest";
                    hub["userEndpt"] = body.userEndpt;
                }

                // if this is a new hub and no name given, give it one
                if ( body.hubId==="new" && hub["hubName"].trim()==="" ) {
                    hub["hubName"] = hub["hubType"];
                }

                if ( body.userEndpt ) {
                    // remove trailing slash if it is there
                    if ( body.userEndpt.substr(-1) === "/" ) {
                        body.userEndpt = body.userEndpt.substr(0, body.userEndpt.length -1);
                    }
                    hub["hubEndpt"] = body.userEndpt;
                    if (body.hubType==="ISY") {
                        body.userAccess = body.clientId + ":" + body.clientSecret;
                        hub["userAccess"] = body.userAccess;
                        hub["hubAccess"] = body.userAccess;

                        // get the number of ISY hubs already configured
                        // if the id is given this means the hub exists
                        if ( body.hubId==="new" ) {
                            var newhubnum = 1;
                            hubs.forEach(function(ahub) {
                                if ( ahub.hubType==="ISY" && ahub.hubId!=="new" ) {
                                    newhubnum++;
                                }
                            });
                            
                            if ( newhubnum < 10 ) {
                                hub.hubId = "isy0" + newhubnum.toString();
                            } else {
                                hub.hubId = "isy" + newhubnum.toString();
                            }
                            body.hubId = hub.hubId;
                            
                            // use default name if one not given
                            if ( hub["hubName"].trim()==="" ) {
                                hub["hubName"] = "ISY";
                            }

                        } else {
                            hub.hubId = body.hubId;
                        }

                    }
                }

                if ( body.userAccess && body.hubType!=="ISY" ) {
                    hub["hubAccess"] = body.userAccess;
                }

                // update existing or add a new hub
                updateHubs(hub, body.hubId);
                writeOptions(GLB.options, true);
                hubs = GLB.options.config.hubs;

                if (DEBUG2) {
                    console.log( (ddbg()), "There are " + hubs.length + " hubs available after hubauth.");
                    console.log( (ddbg()), "hubs: ", hubs);
                }

                // now authorize them
                // handle direct access including ISY hubs first
                var hubnum = hub["hubId"];
                var hubName = hub["hubName"];
                var hubType = hub["hubType"];
                var host = hub["hubHost"];
                var clientId = hub["clientId"];
                var clientSecret = hub["clientSecret"];
                GLB.defhub = hubnum;

                if ( (hub["userAccess"] && hub["userEndpt"]) || body.hubType==="ISY" ) {

                    // get all new devices and update the options index array
                    // this forces page reload with all the new stuff
                    // notice the reference to /reauth in the call to getDevices
                    // this makes the final read redirect back to reauth page
                    var accesstoken  = hub["hubAccess"];
                    var hubEndpt = hub["hubEndpt"];

                    // for ISY we can go right to getting devices
                    // for ST and HE we need to use getHubInfo to first get hubId and hubName
                    // and then we call devices from there given the async nature of Node
                    // this is much like what happens in the getAccessToken function in the OAUTH flow
                    // console.log("hubType= ", hubType);
                    if ( hubType==="ISY" ) {
                        // console.log("get devices...");
                        getDevices(hubnum, hubType, accesstoken, hubEndpt, clientId, clientSecret, hubName, true, "/reauth");
                    } else {
                        getHubInfo(hub, accesstoken, hubEndpt, clientId, clientSecret);
                    }

                    // writeOptions(GLB.options, true);
                    // getDevices(hubnum, hubType, accesstoken, hubEndpt, clientId, clientSecret, hubName, true, "/reauth");
                    result = {action: "things", hubType: hubType, hubName: hubName};
                    if ( DEBUG2 ) {
                        console.log( (ddbg()), "Device retrieval initiated: ", result);
                    }

                // here we start an oauth flow
                // we complete the flow later when redirection happens back to /oauth GET call
                } else {
                    var returnloc = GLB.returnURL + "/oauth";
                    result = {action: "oauth", host: host, hubName: hubName, clientId: clientId, clientSecret: clientSecret, url: returnloc};
                    if ( DEBUG2 ) {
                        console.log( (ddbg()), "OAUTH flow initiated: ", result);
                    }
                }
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
    
            break;
    
        case "hubdelete":
            // TODO - implement hubDelete() function
            console.log( (ddbg()), "Hub deletion is not yet supported...");
            result = "success";
            break;

        case "getclock":
            if ( !swid || swid==="none" ) { swid = "clockdigital"; }
            result = getClock(swid);
            result = getCustomTile(result, "clock", swid);
            // replace any links with stored link values
            // otherwise update the main array with new time info
            for (var rsubid in result) {
                var rvalue = result[rsubid];
                var idx = "clock|" + swid;
                if ( rvalue && rvalue.startsWith("LINK::") ) {
                    result[rsubid] = allthings[idx]["value"][rsubid];
                } else {
                    allthings[idx]["value"][rsubid] = rvalue;
                }
            }
            break;

        case "cancelauth":
        case "showoptions":
        case "showid":
        case "reauth":
        case "showid":
        case "logout":
        case "trackupdate":
                var result = "error - [" + api + "] API call is no longer supported. Try loading browser with: " + GLB.returnURL + "/" + api;
                console.log( (ddbg()), result);
                break;

        case "reload":
            pushClient("reload", "/");
            break;

        case "reset":
            if ( protocol==="GET" ) {
                readOptions("reset");
                GLB.options.config["pword"] = {};
                GLB.options.config["pword"]["default"] = ["", "skin-housepanel"];
                GLB.options.config["uname"] = "default";
                GLB.pwcrypt = true;
                writeOptions(GLB.options, true);
                pushClient("reload", "/logout");
                result = getLoginPage();
            } else {
                result = "error - api call [" + api + "] is not supported in " + protocol + " mode.";
            }
            break;

        default:
            result = "error - unrecognized " + protocol + " api call: " + api;
            break;
    }
    return result;

}

function setupSockets() {

    var wsServer;
    var serverlistening;
    var config = GLB.options.config;

    // create the HTTP server for handling sockets
    var server = http.createServer(function(req, res) {});

    // set up server for a two way socket communication with the browser
    if ( server && config.webSocketServerPort ) {
        // create the webSocket server
        wsServer = new webSocketServer({httpServer: server });
        server.listen(config.webSocketServerPort, function() {
            console.log( (ddbg()), "webSocket Server is listening on port: ", config.webSocketServerPort);
        });
        serverlistening = true;
    } else {
        serverlistening = false;
        console.log( (ddbg()), "webSocket could not be established. webSocketServerPort= ", config.webSocketServerPort);
    }

    // This function handles new connections, messages from connections, and closed connections
    if ( wsServer && serverlistening ) {
        wsServer.on('request', function(request) {
            console.log( (ddbg()), 'Requesting websocket connection: ', request.origin);
            request.accept(null, request.origin); 
        });

        wsServer.on('message', function(request) {
            console.log( (ddbg()), 'websocket msg data: ', request.data );
        });

        wsServer.on('connect', function(connection) {
            console.log( (ddbg()), 'Connecting websocket. Addresses: ', connection.remoteAddresses );

            // shut down any existing connections to same remote host
            var host = connection.socket.remoteAddress;
            var i = 0;
            while ( i < clients.length ) {
                var oldhost = clients[i].socket.remoteAddress;
                if ( oldhost===host ) {
                    clients.splice(i, 1);
                } else {
                    i++;
                }
            }

            // report index of the connection
            // we no longer rely on this to close prior connections
            // instead we just shut down any that match
            var index = clients.push(connection) - 1;
            console.log( (ddbg()), 'Connection accepted. Client #' + index, " host: ", host, " Client count: ", clients.length);

            // send client number to the javascript so it knows its index
            // pushClient("client", "client");

            // user disconnected - remove all clients that match this socket
            connection.on('close', function(reason, description) {
                var host = connection.socket.remoteAddress;
                console.log( (ddbg()), "Peer: ", host, " disconnected. for: ", reason, " desc: ", description);

                // remove clients that match this host
                // clients.splice(indexsave, 1);
                var i = 0;
                while ( i < clients.length ) {
                    var oldhost = clients[i].socket.remoteAddress;
                    if ( oldhost===host ) {
                        clients.splice(i, 1);
                    } else {
                        i++;
                    }
                }
            });

        });
    }

    // make websocket connection to any ISY hub
    // unlike ST and HE below, communication from ISY happens over a real webSocket
    var wshost;
    for (var h in GLB.options.config["hubs"]) {
        var hub = GLB.options.config["hubs"][h];
        wshost = false;
        if ( hub["hubType"]==="ISY" && hub["hubEndpt"] && hub["hubAccess"] ) { 

            var hubhost = hub["hubEndpt"];
            if ( hubhost.startsWith("https://") ) {
                wshost = "wss://" + hubhost.substr(8);
            } else if ( hubhost.startsWith("http://") ) {
                wshost = "ws://" + hubhost.substr(7);
            }
        }

        // set up socket for ISY hub if one is there
        if ( wshost ) {
            var wsclient = new webSocketClient();
            var buff = Buffer.from(hub["hubAccess"]);
            var base64 = buff.toString('base64');
            var origin = "com.universal-devices.websockets.isy";
            var header = {"Authorization": "Basic " + base64, "Sec-WebSocket-Protocol": "ISYSUB",  
                        "Sec-WebSocket-Version": "13", "Origin": "com.universal-devices.websockets.isy"};
            wshost = wshost + "/subscribe";

            wsclient.on("connectFailed", function(err) {
                console.log( (ddbg()), "Connection failure to ISY socket: ", err.toString(), " wshost: ", wshost, " header: ", header);
            });

            wsclient.on("connect", function(connection) {
                console.log( (ddbg()), "Success connecting to ISY socket. Listening for messages...");

                // handle incoming state messages from ISY
                // this will be ignored if the node isn't in our list
                connection.on("message", function(msg) {
                    if ( msg.type==="utf8" ) {
                        processIsyMessage(msg.utf8Data);
                    }
                });
            
                connection.on("error", function(err) {
                    console.log( (ddbg()), "Connection error to ISY socket: ", err.toString());
                });
            
                connection.on("close", function() {
                    console.log( (ddbg()), "Connection closed to ISY socket");
                });
            
            });

            wsclient.connect(wshost, "ISYSUB", origin, header);
        }
    }

}

// ***************************************************
// beginning of main routine
// ***************************************************
var d = new Date();
var hpcode = d.getTime();
GLB.hpcode = hpcode.toString();

// setup rule dup avoider
resetRules();

// read the config file and get array of hubs
readOptions("startup");
if ( DEBUG4 ) {
    console.log( (ddbg()), "Index: ", UTIL.inspect(GLB.options, false, null, false));
}

var uname = getUserName();
try {
    GLB.pwcrypt = GLB.options.config.pword[uname][0];
} catch (e) {
    GLB.pwcrypt = (IGNOREPW || GLB.newuser) ? true : false;
}

var config = GLB.options.config;
var port = config["port"];
if ( !port ) {
    port = 3080;
}
GLB.defhub = "-1";

// start our main server
try {
    // the Node.js app loop - can be invoked by client or back end
    app = express();
    app.use(bodyParser.json());
    app.use(bodyParser.urlencoded({ extended: true }));
    var dir = path.join(__dirname, '');
    app.use(express.static(dir));

    // list on the port
    app.listen(port, function () {
        console.log((ddbg()), "HousePanel Node.js Server is running on port: ", port);
    });
    applistening = true;
    
} catch (e) {
    console.log((ddbg()), 'HousePanel Node.js Server could not be started on port: ', port);
    app = null;
    applistening = false;
}

// retrieve all nodes/things
// client pages are refreshed when each hub is done reading
if ( app && applistening ) {
    getAllThings(true);

    var maxroom = 0;
    if ( array_key_exists("things", GLB.options) && 
        array_key_exists("rooms", GLB.options) ) {
        var thingoptions = GLB.options["things"];
        for (var roomname in thingoptions) {
            var thinglist = thingoptions[roomname];
            if ( thinglist.length > maxroom ) {
                maxroom = thinglist.length;
            }
        }
    }
    
    // handler functions for HousePanel
    // this is where we render the baseline web page for the dashboard
    // define all the mime types that can be rendered
    var mime = {
        html: 'text/html',
        txt: 'text/plain',
        css: 'text/css',
        gif: 'image/gif',
        jpg: 'image/jpeg',
        png: 'image/png',
        svg: 'image/svg+xml',
        js: 'application/javascript'
    };

    app.get('*', function (req, res) {
        
        var $tc;

        if ( req.path==="/" || typeof req.path==="undefined" || req.path==="/undefined" || req.path==="undefined" ) {

            // read options upon a reload
            // readOptions();
            uname = getUserName();
            
            // set the global variable so other functions can return here
            var queryobj = req.query || {};
            var isquery = (utils.count(queryobj) > 0);

            // allow user to manually reset things with this code
            // the hub auth flow is handled with the /reauth path later below
            // this removes all user accounts and logs everyone out
            if ( isquery && queryobj.code && (queryobj.code==="reset") ) {
                readOptions();
                GLB.options.config["pword"] = {};
                GLB.options.config["pword"]["default"] = ["", "skin-housepanel"];
                GLB.options.config["uname"] = "default";
                GLB.pwcrypt = true;
                writeOptions(GLB.options, true);
                pushClient("reload", "/logout");
                $tc = "Logging out all clients..."; // getLoginPage();

            // handle user provided get api calls
            } else if ( isquery ) {
                $tc = apiCall(queryobj, "GET");

            // display the main page if password matches
            // or if we don't have a pw
            } else if ( IGNOREPW || GLB.newuser || GLB.pwcrypt===true || (array_key_exists(uname, GLB.options.config["pword"]) && GLB.pwcrypt===GLB.options.config["pword"][uname][0]) ) {
                // reset for next refresh
                GLB.defhub = "-1";
                
                // set this to always see new user welcome message
                // otherwise, comment it out
                // GLB.newuser = true;

                GLB.pwcrypt===config["pword"][uname][0];
                if ( DEBUG2 ) {
                    console.log( (ddbg()), "login accepted. uname = ", uname, " pwcrypt = ", GLB.pwcrypt);
                }
                if ( DEBUG15 ) {
                    console.log("allthings before render: \n", UTIL.inspect(allthings, false, null, false) );
                    console.log("options before render: \n", UTIL.inspect(GLB.options, false, null, false) );
                }
                $tc = mainPage(req.protocol, req.headers.host, req.path);

            } else {
                console.log( (ddbg()), "login rejected. uname= ", uname, " pwcrypt= ", GLB.pwcrypt, " configpw= ", GLB.options.config["pword"][uname][0]);
                $tc = getLoginPage();
            }
            res.send($tc);
            res.end();

        } else if ( req.path==="/showid") {
            $tc = getInfoPage(GLB.returnURL, req.path);
            res.send($tc);
            res.end();

        } else if ( req.path==="/showoptions") {
            readOptions();
            $tc = getOptionsPage(req.path);
            res.send($tc);
            res.end();

        } else if ( req.path==="/logout") {
            // readOptions();
            $tc = getLoginPage();
            GLB.pwcrypt = false;
            res.send($tc);
            res.end();

        } else if ( req.path==="/reauth") {
            // readOptions();
            d = new Date();
            hpcode = d.getTime();
            GLB.hpcode = hpcode.toString();
            var $tc = getAuthPage(req.headers.host, GLB.hpcode);
            res.send($tc);
            res.end();

        } else if ( req.path==="/oauth") {
            var queryobj = req.query || {};
            if ( queryobj["code"] ) {
                var hubnum = GLB.defhub;
                var hub = findHub(hubnum);

                // get token, endpt, and retrieve devices
                // this goes through a series of callbacks
                // and ends with a pushClient to update the auth page
                getAccessToken(queryobj["code"], hub);
            } else {
                GLB.defhub = "-1";
            }
            d = new Date();
            hpcode = d.getTime();
            GLB.hpcode = hpcode.toString();
            var $tc = getAuthPage(req.headers.host, GLB.hpcode);
            res.send($tc);
            res.end();

        } else if ( req.path==="/reset") {
            readOptions();
            getAllThings(true);
            res.send("Resetting...");
            res.end();

        } else {
            var file = path.join(dir, req.path.replace(/\/$/, '/index.html'));
            if (file.indexOf(dir + path.sep) !== 0) {
                res.status(403).end('Forbidden');
            }
            if ( DEBUG1 ) {
                console.log( (ddbg()), " Loading module: ", req.path, " as: ", file);
            }
            var type = mime[path.extname(file).slice(1)] || 'text/plain';
            var s = fs.createReadStream(file);
            s.on('open', function () {
                res.set('Content-Type', type);
                // res.type(type)
                s.pipe(res);
            });
            s.on('error', function () {
                res.set('Content-Type', 'text/plain');
                res.status(404).end(req + ' Not found');
            });
        }
    });
    
    app.put('*', function(req, res) {
        console.log( (ddbg()), "PUT api calls not yet supported. requested put: ", req.path);
        res.end();
    });

    // *********************************************************************************************
    // these are server treatments for processing updates
    // from SmartThings and Hubitat hubs
    // this is done in the "changeHandler" function
    // found in the HousePanel.groovy application with this line
    //     postHub(state.directIP, state.directPort, "update", deviceName, deviceid, attr, value)
    // *********************************************************************************************
    
    app.post("/", function (req, res) {

        // handle two types of messages posted from hub
        // the first initialize type tells Node.js to update elements
        if ( req.body['msgtype'] === "initialize" ) {
            res.json('hub info updated');
            if ( DEBUG2 ) {
                console.log( (ddbg()), "New hub authorized; updating things in hpserver.");
            }
            readOptions();
            getAllThings(true);
        
        // handle callbacks from ST and HE here
        // for ISY this is done via websockets above
        } else if ( req.body['msgtype'] === "update" ) {
            if ( DEBUG2 ) {
                console.log( (ddbg()), "Received update msg from hub: ", req.body["hubid"], " body: ", req.body);
            }
            var msg = processHubMessage(req.body);
            if ( DEBUG17 ) {
                console.log( (ddbg()), msg );
            }
            res.json(msg);

        // handle all api calls upon the server from js client and external api calls here
        } else if ( typeof req.body['useajax']!=="undefined" || typeof req.body["api"]!=="undefined" ) {
            var result = apiCall(req.body, "POST");
            res.json(result);
        
        // handle unknown requests
        } else {
            console.log((ddbg()) + "hpserver received unknown message.", req.body);
            res.json('hpserver received unknown message.');
        }

    });

    // set up sockets
    setupSockets();
}

// set up a MQTT connections to Polisy broker to listen in on Polyglot messages
// also use this to send debug notices about HousePanel to myself
// setup mqtt client
var udclient = null;
var polisyip = GLB.options.config["polisyip"] || "";

// console.log("hostname: ", os.hostname(), " platform: ", os.platform() );
var hostname;
if ( os.hostname()==="polisy" && os.platform()==="freebsd" ) {
    hostname = "localhost";
} else if ( polisyip ) {
    hostname = polisyip;
} else {
    hostname = null;
}

if ( hostname && fs.existsSync("ssl/polyglot.crt") && fs.existsSync("ssl/client.crt") && fs.existsSync("ssl/client_private.key") ) {
    var ca = fs.readFileSync("ssl/polyglot.crt");
    var cert = fs.readFileSync("ssl/client.crt");
    var key = fs.readFileSync("ssl/client_private.key");
    var udopts = {host: hostname, port: "1883",
                ca: ca, cert: cert, key: key,
                checkServerIdentity: () => { return null; },
                rejectUnauthorized: false};
    udclient = mqtt.connect("mqtts://192.168.11.32", udopts);
}

if ( udclient ) {
    udclient.on("message", function(topic, msg) {
        if ( topic.startsWith("udi/polyglot/frontend/nodeservers") ) {
            try {
                var frontend = JSON.parse(msg.toString());
                console.log( (ddbg()), topic,  " ", frontend.nodeservers.length + " nodeservers");
                frontend.nodeservers.forEach( function(node) {
                    console.log("slot: ", node.profileNum, " name: ", node.name, " file: ", node.homeDir + node.executable);
                });
            } catch(e) {
                console.log("error - trying to decipher MQTT message from polyglot frontend", e);
            }
        } else {
            if ( topic.startsWith("housepanel/") ) {
                console.log( (ddbg()), topic, "msg: ", msg.toString() );
            } else if ( topic.startsWith("udi/polyglot/") ) {
                var str = JSON.parse(msg.toString());
                console.log( (ddbg()), topic, "msg: ", JSON.stringify(str, null, 1) );
            } else {
                console.log("mqtt topic: ", topic, " msg: ", msg.toString() );
            }
        }
    });

    udclient.on("error", function(err) {
        console.log("UDI MQTT error: ", err);
    });

    udclient.on("connect", function() {
        if ( MQTTPOLY ) {
            udclient.subscribe("udi/#", {qos: 0}, function(err, granted) {
                if ( !err ) {
                    console.log("MQTT subscribed to: ", granted );
                    udclient.publish("udi", "UDI mqtt setup and listening...");
                } else {
                    console.log("UDI MQTT error subscribing to udi topic: ", err);
                }
            });
        }

        // lets also subscribe to our own HP publishing calls
        if ( MQTTHP ) {
            udclient.subscribe("housepanel/#", {qos: 0}, function(err, granted) {
                if ( !err ) {
                    console.log("MQTT subscribed to: ", granted );
                    udclient.publish("housepanel", "HousePanel mqtt setup and listening...");
                } else {
                    console.log("MQTT error subscribing to housepanel topic: ", err);
                }
            });
        }

        console.log("UDI mqtt status: ", udclient.connected);
    });
}
